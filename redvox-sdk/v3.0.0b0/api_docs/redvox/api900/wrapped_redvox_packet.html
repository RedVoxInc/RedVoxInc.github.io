<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>redvox.api900.wrapped_redvox_packet API documentation</title>
<meta name="description" content="This module contains classes and methods for working with WrappedRedvoxPackets" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.api900.wrapped_redvox_packet</code></h1>
</header>
<section id="section-intro">
<p>This module contains classes and methods for working with WrappedRedvoxPackets</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable=C0302
&#34;&#34;&#34;
This module contains classes and methods for working with WrappedRedvoxPackets
&#34;&#34;&#34;

import os
import typing

import redvox.api900.concat
import redvox.common.date_time_utils as date_time_utils
import redvox.api900.lib.api900_pb2 as api900_pb2
import redvox.api900.migrations as migrations
import redvox.api900.reader_utils as reader_utils
import redvox.api900.sensors.accelerometer_sensor as _accelerometer_sensor
import redvox.api900.sensors.barometer_sensor as _barometer_sensor
import redvox.api900.sensors.gyroscope_sensor as _gyroscope_sensor
import redvox.api900.sensors.image_sensor as _image_sensor
import redvox.api900.sensors.infrared_sensor as _infrared_sensor
import redvox.api900.sensors.light_sensor as _light_sensor
import redvox.api900.sensors.location_sensor as _location_sensor
import redvox.api900.sensors.magnetometer_sensor as _magnetometer_sensor
import redvox.api900.sensors.microphone_sensor as _microphone_sensor
import redvox.api900.sensors.time_synchronization_sensor as _time_synchronization_sensor
from redvox.api900.sensors.evenly_sampled_channel import EvenlySampledChannel
from redvox.api900.sensors.unevenly_sampled_channel import UnevenlySampledChannel


def read_buffer(buf: bytes, is_compressed: bool = True) -&gt; api900_pb2.RedvoxPacket:
    &#34;&#34;&#34;
    Deserializes a serialized protobuf RedvoxPacket buffer.
    :param buf: Buffer to deserialize.
    :param is_compressed: Whether or not the buffer is compressed or decompressed.
    :return: Deserialized protobuf redvox packet.
    &#34;&#34;&#34;
    buffer = reader_utils.lz4_decompress(buf) if is_compressed else buf
    redvox_packet = api900_pb2.RedvoxPacket()
    redvox_packet.ParseFromString(buffer)
    return redvox_packet


# pylint: disable=R0904
class WrappedRedvoxPacket:
    &#34;&#34;&#34;
    This class provides convenience methods for accessing API 900 protobuf redvox packets.

    This packet contains a reference to the original packet which should be used to access all &#34;top-level&#34; fields. For
    accessing channels, this class can search for and return our high-level channel wrappers or can extract the payload
    directly.
    &#34;&#34;&#34;

    def __init__(self, redvox_packet: api900_pb2.RedvoxPacket = None):
        &#34;&#34;&#34;
        Initializes this wrapped redvox packet.
        :param redvox_packet: A protobuf redvox packet.
        &#34;&#34;&#34;
        if redvox_packet is None:
            self._redvox_packet = api900_pb2.RedvoxPacket()
            self._evenly_sampled_channels_field = list()
            self._unevenly_sampled_channels_field = list()
            self._metadata_list = list()
            self._channel_cache = {}

        else:
            self._redvox_packet: api900_pb2.RedvoxPacket = redvox_packet
            &#34;&#34;&#34;Protobuf api 900 redvox packet&#34;&#34;&#34;

            self._evenly_sampled_channels_field: typing.List[EvenlySampledChannel] = list(
                map(EvenlySampledChannel, reader_utils.repeated_to_array(redvox_packet.evenly_sampled_channels)))
            &#34;&#34;&#34;List of evenly sampled channels&#34;&#34;&#34;

            self._unevenly_sampled_channels_field: typing.List[UnevenlySampledChannel] = list(
                map(UnevenlySampledChannel,
                    reader_utils.repeated_to_array(redvox_packet.unevenly_sampled_channels)))
            &#34;&#34;&#34;List of unevenly sampled channels&#34;&#34;&#34;

            self._metadata_list: typing.List[str] = reader_utils.repeated_to_list(redvox_packet.metadata)
            &#34;&#34;&#34;List of metadata&#34;&#34;&#34;

            self._channel_cache: typing.Dict[int, typing.Union[EvenlySampledChannel, UnevenlySampledChannel]] = {}
            &#34;&#34;&#34;Holds a mapping of channel type to channel for O(1) access.&#34;&#34;&#34;

            # Initialize channel cache
            for evenly_sampled_channel in self._evenly_sampled_channels_field:
                for channel_type in evenly_sampled_channel.channel_types:
                    self._channel_cache[channel_type] = evenly_sampled_channel

            for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
                for channel_type in unevenly_sampled_channel.channel_types:
                    self._channel_cache[channel_type] = unevenly_sampled_channel

    def redvox_packet(self) -&gt; api900_pb2.RedvoxPacket:
        &#34;&#34;&#34;
        returns the protobuf redvox packet
        :return: protobuf redvox packet
        &#34;&#34;&#34;
        return self._redvox_packet

    def _evenly_sampled_channels(self) -&gt; typing.List[EvenlySampledChannel]:
        &#34;&#34;&#34;
        returns the evenly sampled channels as a copied list to avoid built in functions making untracked changes
        :return: list of evenly sampled channels
        &#34;&#34;&#34;
        return self._evenly_sampled_channels_field.copy()

    def _unevenly_sampled_channels(self) -&gt; typing.List[UnevenlySampledChannel]:
        &#34;&#34;&#34;
        returns the unevenly sampled channels as a copied list to avoid built in functions making untracked changes
        :return: list of unevenly sampled channels
        &#34;&#34;&#34;
        return self._unevenly_sampled_channels_field.copy()

    def _refresh_channels(self):
        &#34;&#34;&#34;
        takes the redvox packet and rebuilds the channel cache from it
        &#34;&#34;&#34;
        self._evenly_sampled_channels_field = list(map(EvenlySampledChannel,
                                                       reader_utils.repeated_to_array(
                                                           self._redvox_packet.evenly_sampled_channels)))
        self._unevenly_sampled_channels_field = list(map(UnevenlySampledChannel,
                                                         reader_utils.repeated_to_array(
                                                             self._redvox_packet.unevenly_sampled_channels)))
        self._channel_cache = {}
        for evenly_sampled_channel in self._evenly_sampled_channels_field:
            for channel_type in evenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = evenly_sampled_channel
        for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
            for channel_type in unevenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = unevenly_sampled_channel

    def _add_channel(self, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        &#34;&#34;&#34;
        Add a channel
        :param channel: channel to add
        &#34;&#34;&#34;
        index, sample = self._find_channel(channel.channel_types[0])
        if index is None and sample is None:
            # if type(channel) not in [EvenlySampledChannel, UnevenlySampledChannel]:
            if not isinstance(channel, (EvenlySampledChannel, UnevenlySampledChannel)):
                raise TypeError(&#34;Channel type to add must be even or uneven.&#34;)
            else:
                self._add_channel_redvox_packet(channel)
                self._refresh_channels()
        else:
            raise ValueError(&#34;Cannot add a channel with a type that already exists in this packet.&#34;)

    def _edit_channel(self, channel_type: int, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        &#34;&#34;&#34;
        removes the channel with the given type and adds the channel supplied
        :param channel_type: type of channel to remove
        :param channel: the channel to add
        &#34;&#34;&#34;
        index, sampling = self._find_channel(channel_type)
        if index is not None and sampling is not None:
            if isinstance(channel, EvenlySampledChannel):
                del self._redvox_packet.evenly_sampled_channels[index]
                self._add_channel_redvox_packet(channel)
            elif isinstance(channel, UnevenlySampledChannel):
                del self._redvox_packet.unevenly_sampled_channels[index]
                self._add_channel_redvox_packet(channel)
            else:
                raise TypeError(&#34;Channel type to edit is unknown!&#34;)
            self._refresh_channels()
        else:
            raise TypeError(&#34;Unknown channel type specified for edit.&#34;)

    def _delete_channel(self, channel_type: int):
        &#34;&#34;&#34;
        deletes the channel type specified
        :param channel_type: a channel to remove
        &#34;&#34;&#34;
        index, sampling = self._find_channel(channel_type)
        if index is not None and sampling is not None:
            if sampling == EvenlySampledChannel:
                del self._redvox_packet.evenly_sampled_channels[index]
            else:
                del self._redvox_packet.unevenly_sampled_channels[index]
            self._refresh_channels()
        else:
            raise TypeError(&#34;Unknown channel type to remove from packet.&#34;)

    # pylint: disable=W0120
    def _find_channel(self, channel_type: int) -&gt; (int, typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        &#34;&#34;&#34;
        returns the index of the channel and the kind of sampled array its in
        :return: the index in the even or uneven array and the name of the array
        &#34;&#34;&#34;
        if self._has_channel(channel_type):
            for idx in range(len(self._evenly_sampled_channels_field)):
                if channel_type in self._evenly_sampled_channels_field[idx].channel_types:
                    return idx, EvenlySampledChannel
            for idx in range(len(self._unevenly_sampled_channels_field)):
                if channel_type in self._unevenly_sampled_channels_field[idx].channel_types:
                    return idx, UnevenlySampledChannel
            else:
                return None, None
        else:
            return None, None

    # pylint: disable=R0912
    def _add_channel_redvox_packet(self, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        &#34;&#34;&#34;
        adds the channel to the redvox_packet
        :param channel: channel to add
        &#34;&#34;&#34;
        if isinstance(channel, EvenlySampledChannel):
            newchan = self._redvox_packet.evenly_sampled_channels.add()
            newchan.sample_rate_hz = channel.sample_rate_hz
            newchan.first_sample_timestamp_epoch_microseconds_utc = \
                channel.first_sample_timestamp_epoch_microseconds_utc
        elif isinstance(channel, UnevenlySampledChannel):
            newchan = self._redvox_packet.unevenly_sampled_channels.add()
            for time in channel.timestamps_microseconds_utc:
                newchan.timestamps_microseconds_utc.append(time)
            newchan.sample_interval_mean = channel.sample_interval_mean
            newchan.sample_interval_std = channel.sample_interval_std
            newchan.sample_interval_median = channel.sample_interval_median
        else:
            raise TypeError(&#34;Channel type to add to redvox packet is unknown!&#34;)

        pl_type = channel.get_payload_type()
        if pl_type == &#34;byte_payload&#34;:
            newchan.byte_payload.payload.extend(channel.payload)
        elif pl_type == &#34;uint32_payload&#34;:
            newchan.uint32_payload.payload.extend(channel.payload)
        elif pl_type == &#34;uint64_payload&#34;:
            newchan.uint64_payload.payload.extend(channel.payload)
        elif pl_type == &#34;int32_payload&#34;:
            newchan.int32_payload.payload.extend(channel.payload)
        elif pl_type == &#34;int64_payload&#34;:
            newchan.int64_payload.payload.extend(channel.payload)
        elif pl_type == &#34;float32_payload&#34;:
            newchan.float32_payload.payload.extend(channel.payload)
        elif pl_type == &#34;float64_payload&#34;:
            newchan.float64_payload.payload.extend(channel.payload)
        elif pl_type is None:
            pass
        else:
            raise TypeError(&#34;Unknown payload type in channel to add.&#34;)

        for chan_type in channel.channel_types:
            newchan.channel_types.append(chan_type)
        newchan.sensor_name = channel.sensor_name
        for mean in channel.value_means:
            newchan.value_means.append(mean)
        for stds in channel.value_stds:
            newchan.value_stds.append(stds)
        for median in channel.value_medians:
            newchan.value_medians.append(median)
        for meta in channel.metadata:
            newchan.metadata.append(meta)

    def _get_channel_types(self) -&gt; typing.List[typing.List[int]]:
        &#34;&#34;&#34;
        Returns a list of channel type enumerations. This is a list of lists, and allows us to easily view
        interleaved channels.
        :return: A list of channel type enumerations.
        &#34;&#34;&#34;
        channel_types = []
        for evenly_sampled_channel in self._evenly_sampled_channels_field:
            channel_types.append(evenly_sampled_channel.channel_types)

        for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
            channel_types.append(unevenly_sampled_channel.channel_types)

        return channel_types

    def _get_channel_type_names(self) -&gt; typing.List[typing.List[str]]:
        &#34;&#34;&#34;
        Returns a list of channel type names. This is a list of lists, and allows us to easily view
        interleaved channels.
        :return: A list of channel type names. This is a list of lists, and allows us to easily view
        interleaved channels.
        &#34;&#34;&#34;
        names = []
        for channel_types in self._get_channel_types():
            names.append(list(map(reader_utils.channel_type_name_from_enum, channel_types)))
        return names

    def _get_channel(self, channel_type: int) -&gt; typing.Union[EvenlySampledChannel, UnevenlySampledChannel, None]:
        &#34;&#34;&#34;
        Returns a channel from this packet according to the channel type.
        :param channel_type: The channel type to search for.
        :return: A high level channel wrapper or None.
        &#34;&#34;&#34;
        if channel_type in self._channel_cache:
            return self._channel_cache[channel_type]

        return None

    def _has_channel(self, channel_type: int) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if this packet contains a channel with this type otherwise False.
        :param channel_type: Channel type to search for.
        :return: True is this packet contains a channel with this type otherwise False.
        &#34;&#34;&#34;
        return channel_type in self._channel_cache

    def _has_channels(self, channel_types: typing.List[int]) -&gt; bool:
        &#34;&#34;&#34;
        Checks that this packet contains all of the provided channels.
        :param channel_types: Channel types that this packet must contain.
        :return: True if this packet contains all provided channel types, False otherwise.
        &#34;&#34;&#34;
        has_channel_results = map(self._has_channel, channel_types)
        for has_channel_result in has_channel_results:
            if not has_channel_result:
                return False
        return True

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;
        Converts the protobuf packet stored in this wrapped packet to JSON.
        :return: The JSON representation of the protobuf encoded packet.
        &#34;&#34;&#34;
        return reader_utils.to_json(self._redvox_packet)

    def compressed_buffer(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the compressed buffer associated with this packet.
        :return: The compressed buffer associated with this packet.
        &#34;&#34;&#34;
        return reader_utils.lz4_compress(self._redvox_packet.SerializeToString())

    def default_filename(self, extension: str = &#34;rdvxz&#34;) -&gt; str:
        &#34;&#34;&#34;
        Constructs a default filename from the packet&#39;s metadata.
        :param extension: An optional extension to use.
        :return: A default filename from the packet&#39;s metadata.
        &#34;&#34;&#34;
        return &#34;%s_%d.%s&#34; % (self.redvox_id(), int(round(self.app_file_start_timestamp_machine() / 1000.0)), extension)

    def write_rdvxz(self, directory: str, filename: typing.Optional[str] = None):
        &#34;&#34;&#34;
        Writes a compressed .rdvxz file to the specified directory.
        :param directory: The directory to write the file to.
        :param filename: An optional filename (the default filename will be used if one is not provided).
        &#34;&#34;&#34;
        filename = self.default_filename() if filename is None else filename
        path = os.path.join(directory, filename)
        with open(path, &#34;wb&#34;) as rdvxz_out:
            rdvxz_out.write(self.compressed_buffer())

    def write_json(self, directory: str, filename: typing.Optional[str] = None):
        &#34;&#34;&#34;
        Writes a RedVox compliant .json file to the specified directory.
        :param directory: The directory to write the file to.
        :param filename: An optional filename (the default filename will be used if one is not provided).
        &#34;&#34;&#34;
        filename = self.default_filename(extension=&#34;json&#34;) if filename is None else filename
        path = os.path.join(directory, filename)
        with open(path, &#34;w&#34;) as json_out:
            json_out.write(self.to_json())

    def clone(self) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Returns a clone of this WrappedRedvoxPacket.
        :return: A clone of this WrappedRedvoxPacket.
        &#34;&#34;&#34;
        return WrappedRedvoxPacket(read_buffer(self.compressed_buffer(), True))

    def concat(self, wrapped_redvox_packets: typing.List[&#39;WrappedRedvoxPacket&#39;]) -&gt; typing.List[&#39;WrappedRedvoxPacket&#39;]:
        &#34;&#34;&#34;
        Concatenates this packet with other packets.
        :param wrapped_redvox_packets: Other packets to concatenate with this packet.
        :return: A list of packets each containing a continuous set of data.
        &#34;&#34;&#34;
        return redvox.api900.concat.concat_wrapped_redvox_packets([self] + wrapped_redvox_packets)

    # Start of packet level API getters and setters
    def api(self) -&gt; int:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(self._redvox_packet.api)

    def set_api(self, version: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the api version number
        :param version: version number
        &#34;&#34;&#34;
        self._redvox_packet.api = version
        return self

    def uuid(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.uuid

    def set_uuid(self, uid: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the uuid
        :param uid: uuid string
        &#34;&#34;&#34;
        self._redvox_packet.uuid = uid
        return self

    def redvox_id(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.redvox_id

    def set_redvox_id(self, rid: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the redvox id
        :param rid: redvox id string
        &#34;&#34;&#34;
        self._redvox_packet.redvox_id = rid
        return self

    def authenticated_email(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.authenticated_email

    def set_authenticated_email(self, email: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the authenticated email
        :param email: authenticated email string
        &#34;&#34;&#34;
        self._redvox_packet.authenticated_email = email
        return self

    def authentication_token(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.authentication_token

    def set_authentication_token(self, token: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the authentication token
        :param token: authentication token string
        &#34;&#34;&#34;
        self._redvox_packet.authentication_token = token
        return self

    def firebase_token(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.firebase_token

    def set_firebase_token(self, token: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the firebase token
        :param token: firebase token string
        &#34;&#34;&#34;
        self._redvox_packet.firebase_token = token
        return self

    def is_backfilled(self) -&gt; bool:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.is_backfilled

    def set_is_backfilled(self, tof: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the is_backfilled flag
        :param tof: true or false
        &#34;&#34;&#34;
        self._redvox_packet.is_backfilled = tof
        return self

    def is_private(self) -&gt; bool:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.is_private

    def set_is_private(self, tof: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the is_private flag
        :param tof: true or false
        &#34;&#34;&#34;
        self._redvox_packet.is_private = tof
        return self

    def is_scrambled(self) -&gt; bool:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.is_scrambled

    def set_is_scrambled(self, tof: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the is_scrambled flag
        :param tof: true or false
        &#34;&#34;&#34;
        self._redvox_packet.is_scrambled = tof
        return self

    def device_make(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_make

    def set_device_make(self, make: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the make of the device
        :param make: make of the device string
        &#34;&#34;&#34;
        self._redvox_packet.device_make = make
        return self

    def device_model(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_model

    def set_device_model(self, model: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the model of the device
        :param model: model of the device string
        &#34;&#34;&#34;
        self._redvox_packet.device_model = model
        return self

    def device_os(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_os

    def set_device_os(self, device_os: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the device operating system
        :param device_os: operating system string
        &#34;&#34;&#34;
        self._redvox_packet.device_os = device_os
        return self

    def device_os_version(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_os_version

    def set_device_os_version(self, version: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the device OS version
        :param version: device OS version string
        &#34;&#34;&#34;
        self._redvox_packet.device_os_version = version
        return self

    def app_version(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.app_version

    def set_app_version(self, version: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the app version number
        :param version: app version string
        &#34;&#34;&#34;
        self._redvox_packet.app_version = version
        return self

    def battery_level_percent(self) -&gt; float:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.battery_level_percent

    def set_battery_level_percent(self, percent: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the percentage of battery left
        :param percent: percentage of battery left
        &#34;&#34;&#34;
        self._redvox_packet.battery_level_percent = percent
        return self

    def device_temperature_c(self) -&gt; float:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_temperature_c

    def set_device_temperature_c(self, temp: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the device temperature in degrees Celsius
        :param temp: temperature in degrees Celsius
        &#34;&#34;&#34;
        self._redvox_packet.device_temperature_c = temp
        return self

    def acquisition_server(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.acquisition_server

    def set_acquisition_server(self, server: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the acquisition server url
        :param server: url to acquisition server
        &#34;&#34;&#34;
        self._redvox_packet.acquisition_server = server
        return self

    # pylint: disable=invalid-name
    def time_synchronization_server(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.time_synchronization_server

    def set_time_synchronization_server(self, server: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the time synchronization server url
        :param server: url to time synchronization server
        &#34;&#34;&#34;
        self._redvox_packet.time_synchronization_server = server
        return self

    def authentication_server(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.authentication_server

    def set_authentication_server(self, server: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the authentication server url
        :param server: url to authentication server
        &#34;&#34;&#34;
        self._redvox_packet.authentication_server = server
        return self

    # pylint: disable=invalid-name
    def app_file_start_timestamp_epoch_microseconds_utc(self) -&gt; int:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc)

    def set_app_file_start_timestamp_epoch_microseconds_utc(self, time: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the timestamp of packet creation
        :param time: time when packet was created in microseconds since utc epoch
        &#34;&#34;&#34;
        self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc = migrations.maybe_set_int(time)
        return self

    # pylint: disable=invalid-name
    def app_file_start_timestamp_machine(self) -&gt; int:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(self._redvox_packet.app_file_start_timestamp_machine)

    def set_app_file_start_timestamp_machine(self, time: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the internal machine timestamp of packet creation
        :param time: time when packet was created on local machine
        &#34;&#34;&#34;
        self._redvox_packet.app_file_start_timestamp_machine = migrations.maybe_set_int(time)
        return self

    # pylint: disable=invalid-name
    def server_timestamp_epoch_microseconds_utc(self) -&gt; int:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(self._redvox_packet.server_timestamp_epoch_microseconds_utc)

    def set_server_timestamp_epoch_microseconds_utc(self, time: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the server timestamp when the packet was received
        :param time: time when packet was received by server
        &#34;&#34;&#34;
        self._redvox_packet.server_timestamp_epoch_microseconds_utc = time
        return self

    def metadata(self) -&gt; typing.List[str]:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._metadata_list

    def set_metadata(self, data: typing.List[str]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the metadata
        :param data: metadata as list of strings
        &#34;&#34;&#34;
        self._metadata_list = data
        self._redvox_packet.metadata[:] = data
        return self

    def _clear_metadata(self):
        &#34;&#34;&#34;
        removes all of the packet level metadata from packet
        &#34;&#34;&#34;
        del self._redvox_packet.metadata[:]
        self._metadata_list.clear()

    def metadata_as_dict(self) -&gt; typing.Dict[str, str]:
        &#34;&#34;&#34;
        Return this packet&#39;s metadata as a key-value Python dictionary.
        :return: This packet&#39;s metadata as a key-value Python dictionary.
        &#34;&#34;&#34;
        return reader_utils.get_metadata_as_dict(self._metadata_list)

    def set_metadata_as_dict(self, metadata_dict: typing.Dict[str, str]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the metadata using a dictionary.
        :param metadata_dict: Dictionary of metadata.
        :return: This WrappedRedvoxPacket.
        &#34;&#34;&#34;
        self.set_metadata(reader_utils.metadata_dict_to_list(metadata_dict))
        return self

    def add_metadata(self, key: str, value: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Adds a key pair value to the metadata.
        :param key: The key.
        :param value: The value.
        :return: This instance of a WrappedRedvoxPacket.
        &#34;&#34;&#34;
        metadata = self.metadata_as_dict()
        metadata[key] = value if isinstance(value, str) else str(value)
        self.set_metadata_as_dict(metadata)
        return self

    def start_timestamp_us_utc(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the start timestamp of a WrappedRedvoxPacket.
        :return: The start timestamp of a WrappedRedvoxPacket.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(
            self.microphone_sensor().first_sample_timestamp_epoch_microseconds_utc())

    def duration_s(self) -&gt; float:
        &#34;&#34;&#34;
        The duration of this WrappedRedvoxPacket in seconds.
        :return: The duration of this WrappedRedvoxPacket in seconds.
        &#34;&#34;&#34;
        microphone_sensor = self.microphone_sensor()
        return len(microphone_sensor.payload_values()) / microphone_sensor.sample_rate_hz()

    def end_timestamp_us_utc(self) -&gt; float:
        &#34;&#34;&#34;
        Returns the end timestamp of a WrappedRedvoxPacket.
        :return: The end timestamp of a WrappedRedvoxPacket.
        &#34;&#34;&#34;
        return self.start_timestamp_us_utc() + date_time_utils.seconds_to_microseconds(self.duration_s())

    def update_uneven_sensor_timestamps(self, time_delta: int or float):
        &#34;&#34;&#34;
        Given a time delta in microseconds, will adjust all unevenly sampled sensor timestamps by that amount.
        Use negative values to adjust backwards in time.
        :param time_delta: amount of time to adjust timestamps in microseconds
        &#34;&#34;&#34;
        for channel in self._unevenly_sampled_channels_field:
            if not channel.has_channel(api900_pb2.TIME_SYNCHRONIZATION):
                channel.set_timestamps_microseconds_utc(channel.timestamps_microseconds_utc + time_delta)

    def mach_time_zero(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;
        Returns the mach time zero from the metadata if it exists.
        :return: The mach time zero from the metadata if it exists.
        &#34;&#34;&#34;
        try:
            # First, try to extract metadata from the correct location
            top_level_metadata: typing.Dict[str, str] = self.metadata_as_dict()
            if &#34;machTimeZero&#34; in top_level_metadata:
                return migrations.maybe_get_float(int(top_level_metadata[&#34;machTimeZero&#34;]))

            # If that fails, some Androids stored it in the Location metadata
            location_sensor = self.location_sensor()
            if location_sensor is not None:
                location_metadata: typing.Dict[str, str] = location_sensor.metadata_as_dict()
                if &#34;machTimeZero&#34; in location_metadata:
                    return migrations.maybe_get_float(int(location_metadata[&#34;machTimeZero&#34;]))

            # Finally, if it hasn&#39;t been found, it&#39;s probably a really old packet that doesn&#39;t contain this field
            return None
        except (KeyError, ValueError):
            return None

    def set_mach_time_zero(self, mach_time_zero: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the mach time zero in the packet&#39;s metadata.
        :param mach_time_zero: The mach time zero to use.
        :return: An instance of this wrapped packet.
        &#34;&#34;&#34;
        return self.add_metadata(&#34;machTimeZero&#34;, str(mach_time_zero))

    def best_latency(self) -&gt; typing.Optional[float]:
        &#34;&#34;&#34;
        Returns the best latency from the metadata if it exists.
        :return: The best latency from the metadata if it exists.
        &#34;&#34;&#34;
        try:
            return float(self.metadata_as_dict()[&#34;bestLatency&#34;])
        except (KeyError, ValueError):
            return None

    def set_best_latency(self, best_latency: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the best latency in the packet&#39;s metadata.
        :param best_latency: The best latency to use.
        :return: An instance of this wrapped packet.
        &#34;&#34;&#34;
        return self.add_metadata(&#34;bestLatency&#34;, str(best_latency))

    def best_offset(self) -&gt; typing.Optional[float]:
        &#34;&#34;&#34;
        Returns the best offset from the metadata if it exists.
        :return: The best offset from the metadata if it exists.
        &#34;&#34;&#34;
        try:
            return float(self.metadata_as_dict()[&#34;bestOffset&#34;])
        except (KeyError, ValueError):
            return None

    def set_best_offset(self, best_offset: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the best offset in the packet&#39;s metadata.
        :param best_offset: The best offset to use.
        :return: An instance of this wrapped packet.
        &#34;&#34;&#34;
        return self.add_metadata(&#34;bestOffset&#34;, str(best_offset))

    def is_synch_corrected(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns the isSynchCorrected value from the metadata if it exists.
        :return: The isSynchCorrected value from the metadata if it exists.
        &#34;&#34;&#34;

        def _parse_bool(s: str) -&gt; bool:
            return s == &#34;true&#34; or s == &#34;True&#34;

        try:
            return _parse_bool(self.metadata_as_dict()[&#34;isSynchCorrected&#34;])
        except (KeyError, ValueError):
            return False

    def set_is_synch_corrected(self, is_synch_corrected: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the is_synch_corrected field in the packet&#39;s metadata.
        :param is_synch_corrected: The is_synch_corrected field to use.
        :return: An instance of this wrapped packet.
        &#34;&#34;&#34;
        return self.add_metadata(&#34;isSynchCorrected&#34;, &#34;true&#34; if is_synch_corrected else &#34;false&#34;)

    # Sensor channels
    def has_microphone_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a microphone channel.
        :return: If this packet has a microphone channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.MICROPHONE)

    def microphone_sensor(self) -&gt; typing.Optional[_microphone_sensor.MicrophoneSensor]:
        &#34;&#34;&#34;
        Returns the high-level microphone channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level microphone channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_microphone_sensor():
            return _microphone_sensor.MicrophoneSensor(self._get_channel(api900_pb2.MICROPHONE))

        return None

    def set_microphone_sensor(self, microphone_sensor: typing.Optional[
            _microphone_sensor.MicrophoneSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packets microphone sensor. A channel can be removed by passing in None.
        :param microphone_sensor: An optional instance of a microphone sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_microphone_sensor():
            self._delete_channel(api900_pb2.MICROPHONE)

        if microphone_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(microphone_sensor._evenly_sampled_channel)

        return self

    def has_barometer_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a barometer channel.
        :return: If this packet has a barometer channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.BAROMETER)

    def barometer_sensor(self) -&gt; typing.Optional[_barometer_sensor.BarometerSensor]:
        &#34;&#34;&#34;
        Returns the high-level barometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level barometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_barometer_sensor():
            return _barometer_sensor.BarometerSensor(self._get_channel(api900_pb2.BAROMETER))

        return None

    def set_barometer_sensor(self, barometer_sensor: typing.Optional[
            _barometer_sensor.BarometerSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packets barometer sensor. A channel can be removed by passing in None.
        :param barometer_sensor: An optional instance of a barometer sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_barometer_sensor():
            self._delete_channel(api900_pb2.BAROMETER)

        if barometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(barometer_sensor._unevenly_sampled_channel)

        return self

    def has_location_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a location channel.
        :return: If this packet has a location channel.
        &#34;&#34;&#34;
        return (self._has_channels(
            [api900_pb2.LATITUDE, api900_pb2.LONGITUDE, api900_pb2.ALTITUDE, api900_pb2.SPEED,
             api900_pb2.ACCURACY]) or self._has_channels([api900_pb2.LATITUDE, api900_pb2.LONGITUDE]))

    def location_sensor(self) -&gt; typing.Optional[_location_sensor.LocationSensor]:
        &#34;&#34;&#34;
        Returns the high-level location channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level location channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_location_sensor():
            return _location_sensor.LocationSensor(self._get_channel(api900_pb2.LATITUDE))

        return None

    def set_location_sensor(self,
                            location_sensor: typing.Optional[_location_sensor.LocationSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s location sensor. A channel can be removed by passing in None.
        :param location_sensor: An optional instance of a location sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_location_sensor():
            self._delete_channel(api900_pb2.LATITUDE)

        if location_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(location_sensor._unevenly_sampled_channel)

        return self

    # pylint: disable=invalid-name,C1801
    def has_time_synchronization_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a time synchronization channel.
        :return: If this packet has a time synchronization channel.
        &#34;&#34;&#34;
        if self._has_channel(api900_pb2.TIME_SYNCHRONIZATION):
            ch = _time_synchronization_sensor.TimeSynchronizationSensor(
                self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))
            return len(ch.payload_values()) &gt; 0

        return False

    def time_synchronization_sensor(self) -&gt; typing.Optional[_time_synchronization_sensor.TimeSynchronizationSensor]:
        &#34;&#34;&#34;
        Returns the high-level time synchronization channel API or None if this packet doesn&#39;t contain a channel of
        this type.
        :return: the high-level time synchronization channel API or None if this packet doesn&#39;t contain a channel of
        this type.
        &#34;&#34;&#34;
        if self.has_time_synchronization_sensor():
            return _time_synchronization_sensor.TimeSynchronizationSensor(
                self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))

        return None

    def set_time_synchronization_sensor(self, time_synchronization_sensor: typing.Optional[
            _time_synchronization_sensor.TimeSynchronizationSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s time sync sensor. A channel can be removed by passing in None.
        :param time_synchronization_sensor: An optional instance of a time sync sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_time_synchronization_sensor():
            self._delete_channel(api900_pb2.TIME_SYNCHRONIZATION)

        if time_synchronization_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(time_synchronization_sensor._unevenly_sampled_channel)

        return self

    def has_accelerometer_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has an accelerometer channel.
        :return: If this packet has an accelerometer channel.
        &#34;&#34;&#34;
        return self._has_channels([api900_pb2.ACCELEROMETER_X, api900_pb2.ACCELEROMETER_Y, api900_pb2.ACCELEROMETER_Z])

    def accelerometer_sensor(self) -&gt; typing.Optional[_accelerometer_sensor.AccelerometerSensor]:
        &#34;&#34;&#34;
        Returns the high-level accelerometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level accelerometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_accelerometer_sensor():
            return _accelerometer_sensor.AccelerometerSensor(self._get_channel(api900_pb2.ACCELEROMETER_X))

        return None

    def set_accelerometer_sensor(self,
                                 accelerometer_sensor: typing.Optional[
                                     _accelerometer_sensor.AccelerometerSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s accelerometer sensor. A channel can be removed by passing in None.
        :param accelerometer_sensor: An optional instance of a accelerometer sensor.
        &#34;&#34;&#34;
        if self.has_accelerometer_sensor():
            self._delete_channel(api900_pb2.ACCELEROMETER_X)

        if accelerometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(accelerometer_sensor._unevenly_sampled_channel)

        return self

    def has_magnetometer_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a magnetometer channel.
        :return: If this packet has a magnetometer channel.
        &#34;&#34;&#34;
        return self._has_channels([api900_pb2.MAGNETOMETER_X, api900_pb2.MAGNETOMETER_Y, api900_pb2.MAGNETOMETER_Z])

    def magnetometer_sensor(self) -&gt; typing.Optional[_magnetometer_sensor.MagnetometerSensor]:
        &#34;&#34;&#34;
        Returns the high-level magnetometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level magnetometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_magnetometer_sensor():
            return _magnetometer_sensor.MagnetometerSensor(self._get_channel(api900_pb2.MAGNETOMETER_X))

        return None

    def set_magnetometer_sensor(self,
                                magnetometer_sensor: typing.Optional[
                                    _magnetometer_sensor.MagnetometerSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s magnetomer sensor. A channel can be removed by passing in None.
        :param magnetometer_sensor: An optional instance of a magnetometer sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_magnetometer_sensor():
            self._delete_channel(api900_pb2.MAGNETOMETER_X)

        if magnetometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(magnetometer_sensor._unevenly_sampled_channel)

        return self

    def has_gyroscope_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a gyroscope channel.
        :return: If this packet has a gyroscope channel.
        &#34;&#34;&#34;
        return self._has_channels([api900_pb2.GYROSCOPE_X, api900_pb2.GYROSCOPE_Y, api900_pb2.GYROSCOPE_Z])

    def gyroscope_sensor(self) -&gt; typing.Optional[_gyroscope_sensor.GyroscopeSensor]:
        &#34;&#34;&#34;
        Returns the high-level gyroscope channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level gyroscope channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_gyroscope_sensor():
            return _gyroscope_sensor.GyroscopeSensor(self._get_channel(api900_pb2.GYROSCOPE_X))

        return None

    def set_gyroscope_sensor(self, gyroscope_sensor: typing.Optional[
            _gyroscope_sensor.GyroscopeSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s gyroscope sensor. A channel can be removed by passing in None.
        :param gyroscope_sensor: An optional instance of a gyroscope sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_gyroscope_sensor():
            self._delete_channel(api900_pb2.GYROSCOPE_X)

        if gyroscope_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(gyroscope_sensor._unevenly_sampled_channel)

        return self

    def has_light_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a light channel.
        :return: If this packet has a light channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.LIGHT)

    def light_sensor(self) -&gt; typing.Optional[_light_sensor.LightSensor]:
        &#34;&#34;&#34;
        Returns the high-level light channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level light channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_light_sensor():
            return _light_sensor.LightSensor(self._get_channel(api900_pb2.LIGHT))

        return None

    def set_light_sensor(self, light_sensor: typing.Optional[_light_sensor.LightSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s light sensor. A channel can be removed by passing in None.
        :param light_sensor: An optional instance of a light sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_light_sensor():
            self._delete_channel(api900_pb2.LIGHT)

        if light_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(light_sensor._unevenly_sampled_channel)

        return self

    def has_infrared_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has an infrared channel.
        :return: If this packlet has an infrared channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.INFRARED)

    def infrared_sensor(self) -&gt; typing.Optional[_infrared_sensor.InfraredSensor]:
        &#34;&#34;&#34;
        Returns the high-level infrared channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level infrared channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_infrared_sensor():
            return _infrared_sensor.InfraredSensor(self._get_channel(api900_pb2.INFRARED))

        return None

    def set_infrared_sensor(self,
                            infrared_sensor: typing.Optional[
                                _infrared_sensor.InfraredSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s infrared sensor. A channel can be removed by passing in None.
        :param infrared_sensor: An optional instance of a infrared sensor.
        &#34;&#34;&#34;
        if self.has_infrared_sensor():
            self._delete_channel(api900_pb2.INFRARED)

        if infrared_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(infrared_sensor._unevenly_sampled_channel)

        return self

    def has_image_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has an image channel.
        :return: If this packlet has an image channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.IMAGE)

    def image_sensor(self) -&gt; typing.Optional[_image_sensor.ImageSensor]:
        &#34;&#34;&#34;
        Returns the high-level image channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level image channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_image_sensor():
            return _image_sensor.ImageSensor(self._get_channel(api900_pb2.IMAGE))

        return None

    def set_image_sensor(self, image_sensor: typing.Optional[_image_sensor.ImageSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Set&#39;s the image channel.
        :param image_sensor: Image sensor.
        &#34;&#34;&#34;
        if self.has_image_sensor():
            self._delete_channel(api900_pb2.IMAGE)

        if image_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(image_sensor._unevenly_sampled_channel)

        return self

    def __str__(self):
        &#34;&#34;&#34;
        Returns protobuf&#39;s String representation of this packet.
        :return: Protobuf&#39;s String representation of this packet.
        &#34;&#34;&#34;
        return str(self._redvox_packet)

    def __eq__(self, other):
        return isinstance(other, WrappedRedvoxPacket) and len(self.diff(other)) == 0

    def diff(self, other: &#39;WrappedRedvoxPacket&#39;) -&gt; typing.List[str]:
        &#34;&#34;&#34;
        Finds the differences (if any) between two WrappedRedvoxPackets.
        :param other: The other wrapped redvox packet to compare to.
        :return: A list of differences or an empty list if there are none.
        &#34;&#34;&#34;
        diffs = map(lambda tuple2: reader_utils.diff(tuple2[0], tuple2[1]), [
            (self.api(), other.api()),
            (self.redvox_id(), other.redvox_id()),
            (self.uuid(), other.uuid()),
            (self.authenticated_email(), other.authenticated_email()),
            (self.authentication_token(), other.authentication_token()),
            (self.firebase_token(), other.firebase_token()),
            (self.is_backfilled(), other.is_backfilled()),
            (self.is_private(), other.is_private()),
            (self.is_scrambled(), other.is_scrambled()),
            (self.device_make(), other.device_make()),
            (self.device_model(), other.device_model()),
            (self.device_os(), other.device_os()),
            (self.device_os_version(), other.device_os_version()),
            (self.app_version(), other.app_version()),
            (self.battery_level_percent(), other.battery_level_percent()),
            (self.device_temperature_c(), other.device_temperature_c()),
            (self.acquisition_server(), other.acquisition_server()),
            (self.time_synchronization_server(), other.time_synchronization_server()),
            (self.authentication_server(), other.authentication_server()),
            (self.app_file_start_timestamp_epoch_microseconds_utc(),
             other.app_file_start_timestamp_epoch_microseconds_utc()),
            (self.app_file_start_timestamp_machine(), other.app_file_start_timestamp_machine()),
            (self.server_timestamp_epoch_microseconds_utc(),
             other.server_timestamp_epoch_microseconds_utc()),
            (self.metadata(), other.metadata()),
            (self.microphone_sensor(), other.microphone_sensor()),
            (self.barometer_sensor(), other.barometer_sensor()),
            (self.location_sensor(), other.location_sensor()),
            (self.time_synchronization_sensor(), other.time_synchronization_sensor()),
            (self.accelerometer_sensor(), other.accelerometer_sensor()),
            (self.magnetometer_sensor(), other.magnetometer_sensor()),
            (self.gyroscope_sensor(), other.gyroscope_sensor()),
            (self.light_sensor(), other.light_sensor()),
            (self.infrared_sensor(), other.infrared_sensor())
        ])
        # Filter only out only the differences
        diffs = filter(lambda tuple2: tuple2[0], diffs)
        # Extract the difference string
        diffs = map(lambda tuple2: tuple2[1], diffs)
        return list(diffs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.api900.wrapped_redvox_packet.read_buffer"><code class="name flex">
<span>def <span class="ident">read_buffer</span></span>(<span>buf: bytes, is_compressed: bool = True) ‑> api900_pb2.RedvoxPacket</span>
</code></dt>
<dd>
<div class="desc"><p>Deserializes a serialized protobuf RedvoxPacket buffer.
:param buf: Buffer to deserialize.
:param is_compressed: Whether or not the buffer is compressed or decompressed.
:return: Deserialized protobuf redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_buffer(buf: bytes, is_compressed: bool = True) -&gt; api900_pb2.RedvoxPacket:
    &#34;&#34;&#34;
    Deserializes a serialized protobuf RedvoxPacket buffer.
    :param buf: Buffer to deserialize.
    :param is_compressed: Whether or not the buffer is compressed or decompressed.
    :return: Deserialized protobuf redvox packet.
    &#34;&#34;&#34;
    buffer = reader_utils.lz4_decompress(buf) if is_compressed else buf
    redvox_packet = api900_pb2.RedvoxPacket()
    redvox_packet.ParseFromString(buffer)
    return redvox_packet</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket"><code class="flex name class">
<span>class <span class="ident">WrappedRedvoxPacket</span></span>
<span>(</span><span>redvox_packet: api900_pb2.RedvoxPacket = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class provides convenience methods for accessing API 900 protobuf redvox packets.</p>
<p>This packet contains a reference to the original packet which should be used to access all "top-level" fields. For
accessing channels, this class can search for and return our high-level channel wrappers or can extract the payload
directly.</p>
<p>Initializes this wrapped redvox packet.
:param redvox_packet: A protobuf redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WrappedRedvoxPacket:
    &#34;&#34;&#34;
    This class provides convenience methods for accessing API 900 protobuf redvox packets.

    This packet contains a reference to the original packet which should be used to access all &#34;top-level&#34; fields. For
    accessing channels, this class can search for and return our high-level channel wrappers or can extract the payload
    directly.
    &#34;&#34;&#34;

    def __init__(self, redvox_packet: api900_pb2.RedvoxPacket = None):
        &#34;&#34;&#34;
        Initializes this wrapped redvox packet.
        :param redvox_packet: A protobuf redvox packet.
        &#34;&#34;&#34;
        if redvox_packet is None:
            self._redvox_packet = api900_pb2.RedvoxPacket()
            self._evenly_sampled_channels_field = list()
            self._unevenly_sampled_channels_field = list()
            self._metadata_list = list()
            self._channel_cache = {}

        else:
            self._redvox_packet: api900_pb2.RedvoxPacket = redvox_packet
            &#34;&#34;&#34;Protobuf api 900 redvox packet&#34;&#34;&#34;

            self._evenly_sampled_channels_field: typing.List[EvenlySampledChannel] = list(
                map(EvenlySampledChannel, reader_utils.repeated_to_array(redvox_packet.evenly_sampled_channels)))
            &#34;&#34;&#34;List of evenly sampled channels&#34;&#34;&#34;

            self._unevenly_sampled_channels_field: typing.List[UnevenlySampledChannel] = list(
                map(UnevenlySampledChannel,
                    reader_utils.repeated_to_array(redvox_packet.unevenly_sampled_channels)))
            &#34;&#34;&#34;List of unevenly sampled channels&#34;&#34;&#34;

            self._metadata_list: typing.List[str] = reader_utils.repeated_to_list(redvox_packet.metadata)
            &#34;&#34;&#34;List of metadata&#34;&#34;&#34;

            self._channel_cache: typing.Dict[int, typing.Union[EvenlySampledChannel, UnevenlySampledChannel]] = {}
            &#34;&#34;&#34;Holds a mapping of channel type to channel for O(1) access.&#34;&#34;&#34;

            # Initialize channel cache
            for evenly_sampled_channel in self._evenly_sampled_channels_field:
                for channel_type in evenly_sampled_channel.channel_types:
                    self._channel_cache[channel_type] = evenly_sampled_channel

            for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
                for channel_type in unevenly_sampled_channel.channel_types:
                    self._channel_cache[channel_type] = unevenly_sampled_channel

    def redvox_packet(self) -&gt; api900_pb2.RedvoxPacket:
        &#34;&#34;&#34;
        returns the protobuf redvox packet
        :return: protobuf redvox packet
        &#34;&#34;&#34;
        return self._redvox_packet

    def _evenly_sampled_channels(self) -&gt; typing.List[EvenlySampledChannel]:
        &#34;&#34;&#34;
        returns the evenly sampled channels as a copied list to avoid built in functions making untracked changes
        :return: list of evenly sampled channels
        &#34;&#34;&#34;
        return self._evenly_sampled_channels_field.copy()

    def _unevenly_sampled_channels(self) -&gt; typing.List[UnevenlySampledChannel]:
        &#34;&#34;&#34;
        returns the unevenly sampled channels as a copied list to avoid built in functions making untracked changes
        :return: list of unevenly sampled channels
        &#34;&#34;&#34;
        return self._unevenly_sampled_channels_field.copy()

    def _refresh_channels(self):
        &#34;&#34;&#34;
        takes the redvox packet and rebuilds the channel cache from it
        &#34;&#34;&#34;
        self._evenly_sampled_channels_field = list(map(EvenlySampledChannel,
                                                       reader_utils.repeated_to_array(
                                                           self._redvox_packet.evenly_sampled_channels)))
        self._unevenly_sampled_channels_field = list(map(UnevenlySampledChannel,
                                                         reader_utils.repeated_to_array(
                                                             self._redvox_packet.unevenly_sampled_channels)))
        self._channel_cache = {}
        for evenly_sampled_channel in self._evenly_sampled_channels_field:
            for channel_type in evenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = evenly_sampled_channel
        for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
            for channel_type in unevenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = unevenly_sampled_channel

    def _add_channel(self, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        &#34;&#34;&#34;
        Add a channel
        :param channel: channel to add
        &#34;&#34;&#34;
        index, sample = self._find_channel(channel.channel_types[0])
        if index is None and sample is None:
            # if type(channel) not in [EvenlySampledChannel, UnevenlySampledChannel]:
            if not isinstance(channel, (EvenlySampledChannel, UnevenlySampledChannel)):
                raise TypeError(&#34;Channel type to add must be even or uneven.&#34;)
            else:
                self._add_channel_redvox_packet(channel)
                self._refresh_channels()
        else:
            raise ValueError(&#34;Cannot add a channel with a type that already exists in this packet.&#34;)

    def _edit_channel(self, channel_type: int, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        &#34;&#34;&#34;
        removes the channel with the given type and adds the channel supplied
        :param channel_type: type of channel to remove
        :param channel: the channel to add
        &#34;&#34;&#34;
        index, sampling = self._find_channel(channel_type)
        if index is not None and sampling is not None:
            if isinstance(channel, EvenlySampledChannel):
                del self._redvox_packet.evenly_sampled_channels[index]
                self._add_channel_redvox_packet(channel)
            elif isinstance(channel, UnevenlySampledChannel):
                del self._redvox_packet.unevenly_sampled_channels[index]
                self._add_channel_redvox_packet(channel)
            else:
                raise TypeError(&#34;Channel type to edit is unknown!&#34;)
            self._refresh_channels()
        else:
            raise TypeError(&#34;Unknown channel type specified for edit.&#34;)

    def _delete_channel(self, channel_type: int):
        &#34;&#34;&#34;
        deletes the channel type specified
        :param channel_type: a channel to remove
        &#34;&#34;&#34;
        index, sampling = self._find_channel(channel_type)
        if index is not None and sampling is not None:
            if sampling == EvenlySampledChannel:
                del self._redvox_packet.evenly_sampled_channels[index]
            else:
                del self._redvox_packet.unevenly_sampled_channels[index]
            self._refresh_channels()
        else:
            raise TypeError(&#34;Unknown channel type to remove from packet.&#34;)

    # pylint: disable=W0120
    def _find_channel(self, channel_type: int) -&gt; (int, typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        &#34;&#34;&#34;
        returns the index of the channel and the kind of sampled array its in
        :return: the index in the even or uneven array and the name of the array
        &#34;&#34;&#34;
        if self._has_channel(channel_type):
            for idx in range(len(self._evenly_sampled_channels_field)):
                if channel_type in self._evenly_sampled_channels_field[idx].channel_types:
                    return idx, EvenlySampledChannel
            for idx in range(len(self._unevenly_sampled_channels_field)):
                if channel_type in self._unevenly_sampled_channels_field[idx].channel_types:
                    return idx, UnevenlySampledChannel
            else:
                return None, None
        else:
            return None, None

    # pylint: disable=R0912
    def _add_channel_redvox_packet(self, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        &#34;&#34;&#34;
        adds the channel to the redvox_packet
        :param channel: channel to add
        &#34;&#34;&#34;
        if isinstance(channel, EvenlySampledChannel):
            newchan = self._redvox_packet.evenly_sampled_channels.add()
            newchan.sample_rate_hz = channel.sample_rate_hz
            newchan.first_sample_timestamp_epoch_microseconds_utc = \
                channel.first_sample_timestamp_epoch_microseconds_utc
        elif isinstance(channel, UnevenlySampledChannel):
            newchan = self._redvox_packet.unevenly_sampled_channels.add()
            for time in channel.timestamps_microseconds_utc:
                newchan.timestamps_microseconds_utc.append(time)
            newchan.sample_interval_mean = channel.sample_interval_mean
            newchan.sample_interval_std = channel.sample_interval_std
            newchan.sample_interval_median = channel.sample_interval_median
        else:
            raise TypeError(&#34;Channel type to add to redvox packet is unknown!&#34;)

        pl_type = channel.get_payload_type()
        if pl_type == &#34;byte_payload&#34;:
            newchan.byte_payload.payload.extend(channel.payload)
        elif pl_type == &#34;uint32_payload&#34;:
            newchan.uint32_payload.payload.extend(channel.payload)
        elif pl_type == &#34;uint64_payload&#34;:
            newchan.uint64_payload.payload.extend(channel.payload)
        elif pl_type == &#34;int32_payload&#34;:
            newchan.int32_payload.payload.extend(channel.payload)
        elif pl_type == &#34;int64_payload&#34;:
            newchan.int64_payload.payload.extend(channel.payload)
        elif pl_type == &#34;float32_payload&#34;:
            newchan.float32_payload.payload.extend(channel.payload)
        elif pl_type == &#34;float64_payload&#34;:
            newchan.float64_payload.payload.extend(channel.payload)
        elif pl_type is None:
            pass
        else:
            raise TypeError(&#34;Unknown payload type in channel to add.&#34;)

        for chan_type in channel.channel_types:
            newchan.channel_types.append(chan_type)
        newchan.sensor_name = channel.sensor_name
        for mean in channel.value_means:
            newchan.value_means.append(mean)
        for stds in channel.value_stds:
            newchan.value_stds.append(stds)
        for median in channel.value_medians:
            newchan.value_medians.append(median)
        for meta in channel.metadata:
            newchan.metadata.append(meta)

    def _get_channel_types(self) -&gt; typing.List[typing.List[int]]:
        &#34;&#34;&#34;
        Returns a list of channel type enumerations. This is a list of lists, and allows us to easily view
        interleaved channels.
        :return: A list of channel type enumerations.
        &#34;&#34;&#34;
        channel_types = []
        for evenly_sampled_channel in self._evenly_sampled_channels_field:
            channel_types.append(evenly_sampled_channel.channel_types)

        for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
            channel_types.append(unevenly_sampled_channel.channel_types)

        return channel_types

    def _get_channel_type_names(self) -&gt; typing.List[typing.List[str]]:
        &#34;&#34;&#34;
        Returns a list of channel type names. This is a list of lists, and allows us to easily view
        interleaved channels.
        :return: A list of channel type names. This is a list of lists, and allows us to easily view
        interleaved channels.
        &#34;&#34;&#34;
        names = []
        for channel_types in self._get_channel_types():
            names.append(list(map(reader_utils.channel_type_name_from_enum, channel_types)))
        return names

    def _get_channel(self, channel_type: int) -&gt; typing.Union[EvenlySampledChannel, UnevenlySampledChannel, None]:
        &#34;&#34;&#34;
        Returns a channel from this packet according to the channel type.
        :param channel_type: The channel type to search for.
        :return: A high level channel wrapper or None.
        &#34;&#34;&#34;
        if channel_type in self._channel_cache:
            return self._channel_cache[channel_type]

        return None

    def _has_channel(self, channel_type: int) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if this packet contains a channel with this type otherwise False.
        :param channel_type: Channel type to search for.
        :return: True is this packet contains a channel with this type otherwise False.
        &#34;&#34;&#34;
        return channel_type in self._channel_cache

    def _has_channels(self, channel_types: typing.List[int]) -&gt; bool:
        &#34;&#34;&#34;
        Checks that this packet contains all of the provided channels.
        :param channel_types: Channel types that this packet must contain.
        :return: True if this packet contains all provided channel types, False otherwise.
        &#34;&#34;&#34;
        has_channel_results = map(self._has_channel, channel_types)
        for has_channel_result in has_channel_results:
            if not has_channel_result:
                return False
        return True

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;
        Converts the protobuf packet stored in this wrapped packet to JSON.
        :return: The JSON representation of the protobuf encoded packet.
        &#34;&#34;&#34;
        return reader_utils.to_json(self._redvox_packet)

    def compressed_buffer(self) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the compressed buffer associated with this packet.
        :return: The compressed buffer associated with this packet.
        &#34;&#34;&#34;
        return reader_utils.lz4_compress(self._redvox_packet.SerializeToString())

    def default_filename(self, extension: str = &#34;rdvxz&#34;) -&gt; str:
        &#34;&#34;&#34;
        Constructs a default filename from the packet&#39;s metadata.
        :param extension: An optional extension to use.
        :return: A default filename from the packet&#39;s metadata.
        &#34;&#34;&#34;
        return &#34;%s_%d.%s&#34; % (self.redvox_id(), int(round(self.app_file_start_timestamp_machine() / 1000.0)), extension)

    def write_rdvxz(self, directory: str, filename: typing.Optional[str] = None):
        &#34;&#34;&#34;
        Writes a compressed .rdvxz file to the specified directory.
        :param directory: The directory to write the file to.
        :param filename: An optional filename (the default filename will be used if one is not provided).
        &#34;&#34;&#34;
        filename = self.default_filename() if filename is None else filename
        path = os.path.join(directory, filename)
        with open(path, &#34;wb&#34;) as rdvxz_out:
            rdvxz_out.write(self.compressed_buffer())

    def write_json(self, directory: str, filename: typing.Optional[str] = None):
        &#34;&#34;&#34;
        Writes a RedVox compliant .json file to the specified directory.
        :param directory: The directory to write the file to.
        :param filename: An optional filename (the default filename will be used if one is not provided).
        &#34;&#34;&#34;
        filename = self.default_filename(extension=&#34;json&#34;) if filename is None else filename
        path = os.path.join(directory, filename)
        with open(path, &#34;w&#34;) as json_out:
            json_out.write(self.to_json())

    def clone(self) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Returns a clone of this WrappedRedvoxPacket.
        :return: A clone of this WrappedRedvoxPacket.
        &#34;&#34;&#34;
        return WrappedRedvoxPacket(read_buffer(self.compressed_buffer(), True))

    def concat(self, wrapped_redvox_packets: typing.List[&#39;WrappedRedvoxPacket&#39;]) -&gt; typing.List[&#39;WrappedRedvoxPacket&#39;]:
        &#34;&#34;&#34;
        Concatenates this packet with other packets.
        :param wrapped_redvox_packets: Other packets to concatenate with this packet.
        :return: A list of packets each containing a continuous set of data.
        &#34;&#34;&#34;
        return redvox.api900.concat.concat_wrapped_redvox_packets([self] + wrapped_redvox_packets)

    # Start of packet level API getters and setters
    def api(self) -&gt; int:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(self._redvox_packet.api)

    def set_api(self, version: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the api version number
        :param version: version number
        &#34;&#34;&#34;
        self._redvox_packet.api = version
        return self

    def uuid(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.uuid

    def set_uuid(self, uid: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the uuid
        :param uid: uuid string
        &#34;&#34;&#34;
        self._redvox_packet.uuid = uid
        return self

    def redvox_id(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.redvox_id

    def set_redvox_id(self, rid: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the redvox id
        :param rid: redvox id string
        &#34;&#34;&#34;
        self._redvox_packet.redvox_id = rid
        return self

    def authenticated_email(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.authenticated_email

    def set_authenticated_email(self, email: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the authenticated email
        :param email: authenticated email string
        &#34;&#34;&#34;
        self._redvox_packet.authenticated_email = email
        return self

    def authentication_token(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.authentication_token

    def set_authentication_token(self, token: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the authentication token
        :param token: authentication token string
        &#34;&#34;&#34;
        self._redvox_packet.authentication_token = token
        return self

    def firebase_token(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.firebase_token

    def set_firebase_token(self, token: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the firebase token
        :param token: firebase token string
        &#34;&#34;&#34;
        self._redvox_packet.firebase_token = token
        return self

    def is_backfilled(self) -&gt; bool:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.is_backfilled

    def set_is_backfilled(self, tof: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the is_backfilled flag
        :param tof: true or false
        &#34;&#34;&#34;
        self._redvox_packet.is_backfilled = tof
        return self

    def is_private(self) -&gt; bool:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.is_private

    def set_is_private(self, tof: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the is_private flag
        :param tof: true or false
        &#34;&#34;&#34;
        self._redvox_packet.is_private = tof
        return self

    def is_scrambled(self) -&gt; bool:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.is_scrambled

    def set_is_scrambled(self, tof: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the is_scrambled flag
        :param tof: true or false
        &#34;&#34;&#34;
        self._redvox_packet.is_scrambled = tof
        return self

    def device_make(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_make

    def set_device_make(self, make: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the make of the device
        :param make: make of the device string
        &#34;&#34;&#34;
        self._redvox_packet.device_make = make
        return self

    def device_model(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_model

    def set_device_model(self, model: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the model of the device
        :param model: model of the device string
        &#34;&#34;&#34;
        self._redvox_packet.device_model = model
        return self

    def device_os(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_os

    def set_device_os(self, device_os: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the device operating system
        :param device_os: operating system string
        &#34;&#34;&#34;
        self._redvox_packet.device_os = device_os
        return self

    def device_os_version(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_os_version

    def set_device_os_version(self, version: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the device OS version
        :param version: device OS version string
        &#34;&#34;&#34;
        self._redvox_packet.device_os_version = version
        return self

    def app_version(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.app_version

    def set_app_version(self, version: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the app version number
        :param version: app version string
        &#34;&#34;&#34;
        self._redvox_packet.app_version = version
        return self

    def battery_level_percent(self) -&gt; float:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.battery_level_percent

    def set_battery_level_percent(self, percent: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the percentage of battery left
        :param percent: percentage of battery left
        &#34;&#34;&#34;
        self._redvox_packet.battery_level_percent = percent
        return self

    def device_temperature_c(self) -&gt; float:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.device_temperature_c

    def set_device_temperature_c(self, temp: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the device temperature in degrees Celsius
        :param temp: temperature in degrees Celsius
        &#34;&#34;&#34;
        self._redvox_packet.device_temperature_c = temp
        return self

    def acquisition_server(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.acquisition_server

    def set_acquisition_server(self, server: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the acquisition server url
        :param server: url to acquisition server
        &#34;&#34;&#34;
        self._redvox_packet.acquisition_server = server
        return self

    # pylint: disable=invalid-name
    def time_synchronization_server(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.time_synchronization_server

    def set_time_synchronization_server(self, server: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the time synchronization server url
        :param server: url to time synchronization server
        &#34;&#34;&#34;
        self._redvox_packet.time_synchronization_server = server
        return self

    def authentication_server(self) -&gt; str:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._redvox_packet.authentication_server

    def set_authentication_server(self, server: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the authentication server url
        :param server: url to authentication server
        &#34;&#34;&#34;
        self._redvox_packet.authentication_server = server
        return self

    # pylint: disable=invalid-name
    def app_file_start_timestamp_epoch_microseconds_utc(self) -&gt; int:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc)

    def set_app_file_start_timestamp_epoch_microseconds_utc(self, time: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the timestamp of packet creation
        :param time: time when packet was created in microseconds since utc epoch
        &#34;&#34;&#34;
        self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc = migrations.maybe_set_int(time)
        return self

    # pylint: disable=invalid-name
    def app_file_start_timestamp_machine(self) -&gt; int:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(self._redvox_packet.app_file_start_timestamp_machine)

    def set_app_file_start_timestamp_machine(self, time: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the internal machine timestamp of packet creation
        :param time: time when packet was created on local machine
        &#34;&#34;&#34;
        self._redvox_packet.app_file_start_timestamp_machine = migrations.maybe_set_int(time)
        return self

    # pylint: disable=invalid-name
    def server_timestamp_epoch_microseconds_utc(self) -&gt; int:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(self._redvox_packet.server_timestamp_epoch_microseconds_utc)

    def set_server_timestamp_epoch_microseconds_utc(self, time: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the server timestamp when the packet was received
        :param time: time when packet was received by server
        &#34;&#34;&#34;
        self._redvox_packet.server_timestamp_epoch_microseconds_utc = time
        return self

    def metadata(self) -&gt; typing.List[str]:
        &#34;&#34;&#34;
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        &#34;&#34;&#34;
        return self._metadata_list

    def set_metadata(self, data: typing.List[str]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        sets the metadata
        :param data: metadata as list of strings
        &#34;&#34;&#34;
        self._metadata_list = data
        self._redvox_packet.metadata[:] = data
        return self

    def _clear_metadata(self):
        &#34;&#34;&#34;
        removes all of the packet level metadata from packet
        &#34;&#34;&#34;
        del self._redvox_packet.metadata[:]
        self._metadata_list.clear()

    def metadata_as_dict(self) -&gt; typing.Dict[str, str]:
        &#34;&#34;&#34;
        Return this packet&#39;s metadata as a key-value Python dictionary.
        :return: This packet&#39;s metadata as a key-value Python dictionary.
        &#34;&#34;&#34;
        return reader_utils.get_metadata_as_dict(self._metadata_list)

    def set_metadata_as_dict(self, metadata_dict: typing.Dict[str, str]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the metadata using a dictionary.
        :param metadata_dict: Dictionary of metadata.
        :return: This WrappedRedvoxPacket.
        &#34;&#34;&#34;
        self.set_metadata(reader_utils.metadata_dict_to_list(metadata_dict))
        return self

    def add_metadata(self, key: str, value: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Adds a key pair value to the metadata.
        :param key: The key.
        :param value: The value.
        :return: This instance of a WrappedRedvoxPacket.
        &#34;&#34;&#34;
        metadata = self.metadata_as_dict()
        metadata[key] = value if isinstance(value, str) else str(value)
        self.set_metadata_as_dict(metadata)
        return self

    def start_timestamp_us_utc(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the start timestamp of a WrappedRedvoxPacket.
        :return: The start timestamp of a WrappedRedvoxPacket.
        &#34;&#34;&#34;
        return migrations.maybe_get_float(
            self.microphone_sensor().first_sample_timestamp_epoch_microseconds_utc())

    def duration_s(self) -&gt; float:
        &#34;&#34;&#34;
        The duration of this WrappedRedvoxPacket in seconds.
        :return: The duration of this WrappedRedvoxPacket in seconds.
        &#34;&#34;&#34;
        microphone_sensor = self.microphone_sensor()
        return len(microphone_sensor.payload_values()) / microphone_sensor.sample_rate_hz()

    def end_timestamp_us_utc(self) -&gt; float:
        &#34;&#34;&#34;
        Returns the end timestamp of a WrappedRedvoxPacket.
        :return: The end timestamp of a WrappedRedvoxPacket.
        &#34;&#34;&#34;
        return self.start_timestamp_us_utc() + date_time_utils.seconds_to_microseconds(self.duration_s())

    def update_uneven_sensor_timestamps(self, time_delta: int or float):
        &#34;&#34;&#34;
        Given a time delta in microseconds, will adjust all unevenly sampled sensor timestamps by that amount.
        Use negative values to adjust backwards in time.
        :param time_delta: amount of time to adjust timestamps in microseconds
        &#34;&#34;&#34;
        for channel in self._unevenly_sampled_channels_field:
            if not channel.has_channel(api900_pb2.TIME_SYNCHRONIZATION):
                channel.set_timestamps_microseconds_utc(channel.timestamps_microseconds_utc + time_delta)

    def mach_time_zero(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;
        Returns the mach time zero from the metadata if it exists.
        :return: The mach time zero from the metadata if it exists.
        &#34;&#34;&#34;
        try:
            # First, try to extract metadata from the correct location
            top_level_metadata: typing.Dict[str, str] = self.metadata_as_dict()
            if &#34;machTimeZero&#34; in top_level_metadata:
                return migrations.maybe_get_float(int(top_level_metadata[&#34;machTimeZero&#34;]))

            # If that fails, some Androids stored it in the Location metadata
            location_sensor = self.location_sensor()
            if location_sensor is not None:
                location_metadata: typing.Dict[str, str] = location_sensor.metadata_as_dict()
                if &#34;machTimeZero&#34; in location_metadata:
                    return migrations.maybe_get_float(int(location_metadata[&#34;machTimeZero&#34;]))

            # Finally, if it hasn&#39;t been found, it&#39;s probably a really old packet that doesn&#39;t contain this field
            return None
        except (KeyError, ValueError):
            return None

    def set_mach_time_zero(self, mach_time_zero: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the mach time zero in the packet&#39;s metadata.
        :param mach_time_zero: The mach time zero to use.
        :return: An instance of this wrapped packet.
        &#34;&#34;&#34;
        return self.add_metadata(&#34;machTimeZero&#34;, str(mach_time_zero))

    def best_latency(self) -&gt; typing.Optional[float]:
        &#34;&#34;&#34;
        Returns the best latency from the metadata if it exists.
        :return: The best latency from the metadata if it exists.
        &#34;&#34;&#34;
        try:
            return float(self.metadata_as_dict()[&#34;bestLatency&#34;])
        except (KeyError, ValueError):
            return None

    def set_best_latency(self, best_latency: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the best latency in the packet&#39;s metadata.
        :param best_latency: The best latency to use.
        :return: An instance of this wrapped packet.
        &#34;&#34;&#34;
        return self.add_metadata(&#34;bestLatency&#34;, str(best_latency))

    def best_offset(self) -&gt; typing.Optional[float]:
        &#34;&#34;&#34;
        Returns the best offset from the metadata if it exists.
        :return: The best offset from the metadata if it exists.
        &#34;&#34;&#34;
        try:
            return float(self.metadata_as_dict()[&#34;bestOffset&#34;])
        except (KeyError, ValueError):
            return None

    def set_best_offset(self, best_offset: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the best offset in the packet&#39;s metadata.
        :param best_offset: The best offset to use.
        :return: An instance of this wrapped packet.
        &#34;&#34;&#34;
        return self.add_metadata(&#34;bestOffset&#34;, str(best_offset))

    def is_synch_corrected(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns the isSynchCorrected value from the metadata if it exists.
        :return: The isSynchCorrected value from the metadata if it exists.
        &#34;&#34;&#34;

        def _parse_bool(s: str) -&gt; bool:
            return s == &#34;true&#34; or s == &#34;True&#34;

        try:
            return _parse_bool(self.metadata_as_dict()[&#34;isSynchCorrected&#34;])
        except (KeyError, ValueError):
            return False

    def set_is_synch_corrected(self, is_synch_corrected: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets the is_synch_corrected field in the packet&#39;s metadata.
        :param is_synch_corrected: The is_synch_corrected field to use.
        :return: An instance of this wrapped packet.
        &#34;&#34;&#34;
        return self.add_metadata(&#34;isSynchCorrected&#34;, &#34;true&#34; if is_synch_corrected else &#34;false&#34;)

    # Sensor channels
    def has_microphone_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a microphone channel.
        :return: If this packet has a microphone channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.MICROPHONE)

    def microphone_sensor(self) -&gt; typing.Optional[_microphone_sensor.MicrophoneSensor]:
        &#34;&#34;&#34;
        Returns the high-level microphone channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level microphone channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_microphone_sensor():
            return _microphone_sensor.MicrophoneSensor(self._get_channel(api900_pb2.MICROPHONE))

        return None

    def set_microphone_sensor(self, microphone_sensor: typing.Optional[
            _microphone_sensor.MicrophoneSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packets microphone sensor. A channel can be removed by passing in None.
        :param microphone_sensor: An optional instance of a microphone sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_microphone_sensor():
            self._delete_channel(api900_pb2.MICROPHONE)

        if microphone_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(microphone_sensor._evenly_sampled_channel)

        return self

    def has_barometer_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a barometer channel.
        :return: If this packet has a barometer channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.BAROMETER)

    def barometer_sensor(self) -&gt; typing.Optional[_barometer_sensor.BarometerSensor]:
        &#34;&#34;&#34;
        Returns the high-level barometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level barometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_barometer_sensor():
            return _barometer_sensor.BarometerSensor(self._get_channel(api900_pb2.BAROMETER))

        return None

    def set_barometer_sensor(self, barometer_sensor: typing.Optional[
            _barometer_sensor.BarometerSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packets barometer sensor. A channel can be removed by passing in None.
        :param barometer_sensor: An optional instance of a barometer sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_barometer_sensor():
            self._delete_channel(api900_pb2.BAROMETER)

        if barometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(barometer_sensor._unevenly_sampled_channel)

        return self

    def has_location_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a location channel.
        :return: If this packet has a location channel.
        &#34;&#34;&#34;
        return (self._has_channels(
            [api900_pb2.LATITUDE, api900_pb2.LONGITUDE, api900_pb2.ALTITUDE, api900_pb2.SPEED,
             api900_pb2.ACCURACY]) or self._has_channels([api900_pb2.LATITUDE, api900_pb2.LONGITUDE]))

    def location_sensor(self) -&gt; typing.Optional[_location_sensor.LocationSensor]:
        &#34;&#34;&#34;
        Returns the high-level location channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level location channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_location_sensor():
            return _location_sensor.LocationSensor(self._get_channel(api900_pb2.LATITUDE))

        return None

    def set_location_sensor(self,
                            location_sensor: typing.Optional[_location_sensor.LocationSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s location sensor. A channel can be removed by passing in None.
        :param location_sensor: An optional instance of a location sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_location_sensor():
            self._delete_channel(api900_pb2.LATITUDE)

        if location_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(location_sensor._unevenly_sampled_channel)

        return self

    # pylint: disable=invalid-name,C1801
    def has_time_synchronization_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a time synchronization channel.
        :return: If this packet has a time synchronization channel.
        &#34;&#34;&#34;
        if self._has_channel(api900_pb2.TIME_SYNCHRONIZATION):
            ch = _time_synchronization_sensor.TimeSynchronizationSensor(
                self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))
            return len(ch.payload_values()) &gt; 0

        return False

    def time_synchronization_sensor(self) -&gt; typing.Optional[_time_synchronization_sensor.TimeSynchronizationSensor]:
        &#34;&#34;&#34;
        Returns the high-level time synchronization channel API or None if this packet doesn&#39;t contain a channel of
        this type.
        :return: the high-level time synchronization channel API or None if this packet doesn&#39;t contain a channel of
        this type.
        &#34;&#34;&#34;
        if self.has_time_synchronization_sensor():
            return _time_synchronization_sensor.TimeSynchronizationSensor(
                self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))

        return None

    def set_time_synchronization_sensor(self, time_synchronization_sensor: typing.Optional[
            _time_synchronization_sensor.TimeSynchronizationSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s time sync sensor. A channel can be removed by passing in None.
        :param time_synchronization_sensor: An optional instance of a time sync sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_time_synchronization_sensor():
            self._delete_channel(api900_pb2.TIME_SYNCHRONIZATION)

        if time_synchronization_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(time_synchronization_sensor._unevenly_sampled_channel)

        return self

    def has_accelerometer_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has an accelerometer channel.
        :return: If this packet has an accelerometer channel.
        &#34;&#34;&#34;
        return self._has_channels([api900_pb2.ACCELEROMETER_X, api900_pb2.ACCELEROMETER_Y, api900_pb2.ACCELEROMETER_Z])

    def accelerometer_sensor(self) -&gt; typing.Optional[_accelerometer_sensor.AccelerometerSensor]:
        &#34;&#34;&#34;
        Returns the high-level accelerometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level accelerometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_accelerometer_sensor():
            return _accelerometer_sensor.AccelerometerSensor(self._get_channel(api900_pb2.ACCELEROMETER_X))

        return None

    def set_accelerometer_sensor(self,
                                 accelerometer_sensor: typing.Optional[
                                     _accelerometer_sensor.AccelerometerSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s accelerometer sensor. A channel can be removed by passing in None.
        :param accelerometer_sensor: An optional instance of a accelerometer sensor.
        &#34;&#34;&#34;
        if self.has_accelerometer_sensor():
            self._delete_channel(api900_pb2.ACCELEROMETER_X)

        if accelerometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(accelerometer_sensor._unevenly_sampled_channel)

        return self

    def has_magnetometer_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a magnetometer channel.
        :return: If this packet has a magnetometer channel.
        &#34;&#34;&#34;
        return self._has_channels([api900_pb2.MAGNETOMETER_X, api900_pb2.MAGNETOMETER_Y, api900_pb2.MAGNETOMETER_Z])

    def magnetometer_sensor(self) -&gt; typing.Optional[_magnetometer_sensor.MagnetometerSensor]:
        &#34;&#34;&#34;
        Returns the high-level magnetometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level magnetometer channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_magnetometer_sensor():
            return _magnetometer_sensor.MagnetometerSensor(self._get_channel(api900_pb2.MAGNETOMETER_X))

        return None

    def set_magnetometer_sensor(self,
                                magnetometer_sensor: typing.Optional[
                                    _magnetometer_sensor.MagnetometerSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s magnetomer sensor. A channel can be removed by passing in None.
        :param magnetometer_sensor: An optional instance of a magnetometer sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_magnetometer_sensor():
            self._delete_channel(api900_pb2.MAGNETOMETER_X)

        if magnetometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(magnetometer_sensor._unevenly_sampled_channel)

        return self

    def has_gyroscope_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a gyroscope channel.
        :return: If this packet has a gyroscope channel.
        &#34;&#34;&#34;
        return self._has_channels([api900_pb2.GYROSCOPE_X, api900_pb2.GYROSCOPE_Y, api900_pb2.GYROSCOPE_Z])

    def gyroscope_sensor(self) -&gt; typing.Optional[_gyroscope_sensor.GyroscopeSensor]:
        &#34;&#34;&#34;
        Returns the high-level gyroscope channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level gyroscope channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_gyroscope_sensor():
            return _gyroscope_sensor.GyroscopeSensor(self._get_channel(api900_pb2.GYROSCOPE_X))

        return None

    def set_gyroscope_sensor(self, gyroscope_sensor: typing.Optional[
            _gyroscope_sensor.GyroscopeSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s gyroscope sensor. A channel can be removed by passing in None.
        :param gyroscope_sensor: An optional instance of a gyroscope sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_gyroscope_sensor():
            self._delete_channel(api900_pb2.GYROSCOPE_X)

        if gyroscope_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(gyroscope_sensor._unevenly_sampled_channel)

        return self

    def has_light_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has a light channel.
        :return: If this packet has a light channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.LIGHT)

    def light_sensor(self) -&gt; typing.Optional[_light_sensor.LightSensor]:
        &#34;&#34;&#34;
        Returns the high-level light channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level light channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_light_sensor():
            return _light_sensor.LightSensor(self._get_channel(api900_pb2.LIGHT))

        return None

    def set_light_sensor(self, light_sensor: typing.Optional[_light_sensor.LightSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s light sensor. A channel can be removed by passing in None.
        :param light_sensor: An optional instance of a light sensor.
        :return: This instance of a wrapped redvox packet.
        &#34;&#34;&#34;
        if self.has_light_sensor():
            self._delete_channel(api900_pb2.LIGHT)

        if light_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(light_sensor._unevenly_sampled_channel)

        return self

    def has_infrared_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has an infrared channel.
        :return: If this packlet has an infrared channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.INFRARED)

    def infrared_sensor(self) -&gt; typing.Optional[_infrared_sensor.InfraredSensor]:
        &#34;&#34;&#34;
        Returns the high-level infrared channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level infrared channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_infrared_sensor():
            return _infrared_sensor.InfraredSensor(self._get_channel(api900_pb2.INFRARED))

        return None

    def set_infrared_sensor(self,
                            infrared_sensor: typing.Optional[
                                _infrared_sensor.InfraredSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Sets this packet&#39;s infrared sensor. A channel can be removed by passing in None.
        :param infrared_sensor: An optional instance of a infrared sensor.
        &#34;&#34;&#34;
        if self.has_infrared_sensor():
            self._delete_channel(api900_pb2.INFRARED)

        if infrared_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(infrared_sensor._unevenly_sampled_channel)

        return self

    def has_image_sensor(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns if this packet has an image channel.
        :return: If this packlet has an image channel.
        &#34;&#34;&#34;
        return self._has_channel(api900_pb2.IMAGE)

    def image_sensor(self) -&gt; typing.Optional[_image_sensor.ImageSensor]:
        &#34;&#34;&#34;
        Returns the high-level image channel API or None if this packet doesn&#39;t contain a channel of this type.
        :return: the high-level image channel API or None if this packet doesn&#39;t contain a channel of this type.
        &#34;&#34;&#34;
        if self.has_image_sensor():
            return _image_sensor.ImageSensor(self._get_channel(api900_pb2.IMAGE))

        return None

    def set_image_sensor(self, image_sensor: typing.Optional[_image_sensor.ImageSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
        &#34;&#34;&#34;
        Set&#39;s the image channel.
        :param image_sensor: Image sensor.
        &#34;&#34;&#34;
        if self.has_image_sensor():
            self._delete_channel(api900_pb2.IMAGE)

        if image_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(image_sensor._unevenly_sampled_channel)

        return self

    def __str__(self):
        &#34;&#34;&#34;
        Returns protobuf&#39;s String representation of this packet.
        :return: Protobuf&#39;s String representation of this packet.
        &#34;&#34;&#34;
        return str(self._redvox_packet)

    def __eq__(self, other):
        return isinstance(other, WrappedRedvoxPacket) and len(self.diff(other)) == 0

    def diff(self, other: &#39;WrappedRedvoxPacket&#39;) -&gt; typing.List[str]:
        &#34;&#34;&#34;
        Finds the differences (if any) between two WrappedRedvoxPackets.
        :param other: The other wrapped redvox packet to compare to.
        :return: A list of differences or an empty list if there are none.
        &#34;&#34;&#34;
        diffs = map(lambda tuple2: reader_utils.diff(tuple2[0], tuple2[1]), [
            (self.api(), other.api()),
            (self.redvox_id(), other.redvox_id()),
            (self.uuid(), other.uuid()),
            (self.authenticated_email(), other.authenticated_email()),
            (self.authentication_token(), other.authentication_token()),
            (self.firebase_token(), other.firebase_token()),
            (self.is_backfilled(), other.is_backfilled()),
            (self.is_private(), other.is_private()),
            (self.is_scrambled(), other.is_scrambled()),
            (self.device_make(), other.device_make()),
            (self.device_model(), other.device_model()),
            (self.device_os(), other.device_os()),
            (self.device_os_version(), other.device_os_version()),
            (self.app_version(), other.app_version()),
            (self.battery_level_percent(), other.battery_level_percent()),
            (self.device_temperature_c(), other.device_temperature_c()),
            (self.acquisition_server(), other.acquisition_server()),
            (self.time_synchronization_server(), other.time_synchronization_server()),
            (self.authentication_server(), other.authentication_server()),
            (self.app_file_start_timestamp_epoch_microseconds_utc(),
             other.app_file_start_timestamp_epoch_microseconds_utc()),
            (self.app_file_start_timestamp_machine(), other.app_file_start_timestamp_machine()),
            (self.server_timestamp_epoch_microseconds_utc(),
             other.server_timestamp_epoch_microseconds_utc()),
            (self.metadata(), other.metadata()),
            (self.microphone_sensor(), other.microphone_sensor()),
            (self.barometer_sensor(), other.barometer_sensor()),
            (self.location_sensor(), other.location_sensor()),
            (self.time_synchronization_sensor(), other.time_synchronization_sensor()),
            (self.accelerometer_sensor(), other.accelerometer_sensor()),
            (self.magnetometer_sensor(), other.magnetometer_sensor()),
            (self.gyroscope_sensor(), other.gyroscope_sensor()),
            (self.light_sensor(), other.light_sensor()),
            (self.infrared_sensor(), other.infrared_sensor())
        ])
        # Filter only out only the differences
        diffs = filter(lambda tuple2: tuple2[0], diffs)
        # Extract the difference string
        diffs = map(lambda tuple2: tuple2[1], diffs)
        return list(diffs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_sensor"><code class="name flex">
<span>def <span class="ident">accelerometer_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.accelerometer_sensor.AccelerometerSensor" href="sensors/accelerometer_sensor.html#redvox.api900.sensors.accelerometer_sensor.AccelerometerSensor">AccelerometerSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accelerometer_sensor(self) -&gt; typing.Optional[_accelerometer_sensor.AccelerometerSensor]:
    &#34;&#34;&#34;
    Returns the high-level accelerometer channel API or None if this packet doesn&#39;t contain a channel of this type.
    :return: the high-level accelerometer channel API or None if this packet doesn&#39;t contain a channel of this type.
    &#34;&#34;&#34;
    if self.has_accelerometer_sensor():
        return _accelerometer_sensor.AccelerometerSensor(self._get_channel(api900_pb2.ACCELEROMETER_X))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.acquisition_server"><code class="name flex">
<span>def <span class="ident">acquisition_server</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquisition_server(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.acquisition_server</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.add_metadata"><code class="name flex">
<span>def <span class="ident">add_metadata</span></span>(<span>self, key: str, value: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds a key pair value to the metadata.
:param key: The key.
:param value: The value.
:return: This instance of a WrappedRedvoxPacket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metadata(self, key: str, value: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Adds a key pair value to the metadata.
    :param key: The key.
    :param value: The value.
    :return: This instance of a WrappedRedvoxPacket.
    &#34;&#34;&#34;
    metadata = self.metadata_as_dict()
    metadata[key] = value if isinstance(value, str) else str(value)
    self.set_metadata_as_dict(metadata)
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.api"><code class="name flex">
<span>def <span class="ident">api</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def api(self) -&gt; int:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return migrations.maybe_get_float(self._redvox_packet.api)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc"><code class="name flex">
<span>def <span class="ident">app_file_start_timestamp_epoch_microseconds_utc</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def app_file_start_timestamp_epoch_microseconds_utc(self) -&gt; int:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return migrations.maybe_get_float(self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_machine"><code class="name flex">
<span>def <span class="ident">app_file_start_timestamp_machine</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def app_file_start_timestamp_machine(self) -&gt; int:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return migrations.maybe_get_float(self._redvox_packet.app_file_start_timestamp_machine)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_version"><code class="name flex">
<span>def <span class="ident">app_version</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def app_version(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.app_version</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authenticated_email"><code class="name flex">
<span>def <span class="ident">authenticated_email</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authenticated_email(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.authenticated_email</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_server"><code class="name flex">
<span>def <span class="ident">authentication_server</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authentication_server(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.authentication_server</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_token"><code class="name flex">
<span>def <span class="ident">authentication_token</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authentication_token(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.authentication_token</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_sensor"><code class="name flex">
<span>def <span class="ident">barometer_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.barometer_sensor.BarometerSensor" href="sensors/barometer_sensor.html#redvox.api900.sensors.barometer_sensor.BarometerSensor">BarometerSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level barometer channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level barometer channel API or None if this packet doesn't contain a channel of this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def barometer_sensor(self) -&gt; typing.Optional[_barometer_sensor.BarometerSensor]:
    &#34;&#34;&#34;
    Returns the high-level barometer channel API or None if this packet doesn&#39;t contain a channel of this type.
    :return: the high-level barometer channel API or None if this packet doesn&#39;t contain a channel of this type.
    &#34;&#34;&#34;
    if self.has_barometer_sensor():
        return _barometer_sensor.BarometerSensor(self._get_channel(api900_pb2.BAROMETER))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.battery_level_percent"><code class="name flex">
<span>def <span class="ident">battery_level_percent</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def battery_level_percent(self) -&gt; float:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.battery_level_percent</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_latency"><code class="name flex">
<span>def <span class="ident">best_latency</span></span>(<span>self) ‑> typing.Optional[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the best latency from the metadata if it exists.
:return: The best latency from the metadata if it exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def best_latency(self) -&gt; typing.Optional[float]:
    &#34;&#34;&#34;
    Returns the best latency from the metadata if it exists.
    :return: The best latency from the metadata if it exists.
    &#34;&#34;&#34;
    try:
        return float(self.metadata_as_dict()[&#34;bestLatency&#34;])
    except (KeyError, ValueError):
        return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_offset"><code class="name flex">
<span>def <span class="ident">best_offset</span></span>(<span>self) ‑> typing.Optional[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the best offset from the metadata if it exists.
:return: The best offset from the metadata if it exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def best_offset(self) -&gt; typing.Optional[float]:
    &#34;&#34;&#34;
    Returns the best offset from the metadata if it exists.
    :return: The best offset from the metadata if it exists.
    &#34;&#34;&#34;
    try:
        return float(self.metadata_as_dict()[&#34;bestOffset&#34;])
    except (KeyError, ValueError):
        return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a clone of this WrappedRedvoxPacket.
:return: A clone of this WrappedRedvoxPacket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Returns a clone of this WrappedRedvoxPacket.
    :return: A clone of this WrappedRedvoxPacket.
    &#34;&#34;&#34;
    return WrappedRedvoxPacket(read_buffer(self.compressed_buffer(), True))</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.compressed_buffer"><code class="name flex">
<span>def <span class="ident">compressed_buffer</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the compressed buffer associated with this packet.
:return: The compressed buffer associated with this packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compressed_buffer(self) -&gt; bytes:
    &#34;&#34;&#34;
    Returns the compressed buffer associated with this packet.
    :return: The compressed buffer associated with this packet.
    &#34;&#34;&#34;
    return reader_utils.lz4_compress(self._redvox_packet.SerializeToString())</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>self, wrapped_redvox_packets: typing.List[ForwardRef('<a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a>')]) ‑> typing.List[<a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates this packet with other packets.
:param wrapped_redvox_packets: Other packets to concatenate with this packet.
:return: A list of packets each containing a continuous set of data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(self, wrapped_redvox_packets: typing.List[&#39;WrappedRedvoxPacket&#39;]) -&gt; typing.List[&#39;WrappedRedvoxPacket&#39;]:
    &#34;&#34;&#34;
    Concatenates this packet with other packets.
    :param wrapped_redvox_packets: Other packets to concatenate with this packet.
    :return: A list of packets each containing a continuous set of data.
    &#34;&#34;&#34;
    return redvox.api900.concat.concat_wrapped_redvox_packets([self] + wrapped_redvox_packets)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.default_filename"><code class="name flex">
<span>def <span class="ident">default_filename</span></span>(<span>self, extension: str = 'rdvxz') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a default filename from the packet's metadata.
:param extension: An optional extension to use.
:return: A default filename from the packet's metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_filename(self, extension: str = &#34;rdvxz&#34;) -&gt; str:
    &#34;&#34;&#34;
    Constructs a default filename from the packet&#39;s metadata.
    :param extension: An optional extension to use.
    :return: A default filename from the packet&#39;s metadata.
    &#34;&#34;&#34;
    return &#34;%s_%d.%s&#34; % (self.redvox_id(), int(round(self.app_file_start_timestamp_machine() / 1000.0)), extension)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_make"><code class="name flex">
<span>def <span class="ident">device_make</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device_make(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.device_make</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_model"><code class="name flex">
<span>def <span class="ident">device_model</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device_model(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.device_model</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os"><code class="name flex">
<span>def <span class="ident">device_os</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device_os(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.device_os</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os_version"><code class="name flex">
<span>def <span class="ident">device_os_version</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device_os_version(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.device_os_version</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_temperature_c"><code class="name flex">
<span>def <span class="ident">device_temperature_c</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def device_temperature_c(self) -&gt; float:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.device_temperature_c</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>self, other: <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a>) ‑> typing.List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the differences (if any) between two WrappedRedvoxPackets.
:param other: The other wrapped redvox packet to compare to.
:return: A list of differences or an empty list if there are none.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(self, other: &#39;WrappedRedvoxPacket&#39;) -&gt; typing.List[str]:
    &#34;&#34;&#34;
    Finds the differences (if any) between two WrappedRedvoxPackets.
    :param other: The other wrapped redvox packet to compare to.
    :return: A list of differences or an empty list if there are none.
    &#34;&#34;&#34;
    diffs = map(lambda tuple2: reader_utils.diff(tuple2[0], tuple2[1]), [
        (self.api(), other.api()),
        (self.redvox_id(), other.redvox_id()),
        (self.uuid(), other.uuid()),
        (self.authenticated_email(), other.authenticated_email()),
        (self.authentication_token(), other.authentication_token()),
        (self.firebase_token(), other.firebase_token()),
        (self.is_backfilled(), other.is_backfilled()),
        (self.is_private(), other.is_private()),
        (self.is_scrambled(), other.is_scrambled()),
        (self.device_make(), other.device_make()),
        (self.device_model(), other.device_model()),
        (self.device_os(), other.device_os()),
        (self.device_os_version(), other.device_os_version()),
        (self.app_version(), other.app_version()),
        (self.battery_level_percent(), other.battery_level_percent()),
        (self.device_temperature_c(), other.device_temperature_c()),
        (self.acquisition_server(), other.acquisition_server()),
        (self.time_synchronization_server(), other.time_synchronization_server()),
        (self.authentication_server(), other.authentication_server()),
        (self.app_file_start_timestamp_epoch_microseconds_utc(),
         other.app_file_start_timestamp_epoch_microseconds_utc()),
        (self.app_file_start_timestamp_machine(), other.app_file_start_timestamp_machine()),
        (self.server_timestamp_epoch_microseconds_utc(),
         other.server_timestamp_epoch_microseconds_utc()),
        (self.metadata(), other.metadata()),
        (self.microphone_sensor(), other.microphone_sensor()),
        (self.barometer_sensor(), other.barometer_sensor()),
        (self.location_sensor(), other.location_sensor()),
        (self.time_synchronization_sensor(), other.time_synchronization_sensor()),
        (self.accelerometer_sensor(), other.accelerometer_sensor()),
        (self.magnetometer_sensor(), other.magnetometer_sensor()),
        (self.gyroscope_sensor(), other.gyroscope_sensor()),
        (self.light_sensor(), other.light_sensor()),
        (self.infrared_sensor(), other.infrared_sensor())
    ])
    # Filter only out only the differences
    diffs = filter(lambda tuple2: tuple2[0], diffs)
    # Extract the difference string
    diffs = map(lambda tuple2: tuple2[1], diffs)
    return list(diffs)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.duration_s"><code class="name flex">
<span>def <span class="ident">duration_s</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>The duration of this WrappedRedvoxPacket in seconds.
:return: The duration of this WrappedRedvoxPacket in seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def duration_s(self) -&gt; float:
    &#34;&#34;&#34;
    The duration of this WrappedRedvoxPacket in seconds.
    :return: The duration of this WrappedRedvoxPacket in seconds.
    &#34;&#34;&#34;
    microphone_sensor = self.microphone_sensor()
    return len(microphone_sensor.payload_values()) / microphone_sensor.sample_rate_hz()</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.end_timestamp_us_utc"><code class="name flex">
<span>def <span class="ident">end_timestamp_us_utc</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the end timestamp of a WrappedRedvoxPacket.
:return: The end timestamp of a WrappedRedvoxPacket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_timestamp_us_utc(self) -&gt; float:
    &#34;&#34;&#34;
    Returns the end timestamp of a WrappedRedvoxPacket.
    :return: The end timestamp of a WrappedRedvoxPacket.
    &#34;&#34;&#34;
    return self.start_timestamp_us_utc() + date_time_utils.seconds_to_microseconds(self.duration_s())</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.firebase_token"><code class="name flex">
<span>def <span class="ident">firebase_token</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def firebase_token(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.firebase_token</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_sensor"><code class="name flex">
<span>def <span class="ident">gyroscope_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.gyroscope_sensor.GyroscopeSensor" href="sensors/gyroscope_sensor.html#redvox.api900.sensors.gyroscope_sensor.GyroscopeSensor">GyroscopeSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gyroscope_sensor(self) -&gt; typing.Optional[_gyroscope_sensor.GyroscopeSensor]:
    &#34;&#34;&#34;
    Returns the high-level gyroscope channel API or None if this packet doesn&#39;t contain a channel of this type.
    :return: the high-level gyroscope channel API or None if this packet doesn&#39;t contain a channel of this type.
    &#34;&#34;&#34;
    if self.has_gyroscope_sensor():
        return _gyroscope_sensor.GyroscopeSensor(self._get_channel(api900_pb2.GYROSCOPE_X))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_sensor"><code class="name flex">
<span>def <span class="ident">has_accelerometer_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has an accelerometer channel.
:return: If this packet has an accelerometer channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_accelerometer_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has an accelerometer channel.
    :return: If this packet has an accelerometer channel.
    &#34;&#34;&#34;
    return self._has_channels([api900_pb2.ACCELEROMETER_X, api900_pb2.ACCELEROMETER_Y, api900_pb2.ACCELEROMETER_Z])</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_sensor"><code class="name flex">
<span>def <span class="ident">has_barometer_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has a barometer channel.
:return: If this packet has a barometer channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_barometer_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has a barometer channel.
    :return: If this packet has a barometer channel.
    &#34;&#34;&#34;
    return self._has_channel(api900_pb2.BAROMETER)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_sensor"><code class="name flex">
<span>def <span class="ident">has_gyroscope_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has a gyroscope channel.
:return: If this packet has a gyroscope channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_gyroscope_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has a gyroscope channel.
    :return: If this packet has a gyroscope channel.
    &#34;&#34;&#34;
    return self._has_channels([api900_pb2.GYROSCOPE_X, api900_pb2.GYROSCOPE_Y, api900_pb2.GYROSCOPE_Z])</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_sensor"><code class="name flex">
<span>def <span class="ident">has_image_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has an image channel.
:return: If this packlet has an image channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_image_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has an image channel.
    :return: If this packlet has an image channel.
    &#34;&#34;&#34;
    return self._has_channel(api900_pb2.IMAGE)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_sensor"><code class="name flex">
<span>def <span class="ident">has_infrared_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has an infrared channel.
:return: If this packlet has an infrared channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_infrared_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has an infrared channel.
    :return: If this packlet has an infrared channel.
    &#34;&#34;&#34;
    return self._has_channel(api900_pb2.INFRARED)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_sensor"><code class="name flex">
<span>def <span class="ident">has_light_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has a light channel.
:return: If this packet has a light channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_light_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has a light channel.
    :return: If this packet has a light channel.
    &#34;&#34;&#34;
    return self._has_channel(api900_pb2.LIGHT)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_sensor"><code class="name flex">
<span>def <span class="ident">has_location_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has a location channel.
:return: If this packet has a location channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_location_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has a location channel.
    :return: If this packet has a location channel.
    &#34;&#34;&#34;
    return (self._has_channels(
        [api900_pb2.LATITUDE, api900_pb2.LONGITUDE, api900_pb2.ALTITUDE, api900_pb2.SPEED,
         api900_pb2.ACCURACY]) or self._has_channels([api900_pb2.LATITUDE, api900_pb2.LONGITUDE]))</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_sensor"><code class="name flex">
<span>def <span class="ident">has_magnetometer_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has a magnetometer channel.
:return: If this packet has a magnetometer channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_magnetometer_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has a magnetometer channel.
    :return: If this packet has a magnetometer channel.
    &#34;&#34;&#34;
    return self._has_channels([api900_pb2.MAGNETOMETER_X, api900_pb2.MAGNETOMETER_Y, api900_pb2.MAGNETOMETER_Z])</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_sensor"><code class="name flex">
<span>def <span class="ident">has_microphone_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has a microphone channel.
:return: If this packet has a microphone channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_microphone_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has a microphone channel.
    :return: If this packet has a microphone channel.
    &#34;&#34;&#34;
    return self._has_channel(api900_pb2.MICROPHONE)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_sensor"><code class="name flex">
<span>def <span class="ident">has_time_synchronization_sensor</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if this packet has a time synchronization channel.
:return: If this packet has a time synchronization channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_time_synchronization_sensor(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns if this packet has a time synchronization channel.
    :return: If this packet has a time synchronization channel.
    &#34;&#34;&#34;
    if self._has_channel(api900_pb2.TIME_SYNCHRONIZATION):
        ch = _time_synchronization_sensor.TimeSynchronizationSensor(
            self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))
        return len(ch.payload_values()) &gt; 0

    return False</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_sensor"><code class="name flex">
<span>def <span class="ident">image_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.image_sensor.ImageSensor" href="sensors/image_sensor.html#redvox.api900.sensors.image_sensor.ImageSensor">ImageSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level image channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level image channel API or None if this packet doesn't contain a channel of this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image_sensor(self) -&gt; typing.Optional[_image_sensor.ImageSensor]:
    &#34;&#34;&#34;
    Returns the high-level image channel API or None if this packet doesn&#39;t contain a channel of this type.
    :return: the high-level image channel API or None if this packet doesn&#39;t contain a channel of this type.
    &#34;&#34;&#34;
    if self.has_image_sensor():
        return _image_sensor.ImageSensor(self._get_channel(api900_pb2.IMAGE))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_sensor"><code class="name flex">
<span>def <span class="ident">infrared_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.infrared_sensor.InfraredSensor" href="sensors/infrared_sensor.html#redvox.api900.sensors.infrared_sensor.InfraredSensor">InfraredSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level infrared channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level infrared channel API or None if this packet doesn't contain a channel of this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infrared_sensor(self) -&gt; typing.Optional[_infrared_sensor.InfraredSensor]:
    &#34;&#34;&#34;
    Returns the high-level infrared channel API or None if this packet doesn&#39;t contain a channel of this type.
    :return: the high-level infrared channel API or None if this packet doesn&#39;t contain a channel of this type.
    &#34;&#34;&#34;
    if self.has_infrared_sensor():
        return _infrared_sensor.InfraredSensor(self._get_channel(api900_pb2.INFRARED))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_backfilled"><code class="name flex">
<span>def <span class="ident">is_backfilled</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_backfilled(self) -&gt; bool:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.is_backfilled</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_private"><code class="name flex">
<span>def <span class="ident">is_private</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_private(self) -&gt; bool:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.is_private</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_scrambled"><code class="name flex">
<span>def <span class="ident">is_scrambled</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_scrambled(self) -&gt; bool:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.is_scrambled</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_synch_corrected"><code class="name flex">
<span>def <span class="ident">is_synch_corrected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the isSynchCorrected value from the metadata if it exists.
:return: The isSynchCorrected value from the metadata if it exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_synch_corrected(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns the isSynchCorrected value from the metadata if it exists.
    :return: The isSynchCorrected value from the metadata if it exists.
    &#34;&#34;&#34;

    def _parse_bool(s: str) -&gt; bool:
        return s == &#34;true&#34; or s == &#34;True&#34;

    try:
        return _parse_bool(self.metadata_as_dict()[&#34;isSynchCorrected&#34;])
    except (KeyError, ValueError):
        return False</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_sensor"><code class="name flex">
<span>def <span class="ident">light_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.light_sensor.LightSensor" href="sensors/light_sensor.html#redvox.api900.sensors.light_sensor.LightSensor">LightSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level light channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level light channel API or None if this packet doesn't contain a channel of this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def light_sensor(self) -&gt; typing.Optional[_light_sensor.LightSensor]:
    &#34;&#34;&#34;
    Returns the high-level light channel API or None if this packet doesn&#39;t contain a channel of this type.
    :return: the high-level light channel API or None if this packet doesn&#39;t contain a channel of this type.
    &#34;&#34;&#34;
    if self.has_light_sensor():
        return _light_sensor.LightSensor(self._get_channel(api900_pb2.LIGHT))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_sensor"><code class="name flex">
<span>def <span class="ident">location_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.location_sensor.LocationSensor" href="sensors/location_sensor.html#redvox.api900.sensors.location_sensor.LocationSensor">LocationSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level location channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level location channel API or None if this packet doesn't contain a channel of this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def location_sensor(self) -&gt; typing.Optional[_location_sensor.LocationSensor]:
    &#34;&#34;&#34;
    Returns the high-level location channel API or None if this packet doesn&#39;t contain a channel of this type.
    :return: the high-level location channel API or None if this packet doesn&#39;t contain a channel of this type.
    &#34;&#34;&#34;
    if self.has_location_sensor():
        return _location_sensor.LocationSensor(self._get_channel(api900_pb2.LATITUDE))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.mach_time_zero"><code class="name flex">
<span>def <span class="ident">mach_time_zero</span></span>(<span>self) ‑> typing.Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the mach time zero from the metadata if it exists.
:return: The mach time zero from the metadata if it exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mach_time_zero(self) -&gt; typing.Optional[int]:
    &#34;&#34;&#34;
    Returns the mach time zero from the metadata if it exists.
    :return: The mach time zero from the metadata if it exists.
    &#34;&#34;&#34;
    try:
        # First, try to extract metadata from the correct location
        top_level_metadata: typing.Dict[str, str] = self.metadata_as_dict()
        if &#34;machTimeZero&#34; in top_level_metadata:
            return migrations.maybe_get_float(int(top_level_metadata[&#34;machTimeZero&#34;]))

        # If that fails, some Androids stored it in the Location metadata
        location_sensor = self.location_sensor()
        if location_sensor is not None:
            location_metadata: typing.Dict[str, str] = location_sensor.metadata_as_dict()
            if &#34;machTimeZero&#34; in location_metadata:
                return migrations.maybe_get_float(int(location_metadata[&#34;machTimeZero&#34;]))

        # Finally, if it hasn&#39;t been found, it&#39;s probably a really old packet that doesn&#39;t contain this field
        return None
    except (KeyError, ValueError):
        return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_sensor"><code class="name flex">
<span>def <span class="ident">magnetometer_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.magnetometer_sensor.MagnetometerSensor" href="sensors/magnetometer_sensor.html#redvox.api900.sensors.magnetometer_sensor.MagnetometerSensor">MagnetometerSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def magnetometer_sensor(self) -&gt; typing.Optional[_magnetometer_sensor.MagnetometerSensor]:
    &#34;&#34;&#34;
    Returns the high-level magnetometer channel API or None if this packet doesn&#39;t contain a channel of this type.
    :return: the high-level magnetometer channel API or None if this packet doesn&#39;t contain a channel of this type.
    &#34;&#34;&#34;
    if self.has_magnetometer_sensor():
        return _magnetometer_sensor.MagnetometerSensor(self._get_channel(api900_pb2.MAGNETOMETER_X))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata"><code class="name flex">
<span>def <span class="ident">metadata</span></span>(<span>self) ‑> typing.List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata(self) -&gt; typing.List[str]:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._metadata_list</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata_as_dict"><code class="name flex">
<span>def <span class="ident">metadata_as_dict</span></span>(<span>self) ‑> typing.Dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return this packet's metadata as a key-value Python dictionary.
:return: This packet's metadata as a key-value Python dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata_as_dict(self) -&gt; typing.Dict[str, str]:
    &#34;&#34;&#34;
    Return this packet&#39;s metadata as a key-value Python dictionary.
    :return: This packet&#39;s metadata as a key-value Python dictionary.
    &#34;&#34;&#34;
    return reader_utils.get_metadata_as_dict(self._metadata_list)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_sensor"><code class="name flex">
<span>def <span class="ident">microphone_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.microphone_sensor.MicrophoneSensor" href="sensors/microphone_sensor.html#redvox.api900.sensors.microphone_sensor.MicrophoneSensor">MicrophoneSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level microphone channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level microphone channel API or None if this packet doesn't contain a channel of this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def microphone_sensor(self) -&gt; typing.Optional[_microphone_sensor.MicrophoneSensor]:
    &#34;&#34;&#34;
    Returns the high-level microphone channel API or None if this packet doesn&#39;t contain a channel of this type.
    :return: the high-level microphone channel API or None if this packet doesn&#39;t contain a channel of this type.
    &#34;&#34;&#34;
    if self.has_microphone_sensor():
        return _microphone_sensor.MicrophoneSensor(self._get_channel(api900_pb2.MICROPHONE))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_id"><code class="name flex">
<span>def <span class="ident">redvox_id</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redvox_id(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.redvox_id</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_packet"><code class="name flex">
<span>def <span class="ident">redvox_packet</span></span>(<span>self) ‑> api900_pb2.RedvoxPacket</span>
</code></dt>
<dd>
<div class="desc"><p>returns the protobuf redvox packet
:return: protobuf redvox packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redvox_packet(self) -&gt; api900_pb2.RedvoxPacket:
    &#34;&#34;&#34;
    returns the protobuf redvox packet
    :return: protobuf redvox packet
    &#34;&#34;&#34;
    return self._redvox_packet</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.server_timestamp_epoch_microseconds_utc"><code class="name flex">
<span>def <span class="ident">server_timestamp_epoch_microseconds_utc</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def server_timestamp_epoch_microseconds_utc(self) -&gt; int:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return migrations.maybe_get_float(self._redvox_packet.server_timestamp_epoch_microseconds_utc)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_sensor"><code class="name flex">
<span>def <span class="ident">set_accelerometer_sensor</span></span>(<span>self, accelerometer_sensor: typing.Optional[<a title="redvox.api900.sensors.accelerometer_sensor.AccelerometerSensor" href="sensors/accelerometer_sensor.html#redvox.api900.sensors.accelerometer_sensor.AccelerometerSensor">AccelerometerSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets this packet's accelerometer sensor. A channel can be removed by passing in None.
:param accelerometer_sensor: An optional instance of a accelerometer sensor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_accelerometer_sensor(self,
                             accelerometer_sensor: typing.Optional[
                                 _accelerometer_sensor.AccelerometerSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets this packet&#39;s accelerometer sensor. A channel can be removed by passing in None.
    :param accelerometer_sensor: An optional instance of a accelerometer sensor.
    &#34;&#34;&#34;
    if self.has_accelerometer_sensor():
        self._delete_channel(api900_pb2.ACCELEROMETER_X)

    if accelerometer_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(accelerometer_sensor._unevenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_acquisition_server"><code class="name flex">
<span>def <span class="ident">set_acquisition_server</span></span>(<span>self, server: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the acquisition server url
:param server: url to acquisition server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_acquisition_server(self, server: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the acquisition server url
    :param server: url to acquisition server
    &#34;&#34;&#34;
    self._redvox_packet.acquisition_server = server
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_api"><code class="name flex">
<span>def <span class="ident">set_api</span></span>(<span>self, version: int) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the api version number
:param version: version number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_api(self, version: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the api version number
    :param version: version number
    &#34;&#34;&#34;
    self._redvox_packet.api = version
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_epoch_microseconds_utc"><code class="name flex">
<span>def <span class="ident">set_app_file_start_timestamp_epoch_microseconds_utc</span></span>(<span>self, time: int) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the timestamp of packet creation
:param time: time when packet was created in microseconds since utc epoch</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_app_file_start_timestamp_epoch_microseconds_utc(self, time: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the timestamp of packet creation
    :param time: time when packet was created in microseconds since utc epoch
    &#34;&#34;&#34;
    self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc = migrations.maybe_set_int(time)
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_machine"><code class="name flex">
<span>def <span class="ident">set_app_file_start_timestamp_machine</span></span>(<span>self, time: int) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the internal machine timestamp of packet creation
:param time: time when packet was created on local machine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_app_file_start_timestamp_machine(self, time: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the internal machine timestamp of packet creation
    :param time: time when packet was created on local machine
    &#34;&#34;&#34;
    self._redvox_packet.app_file_start_timestamp_machine = migrations.maybe_set_int(time)
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_version"><code class="name flex">
<span>def <span class="ident">set_app_version</span></span>(<span>self, version: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the app version number
:param version: app version string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_app_version(self, version: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the app version number
    :param version: app version string
    &#34;&#34;&#34;
    self._redvox_packet.app_version = version
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authenticated_email"><code class="name flex">
<span>def <span class="ident">set_authenticated_email</span></span>(<span>self, email: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the authenticated email
:param email: authenticated email string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_authenticated_email(self, email: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the authenticated email
    :param email: authenticated email string
    &#34;&#34;&#34;
    self._redvox_packet.authenticated_email = email
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_server"><code class="name flex">
<span>def <span class="ident">set_authentication_server</span></span>(<span>self, server: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the authentication server url
:param server: url to authentication server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_authentication_server(self, server: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the authentication server url
    :param server: url to authentication server
    &#34;&#34;&#34;
    self._redvox_packet.authentication_server = server
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_token"><code class="name flex">
<span>def <span class="ident">set_authentication_token</span></span>(<span>self, token: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the authentication token
:param token: authentication token string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_authentication_token(self, token: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the authentication token
    :param token: authentication token string
    &#34;&#34;&#34;
    self._redvox_packet.authentication_token = token
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_sensor"><code class="name flex">
<span>def <span class="ident">set_barometer_sensor</span></span>(<span>self, barometer_sensor: typing.Optional[<a title="redvox.api900.sensors.barometer_sensor.BarometerSensor" href="sensors/barometer_sensor.html#redvox.api900.sensors.barometer_sensor.BarometerSensor">BarometerSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets this packets barometer sensor. A channel can be removed by passing in None.
:param barometer_sensor: An optional instance of a barometer sensor.
:return: This instance of a wrapped redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_barometer_sensor(self, barometer_sensor: typing.Optional[
        _barometer_sensor.BarometerSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets this packets barometer sensor. A channel can be removed by passing in None.
    :param barometer_sensor: An optional instance of a barometer sensor.
    :return: This instance of a wrapped redvox packet.
    &#34;&#34;&#34;
    if self.has_barometer_sensor():
        self._delete_channel(api900_pb2.BAROMETER)

    if barometer_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(barometer_sensor._unevenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_battery_level_percent"><code class="name flex">
<span>def <span class="ident">set_battery_level_percent</span></span>(<span>self, percent: float) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the percentage of battery left
:param percent: percentage of battery left</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_battery_level_percent(self, percent: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the percentage of battery left
    :param percent: percentage of battery left
    &#34;&#34;&#34;
    self._redvox_packet.battery_level_percent = percent
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_latency"><code class="name flex">
<span>def <span class="ident">set_best_latency</span></span>(<span>self, best_latency: float) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets the best latency in the packet's metadata.
:param best_latency: The best latency to use.
:return: An instance of this wrapped packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_best_latency(self, best_latency: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets the best latency in the packet&#39;s metadata.
    :param best_latency: The best latency to use.
    :return: An instance of this wrapped packet.
    &#34;&#34;&#34;
    return self.add_metadata(&#34;bestLatency&#34;, str(best_latency))</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_offset"><code class="name flex">
<span>def <span class="ident">set_best_offset</span></span>(<span>self, best_offset: float) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets the best offset in the packet's metadata.
:param best_offset: The best offset to use.
:return: An instance of this wrapped packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_best_offset(self, best_offset: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets the best offset in the packet&#39;s metadata.
    :param best_offset: The best offset to use.
    :return: An instance of this wrapped packet.
    &#34;&#34;&#34;
    return self.add_metadata(&#34;bestOffset&#34;, str(best_offset))</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_make"><code class="name flex">
<span>def <span class="ident">set_device_make</span></span>(<span>self, make: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the make of the device
:param make: make of the device string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_device_make(self, make: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the make of the device
    :param make: make of the device string
    &#34;&#34;&#34;
    self._redvox_packet.device_make = make
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_model"><code class="name flex">
<span>def <span class="ident">set_device_model</span></span>(<span>self, model: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the model of the device
:param model: model of the device string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_device_model(self, model: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the model of the device
    :param model: model of the device string
    &#34;&#34;&#34;
    self._redvox_packet.device_model = model
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os"><code class="name flex">
<span>def <span class="ident">set_device_os</span></span>(<span>self, device_os: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the device operating system
:param device_os: operating system string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_device_os(self, device_os: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the device operating system
    :param device_os: operating system string
    &#34;&#34;&#34;
    self._redvox_packet.device_os = device_os
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os_version"><code class="name flex">
<span>def <span class="ident">set_device_os_version</span></span>(<span>self, version: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the device OS version
:param version: device OS version string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_device_os_version(self, version: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the device OS version
    :param version: device OS version string
    &#34;&#34;&#34;
    self._redvox_packet.device_os_version = version
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_temperature_c"><code class="name flex">
<span>def <span class="ident">set_device_temperature_c</span></span>(<span>self, temp: float) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the device temperature in degrees Celsius
:param temp: temperature in degrees Celsius</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_device_temperature_c(self, temp: float) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the device temperature in degrees Celsius
    :param temp: temperature in degrees Celsius
    &#34;&#34;&#34;
    self._redvox_packet.device_temperature_c = temp
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_firebase_token"><code class="name flex">
<span>def <span class="ident">set_firebase_token</span></span>(<span>self, token: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the firebase token
:param token: firebase token string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_firebase_token(self, token: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the firebase token
    :param token: firebase token string
    &#34;&#34;&#34;
    self._redvox_packet.firebase_token = token
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_sensor"><code class="name flex">
<span>def <span class="ident">set_gyroscope_sensor</span></span>(<span>self, gyroscope_sensor: typing.Optional[<a title="redvox.api900.sensors.gyroscope_sensor.GyroscopeSensor" href="sensors/gyroscope_sensor.html#redvox.api900.sensors.gyroscope_sensor.GyroscopeSensor">GyroscopeSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets this packet's gyroscope sensor. A channel can be removed by passing in None.
:param gyroscope_sensor: An optional instance of a gyroscope sensor.
:return: This instance of a wrapped redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_gyroscope_sensor(self, gyroscope_sensor: typing.Optional[
        _gyroscope_sensor.GyroscopeSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets this packet&#39;s gyroscope sensor. A channel can be removed by passing in None.
    :param gyroscope_sensor: An optional instance of a gyroscope sensor.
    :return: This instance of a wrapped redvox packet.
    &#34;&#34;&#34;
    if self.has_gyroscope_sensor():
        self._delete_channel(api900_pb2.GYROSCOPE_X)

    if gyroscope_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(gyroscope_sensor._unevenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_sensor"><code class="name flex">
<span>def <span class="ident">set_image_sensor</span></span>(<span>self, image_sensor: typing.Optional[<a title="redvox.api900.sensors.image_sensor.ImageSensor" href="sensors/image_sensor.html#redvox.api900.sensors.image_sensor.ImageSensor">ImageSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set's the image channel.
:param image_sensor: Image sensor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_image_sensor(self, image_sensor: typing.Optional[_image_sensor.ImageSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Set&#39;s the image channel.
    :param image_sensor: Image sensor.
    &#34;&#34;&#34;
    if self.has_image_sensor():
        self._delete_channel(api900_pb2.IMAGE)

    if image_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(image_sensor._unevenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_sensor"><code class="name flex">
<span>def <span class="ident">set_infrared_sensor</span></span>(<span>self, infrared_sensor: typing.Optional[<a title="redvox.api900.sensors.infrared_sensor.InfraredSensor" href="sensors/infrared_sensor.html#redvox.api900.sensors.infrared_sensor.InfraredSensor">InfraredSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets this packet's infrared sensor. A channel can be removed by passing in None.
:param infrared_sensor: An optional instance of a infrared sensor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_infrared_sensor(self,
                        infrared_sensor: typing.Optional[
                            _infrared_sensor.InfraredSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets this packet&#39;s infrared sensor. A channel can be removed by passing in None.
    :param infrared_sensor: An optional instance of a infrared sensor.
    &#34;&#34;&#34;
    if self.has_infrared_sensor():
        self._delete_channel(api900_pb2.INFRARED)

    if infrared_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(infrared_sensor._unevenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_backfilled"><code class="name flex">
<span>def <span class="ident">set_is_backfilled</span></span>(<span>self, tof: bool) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the is_backfilled flag
:param tof: true or false</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_backfilled(self, tof: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the is_backfilled flag
    :param tof: true or false
    &#34;&#34;&#34;
    self._redvox_packet.is_backfilled = tof
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_private"><code class="name flex">
<span>def <span class="ident">set_is_private</span></span>(<span>self, tof: bool) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the is_private flag
:param tof: true or false</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_private(self, tof: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the is_private flag
    :param tof: true or false
    &#34;&#34;&#34;
    self._redvox_packet.is_private = tof
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_scrambled"><code class="name flex">
<span>def <span class="ident">set_is_scrambled</span></span>(<span>self, tof: bool) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the is_scrambled flag
:param tof: true or false</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_scrambled(self, tof: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the is_scrambled flag
    :param tof: true or false
    &#34;&#34;&#34;
    self._redvox_packet.is_scrambled = tof
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_synch_corrected"><code class="name flex">
<span>def <span class="ident">set_is_synch_corrected</span></span>(<span>self, is_synch_corrected: bool) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets the is_synch_corrected field in the packet's metadata.
:param is_synch_corrected: The is_synch_corrected field to use.
:return: An instance of this wrapped packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_synch_corrected(self, is_synch_corrected: bool) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets the is_synch_corrected field in the packet&#39;s metadata.
    :param is_synch_corrected: The is_synch_corrected field to use.
    :return: An instance of this wrapped packet.
    &#34;&#34;&#34;
    return self.add_metadata(&#34;isSynchCorrected&#34;, &#34;true&#34; if is_synch_corrected else &#34;false&#34;)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_sensor"><code class="name flex">
<span>def <span class="ident">set_light_sensor</span></span>(<span>self, light_sensor: typing.Optional[<a title="redvox.api900.sensors.light_sensor.LightSensor" href="sensors/light_sensor.html#redvox.api900.sensors.light_sensor.LightSensor">LightSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets this packet's light sensor. A channel can be removed by passing in None.
:param light_sensor: An optional instance of a light sensor.
:return: This instance of a wrapped redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_light_sensor(self, light_sensor: typing.Optional[_light_sensor.LightSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets this packet&#39;s light sensor. A channel can be removed by passing in None.
    :param light_sensor: An optional instance of a light sensor.
    :return: This instance of a wrapped redvox packet.
    &#34;&#34;&#34;
    if self.has_light_sensor():
        self._delete_channel(api900_pb2.LIGHT)

    if light_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(light_sensor._unevenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_sensor"><code class="name flex">
<span>def <span class="ident">set_location_sensor</span></span>(<span>self, location_sensor: typing.Optional[<a title="redvox.api900.sensors.location_sensor.LocationSensor" href="sensors/location_sensor.html#redvox.api900.sensors.location_sensor.LocationSensor">LocationSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets this packet's location sensor. A channel can be removed by passing in None.
:param location_sensor: An optional instance of a location sensor.
:return: This instance of a wrapped redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_location_sensor(self,
                        location_sensor: typing.Optional[_location_sensor.LocationSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets this packet&#39;s location sensor. A channel can be removed by passing in None.
    :param location_sensor: An optional instance of a location sensor.
    :return: This instance of a wrapped redvox packet.
    &#34;&#34;&#34;
    if self.has_location_sensor():
        self._delete_channel(api900_pb2.LATITUDE)

    if location_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(location_sensor._unevenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_mach_time_zero"><code class="name flex">
<span>def <span class="ident">set_mach_time_zero</span></span>(<span>self, mach_time_zero: int) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets the mach time zero in the packet's metadata.
:param mach_time_zero: The mach time zero to use.
:return: An instance of this wrapped packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mach_time_zero(self, mach_time_zero: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets the mach time zero in the packet&#39;s metadata.
    :param mach_time_zero: The mach time zero to use.
    :return: An instance of this wrapped packet.
    &#34;&#34;&#34;
    return self.add_metadata(&#34;machTimeZero&#34;, str(mach_time_zero))</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_sensor"><code class="name flex">
<span>def <span class="ident">set_magnetometer_sensor</span></span>(<span>self, magnetometer_sensor: typing.Optional[<a title="redvox.api900.sensors.magnetometer_sensor.MagnetometerSensor" href="sensors/magnetometer_sensor.html#redvox.api900.sensors.magnetometer_sensor.MagnetometerSensor">MagnetometerSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets this packet's magnetomer sensor. A channel can be removed by passing in None.
:param magnetometer_sensor: An optional instance of a magnetometer sensor.
:return: This instance of a wrapped redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_magnetometer_sensor(self,
                            magnetometer_sensor: typing.Optional[
                                _magnetometer_sensor.MagnetometerSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets this packet&#39;s magnetomer sensor. A channel can be removed by passing in None.
    :param magnetometer_sensor: An optional instance of a magnetometer sensor.
    :return: This instance of a wrapped redvox packet.
    &#34;&#34;&#34;
    if self.has_magnetometer_sensor():
        self._delete_channel(api900_pb2.MAGNETOMETER_X)

    if magnetometer_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(magnetometer_sensor._unevenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata"><code class="name flex">
<span>def <span class="ident">set_metadata</span></span>(<span>self, data: typing.List[str]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the metadata
:param data: metadata as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_metadata(self, data: typing.List[str]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the metadata
    :param data: metadata as list of strings
    &#34;&#34;&#34;
    self._metadata_list = data
    self._redvox_packet.metadata[:] = data
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata_as_dict"><code class="name flex">
<span>def <span class="ident">set_metadata_as_dict</span></span>(<span>self, metadata_dict: typing.Dict[str, str]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets the metadata using a dictionary.
:param metadata_dict: Dictionary of metadata.
:return: This WrappedRedvoxPacket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_metadata_as_dict(self, metadata_dict: typing.Dict[str, str]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets the metadata using a dictionary.
    :param metadata_dict: Dictionary of metadata.
    :return: This WrappedRedvoxPacket.
    &#34;&#34;&#34;
    self.set_metadata(reader_utils.metadata_dict_to_list(metadata_dict))
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_sensor"><code class="name flex">
<span>def <span class="ident">set_microphone_sensor</span></span>(<span>self, microphone_sensor: typing.Optional[<a title="redvox.api900.sensors.microphone_sensor.MicrophoneSensor" href="sensors/microphone_sensor.html#redvox.api900.sensors.microphone_sensor.MicrophoneSensor">MicrophoneSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets this packets microphone sensor. A channel can be removed by passing in None.
:param microphone_sensor: An optional instance of a microphone sensor.
:return: This instance of a wrapped redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_microphone_sensor(self, microphone_sensor: typing.Optional[
        _microphone_sensor.MicrophoneSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets this packets microphone sensor. A channel can be removed by passing in None.
    :param microphone_sensor: An optional instance of a microphone sensor.
    :return: This instance of a wrapped redvox packet.
    &#34;&#34;&#34;
    if self.has_microphone_sensor():
        self._delete_channel(api900_pb2.MICROPHONE)

    if microphone_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(microphone_sensor._evenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_redvox_id"><code class="name flex">
<span>def <span class="ident">set_redvox_id</span></span>(<span>self, rid: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the redvox id
:param rid: redvox id string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_redvox_id(self, rid: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the redvox id
    :param rid: redvox id string
    &#34;&#34;&#34;
    self._redvox_packet.redvox_id = rid
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_server_timestamp_epoch_microseconds_utc"><code class="name flex">
<span>def <span class="ident">set_server_timestamp_epoch_microseconds_utc</span></span>(<span>self, time: int) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the server timestamp when the packet was received
:param time: time when packet was received by server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_server_timestamp_epoch_microseconds_utc(self, time: int) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the server timestamp when the packet was received
    :param time: time when packet was received by server
    &#34;&#34;&#34;
    self._redvox_packet.server_timestamp_epoch_microseconds_utc = time
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_sensor"><code class="name flex">
<span>def <span class="ident">set_time_synchronization_sensor</span></span>(<span>self, time_synchronization_sensor: typing.Optional[<a title="redvox.api900.sensors.time_synchronization_sensor.TimeSynchronizationSensor" href="sensors/time_synchronization_sensor.html#redvox.api900.sensors.time_synchronization_sensor.TimeSynchronizationSensor">TimeSynchronizationSensor</a>]) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets this packet's time sync sensor. A channel can be removed by passing in None.
:param time_synchronization_sensor: An optional instance of a time sync sensor.
:return: This instance of a wrapped redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_synchronization_sensor(self, time_synchronization_sensor: typing.Optional[
        _time_synchronization_sensor.TimeSynchronizationSensor]) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    Sets this packet&#39;s time sync sensor. A channel can be removed by passing in None.
    :param time_synchronization_sensor: An optional instance of a time sync sensor.
    :return: This instance of a wrapped redvox packet.
    &#34;&#34;&#34;
    if self.has_time_synchronization_sensor():
        self._delete_channel(api900_pb2.TIME_SYNCHRONIZATION)

    if time_synchronization_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(time_synchronization_sensor._unevenly_sampled_channel)

    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_server"><code class="name flex">
<span>def <span class="ident">set_time_synchronization_server</span></span>(<span>self, server: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the time synchronization server url
:param server: url to time synchronization server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_synchronization_server(self, server: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the time synchronization server url
    :param server: url to time synchronization server
    &#34;&#34;&#34;
    self._redvox_packet.time_synchronization_server = server
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_uuid"><code class="name flex">
<span>def <span class="ident">set_uuid</span></span>(<span>self, uid: str) ‑> <a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
</code></dt>
<dd>
<div class="desc"><p>sets the uuid
:param uid: uuid string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_uuid(self, uid: str) -&gt; &#39;WrappedRedvoxPacket&#39;:
    &#34;&#34;&#34;
    sets the uuid
    :param uid: uuid string
    &#34;&#34;&#34;
    self._redvox_packet.uuid = uid
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.start_timestamp_us_utc"><code class="name flex">
<span>def <span class="ident">start_timestamp_us_utc</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the start timestamp of a WrappedRedvoxPacket.
:return: The start timestamp of a WrappedRedvoxPacket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_timestamp_us_utc(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the start timestamp of a WrappedRedvoxPacket.
    :return: The start timestamp of a WrappedRedvoxPacket.
    &#34;&#34;&#34;
    return migrations.maybe_get_float(
        self.microphone_sensor().first_sample_timestamp_epoch_microseconds_utc())</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_sensor"><code class="name flex">
<span>def <span class="ident">time_synchronization_sensor</span></span>(<span>self) ‑> typing.Optional[<a title="redvox.api900.sensors.time_synchronization_sensor.TimeSynchronizationSensor" href="sensors/time_synchronization_sensor.html#redvox.api900.sensors.time_synchronization_sensor.TimeSynchronizationSensor">TimeSynchronizationSensor</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the high-level time synchronization channel API or None if this packet doesn't contain a channel of
this type.
:return: the high-level time synchronization channel API or None if this packet doesn't contain a channel of
this type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_synchronization_sensor(self) -&gt; typing.Optional[_time_synchronization_sensor.TimeSynchronizationSensor]:
    &#34;&#34;&#34;
    Returns the high-level time synchronization channel API or None if this packet doesn&#39;t contain a channel of
    this type.
    :return: the high-level time synchronization channel API or None if this packet doesn&#39;t contain a channel of
    this type.
    &#34;&#34;&#34;
    if self.has_time_synchronization_sensor():
        return _time_synchronization_sensor.TimeSynchronizationSensor(
            self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_server"><code class="name flex">
<span>def <span class="ident">time_synchronization_server</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_synchronization_server(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.time_synchronization_server</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the protobuf packet stored in this wrapped packet to JSON.
:return: The JSON representation of the protobuf encoded packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; str:
    &#34;&#34;&#34;
    Converts the protobuf packet stored in this wrapped packet to JSON.
    :return: The JSON representation of the protobuf encoded packet.
    &#34;&#34;&#34;
    return reader_utils.to_json(self._redvox_packet)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.update_uneven_sensor_timestamps"><code class="name flex">
<span>def <span class="ident">update_uneven_sensor_timestamps</span></span>(<span>self, time_delta: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a time delta in microseconds, will adjust all unevenly sampled sensor timestamps by that amount.
Use negative values to adjust backwards in time.
:param time_delta: amount of time to adjust timestamps in microseconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_uneven_sensor_timestamps(self, time_delta: int or float):
    &#34;&#34;&#34;
    Given a time delta in microseconds, will adjust all unevenly sampled sensor timestamps by that amount.
    Use negative values to adjust backwards in time.
    :param time_delta: amount of time to adjust timestamps in microseconds
    &#34;&#34;&#34;
    for channel in self._unevenly_sampled_channels_field:
        if not channel.has_channel(api900_pb2.TIME_SYNCHRONIZATION):
            channel.set_timestamps_microseconds_utc(channel.timestamps_microseconds_utc + time_delta)</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.uuid"><code class="name flex">
<span>def <span class="ident">uuid</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>See <a href="https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master">https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master</a> for a
description of this field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uuid(self) -&gt; str:
    &#34;&#34;&#34;
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    &#34;&#34;&#34;
    return self._redvox_packet.uuid</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_json"><code class="name flex">
<span>def <span class="ident">write_json</span></span>(<span>self, directory: str, filename: typing.Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a RedVox compliant .json file to the specified directory.
:param directory: The directory to write the file to.
:param filename: An optional filename (the default filename will be used if one is not provided).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_json(self, directory: str, filename: typing.Optional[str] = None):
    &#34;&#34;&#34;
    Writes a RedVox compliant .json file to the specified directory.
    :param directory: The directory to write the file to.
    :param filename: An optional filename (the default filename will be used if one is not provided).
    &#34;&#34;&#34;
    filename = self.default_filename(extension=&#34;json&#34;) if filename is None else filename
    path = os.path.join(directory, filename)
    with open(path, &#34;w&#34;) as json_out:
        json_out.write(self.to_json())</code></pre>
</details>
</dd>
<dt id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_rdvxz"><code class="name flex">
<span>def <span class="ident">write_rdvxz</span></span>(<span>self, directory: str, filename: typing.Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a compressed .rdvxz file to the specified directory.
:param directory: The directory to write the file to.
:param filename: An optional filename (the default filename will be used if one is not provided).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_rdvxz(self, directory: str, filename: typing.Optional[str] = None):
    &#34;&#34;&#34;
    Writes a compressed .rdvxz file to the specified directory.
    :param directory: The directory to write the file to.
    :param filename: An optional filename (the default filename will be used if one is not provided).
    &#34;&#34;&#34;
    filename = self.default_filename() if filename is None else filename
    path = os.path.join(directory, filename)
    with open(path, &#34;wb&#34;) as rdvxz_out:
        rdvxz_out.write(self.compressed_buffer())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.api900" href="index.html">redvox.api900</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.api900.wrapped_redvox_packet.read_buffer" href="#redvox.api900.wrapped_redvox_packet.read_buffer">read_buffer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></code></h4>
<ul class="">
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_sensor">accelerometer_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.acquisition_server" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.acquisition_server">acquisition_server</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.add_metadata" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.add_metadata">add_metadata</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.api" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.api">api</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc">app_file_start_timestamp_epoch_microseconds_utc</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_machine" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_machine">app_file_start_timestamp_machine</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_version" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_version">app_version</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authenticated_email" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authenticated_email">authenticated_email</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_server" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_server">authentication_server</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_token" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_token">authentication_token</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_sensor">barometer_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.battery_level_percent" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.battery_level_percent">battery_level_percent</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_latency" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_latency">best_latency</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_offset" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_offset">best_offset</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.clone" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.clone">clone</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.compressed_buffer" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.compressed_buffer">compressed_buffer</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.concat" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.concat">concat</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.default_filename" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.default_filename">default_filename</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_make" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_make">device_make</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_model" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_model">device_model</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os">device_os</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os_version" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os_version">device_os_version</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_temperature_c" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_temperature_c">device_temperature_c</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.diff" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.diff">diff</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.duration_s" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.duration_s">duration_s</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.end_timestamp_us_utc" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.end_timestamp_us_utc">end_timestamp_us_utc</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.firebase_token" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.firebase_token">firebase_token</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_sensor">gyroscope_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_sensor">has_accelerometer_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_sensor">has_barometer_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_sensor">has_gyroscope_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_sensor">has_image_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_sensor">has_infrared_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_sensor">has_light_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_sensor">has_location_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_sensor">has_magnetometer_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_sensor">has_microphone_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_sensor">has_time_synchronization_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_sensor">image_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_sensor">infrared_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_backfilled" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_backfilled">is_backfilled</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_private" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_private">is_private</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_scrambled" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_scrambled">is_scrambled</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_synch_corrected" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_synch_corrected">is_synch_corrected</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_sensor">light_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_sensor">location_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.mach_time_zero" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.mach_time_zero">mach_time_zero</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_sensor">magnetometer_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata">metadata</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata_as_dict" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata_as_dict">metadata_as_dict</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_sensor">microphone_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_id" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_id">redvox_id</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_packet" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_packet">redvox_packet</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.server_timestamp_epoch_microseconds_utc" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.server_timestamp_epoch_microseconds_utc">server_timestamp_epoch_microseconds_utc</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_sensor">set_accelerometer_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_acquisition_server" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_acquisition_server">set_acquisition_server</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_api" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_api">set_api</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_epoch_microseconds_utc" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_epoch_microseconds_utc">set_app_file_start_timestamp_epoch_microseconds_utc</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_machine" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_machine">set_app_file_start_timestamp_machine</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_version" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_version">set_app_version</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authenticated_email" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authenticated_email">set_authenticated_email</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_server" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_server">set_authentication_server</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_token" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_token">set_authentication_token</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_sensor">set_barometer_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_battery_level_percent" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_battery_level_percent">set_battery_level_percent</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_latency" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_latency">set_best_latency</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_offset" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_offset">set_best_offset</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_make" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_make">set_device_make</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_model" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_model">set_device_model</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os">set_device_os</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os_version" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os_version">set_device_os_version</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_temperature_c" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_temperature_c">set_device_temperature_c</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_firebase_token" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_firebase_token">set_firebase_token</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_sensor">set_gyroscope_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_sensor">set_image_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_sensor">set_infrared_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_backfilled" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_backfilled">set_is_backfilled</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_private" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_private">set_is_private</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_scrambled" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_scrambled">set_is_scrambled</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_synch_corrected" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_synch_corrected">set_is_synch_corrected</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_sensor">set_light_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_sensor">set_location_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_mach_time_zero" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_mach_time_zero">set_mach_time_zero</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_sensor">set_magnetometer_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata">set_metadata</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata_as_dict" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata_as_dict">set_metadata_as_dict</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_sensor">set_microphone_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_redvox_id" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_redvox_id">set_redvox_id</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_server_timestamp_epoch_microseconds_utc" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_server_timestamp_epoch_microseconds_utc">set_server_timestamp_epoch_microseconds_utc</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_sensor">set_time_synchronization_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_server" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_server">set_time_synchronization_server</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_uuid" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_uuid">set_uuid</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.start_timestamp_us_utc" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.start_timestamp_us_utc">start_timestamp_us_utc</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_sensor" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_sensor">time_synchronization_sensor</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_server" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_server">time_synchronization_server</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.to_json" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.to_json">to_json</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.update_uneven_sensor_timestamps" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.update_uneven_sensor_timestamps">update_uneven_sensor_timestamps</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.uuid" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.uuid">uuid</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_json" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_json">write_json</a></code></li>
<li><code><a title="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_rdvxz" href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_rdvxz">write_rdvxz</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>