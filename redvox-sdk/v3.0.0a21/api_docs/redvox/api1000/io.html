<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>redvox.api1000.io API documentation</title>
<meta name="description" content="This module contains functions for reading and writing bulk API M data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.api1000.io</code></h1>
</header>
<section id="section-intro">
<p>This module contains functions for reading and writing bulk API M data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains functions for reading and writing bulk API M data.
&#34;&#34;&#34;

import glob
import os
from typing import List, Optional, Set, Tuple, Callable, TypeVar

import numpy as np

import redvox.api1000.common.lz4
import redvox.api1000.wrapped_redvox_packet.wrapped_packet as api_m_wp
import redvox.common.date_time_utils as date_time_utils


REDVOX_API_M_FILE_EXT = &#34;rdvxm&#34;


def calc_evenly_sampled_timestamps(start: float, samples: int, rate_hz: float) -&gt; np.array:
    &#34;&#34;&#34;
    given a start time, calculates samples amount of evenly spaced timestamps at rate_hz
    :param start: float, start timestamp
    :param samples: int, number of samples
    :param rate_hz: float, sample rate in hz
    :return: np.array with evenly spaced timestamps starting at start
    &#34;&#34;&#34;
    return np.array(start + date_time_utils.seconds_to_microseconds(np.arange(0, samples) / rate_hz))


# todo: stream inputs and read multiple buffers
class ReadWrappedPackets:
    &#34;&#34;&#34;
    A searchable/sortable list of continuous wrapped API M redvox packets
    A set of API M packets are continuous if:
        * their redvox ids are equal
        * their uuids are equal
        * their app start machine timestamps are equal
        * their sample rate is constant
        * their sensors do not change
        * there is no considerable gap between the end of one packet and the start of the next
    properties:
        wrapped_packets: list of wrapped redvox API M packets
        redvox_id: string, redvox id of all the packets
        uuid: string, uuid of all the packets
        start_mach_timestamp: float, app_start_mach_timestamp of all the packets
        audio_sample_rate: float, sample rate of the audio sensor
    &#34;&#34;&#34;
    def __init__(self, wrapped_packets: List[api_m_wp.WrappedRedvoxPacketM]):
        &#34;&#34;&#34;
        initialize ReadWrappedPackets
        :param wrapped_packets: the packets to add; must be continuous
        &#34;&#34;&#34;
        # set the values used to check continuity
        self.redvox_id: str = wrapped_packets[0].get_station_information().get_id()
        self.uuid: str = wrapped_packets[0].get_station_information().get_uuid()
        self.start_mach_timestamp: float = wrapped_packets[0].get_timing_information().get_app_start_mach_timestamp()
        self.audio_sample_rate: float = wrapped_packets[0].get_sensors().get_audio().get_sample_rate()
        # set the packets
        self.wrapped_packets: List[api_m_wp.WrappedRedvoxPacketM] = wrapped_packets
        if len(wrapped_packets) &gt; 1:
            self.wrapped_packets = self.sort_packets()

    @staticmethod
    def _default_sort_packets(packet: api_m_wp.WrappedRedvoxPacketM):
        return packet.get_timing_information().get_packet_start_mach_timestamp()

    # this is for below to allow custom criteria to sort on
    T = TypeVar(&#34;T&#34;)

    def sort_packets(self, sort_func: Optional[Callable[[api_m_wp.WrappedRedvoxPacketM], T]] = None,
                     reverse: bool = False) -&gt; List[api_m_wp.WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        sort packets by custom user function, or by default, packet_start_timestamp
        :param sort_func: Optional function defining how to sort the packets, default None (uses packet start mach time)
        :param reverse: bool, if True, sort results in reverse, default False
        :return: the sorted list of packets
        &#34;&#34;&#34;
        if sort_func is None:
            sort_func = self._default_sort_packets
        return sorted(self.wrapped_packets, key=sort_func, reverse=reverse)

    def add_packet(self, wrapped_packet: api_m_wp.WrappedRedvoxPacketM) -&gt; bool:
        &#34;&#34;&#34;
        Adds the wrapped packet to the list if it is from the same device
        :param wrapped_packet: packet to potentially add to list
        :return: True if successful, False otherwise
        &#34;&#34;&#34;
        if wrapped_packet.get_station_information().get_id() == self.redvox_id \
                and wrapped_packet.get_station_information().get_uuid() == self.uuid \
                and wrapped_packet.get_timing_information().get_app_start_mach_timestamp() == self.start_mach_timestamp\
                and self.validate_sensors(wrapped_packet):
            self.wrapped_packets.append(wrapped_packet)
            self.wrapped_packets = self.sort_packets()
            return True
        return False

    def validate_sensors(self, wrapped_packet: api_m_wp.WrappedRedvoxPacketM) -&gt; bool:
        &#34;&#34;&#34;
        Checks for difference between sensors of the wrapped_packet and the ReadWrappedPacket
        :param wrapped_packet: packet to check for differences
        :return: True if no change in any sensors, False otherwise
        &#34;&#34;&#34;
        # only 1 packet means sensors don&#39;t change
        if len(self.wrapped_packets) &lt;= 1:
            return True
        prev_sensors = [wrapped_packet.get_sensors().has_audio(),
                        wrapped_packet.get_sensors().has_pressure(),
                        wrapped_packet.get_sensors().has_accelerometer(),
                        wrapped_packet.get_sensors().has_gyroscope(),
                        wrapped_packet.get_sensors().has_light(),
                        wrapped_packet.get_sensors().has_image(),
                        wrapped_packet.get_sensors().has_location(),
                        wrapped_packet.get_sensors().has_magnetometer(),
                        wrapped_packet.get_sensors().has_ambient_temperature(),
                        wrapped_packet.get_sensors().has_compress_audio(),
                        wrapped_packet.get_sensors().has_gravity(),
                        wrapped_packet.get_sensors().has_linear_acceleration(),
                        wrapped_packet.get_sensors().has_orientation(),
                        wrapped_packet.get_sensors().has_proximity(),
                        wrapped_packet.get_sensors().has_relative_humidity(),
                        wrapped_packet.get_sensors().has_rotation_vector()]
        for packet in self.wrapped_packets:
            next_sensors = [packet.get_sensors().has_audio(),
                            packet.get_sensors().has_pressure(),
                            packet.get_sensors().has_accelerometer(),
                            packet.get_sensors().has_gyroscope(),
                            packet.get_sensors().has_light(),
                            packet.get_sensors().has_image(),
                            packet.get_sensors().has_location(),
                            packet.get_sensors().has_magnetometer(),
                            packet.get_sensors().has_ambient_temperature(),
                            packet.get_sensors().has_compress_audio(),
                            packet.get_sensors().has_gravity(),
                            packet.get_sensors().has_linear_acceleration(),
                            packet.get_sensors().has_orientation(),
                            packet.get_sensors().has_proximity(),
                            packet.get_sensors().has_relative_humidity(),
                            packet.get_sensors().has_rotation_vector()]
            if prev_sensors != next_sensors:
                return False
        # if here, all sensors match
        return True

    def identify_gaps(self, allowed_timing_error_s: float, debug: bool = False) -&gt; List[int]:
        &#34;&#34;&#34;
        Identifies discontinuities in sensor data by checking if sensors drop in and out and by comparing timing info.
        :param allowed_timing_error_s: float, the amount of timing error in seconds.
        :param debug: bool, if True, output information as function is running, default False
        :return: A list of indices into the original list where gaps were found.
        &#34;&#34;&#34;
        if len(self.wrapped_packets) &lt;= 1:
            return []

        gaps = set()

        for i in range(1, len(self.wrapped_packets)):
            prev_packet = self.wrapped_packets[i - 1]
            next_packet = self.wrapped_packets[i]

            prev_timestamp = prev_packet.get_timing_information().get_packet_end_mach_timestamp()
            next_timestamp = next_packet.get_timing_information().get_packet_start_mach_timestamp()
            if debug:
                print(next_timestamp - prev_timestamp)
            # timestamps of audio data should be close together
            if date_time_utils.microseconds_to_seconds(next_timestamp - prev_timestamp) &gt; allowed_timing_error_s:
                gaps.add(i)
                if debug:
                    print(&#34;time gap&#34;)

        return sorted(list(gaps))


class ReadResult:
    &#34;&#34;&#34;
    Results from reading a directory containing API M redvox data
    properties:
        start_timestamp: optional float, start timestamp in microseconds of the data being read
        end_timestamp: optional float, end timestamp in microseconds of the data being read
        all_wrapped_packets: list of lists of wrapped API M redvox packets
    &#34;&#34;&#34;
    def __init__(self, start_time: Optional[float] = None, end_time: Optional[float] = None,
                 wrapped_packets: Optional[List[ReadWrappedPackets]] = None):
        &#34;&#34;&#34;
        initialize a ReadResult
        :param start_time: start time of the data being read, default None
        :param end_time: end time of the data being read, default None
        :param wrapped_packets: list of lists of wrapped API M packets containing all the data, default None
        &#34;&#34;&#34;
        self.start_timestamp: Optional[float] = start_time
        self.end_timestamp: Optional[float] = end_time
        if wrapped_packets is None:
            self.all_wrapped_packets = []
        else:
            self.all_wrapped_packets = wrapped_packets

    def add_result(self, wrapped_packets: ReadWrappedPackets):
        &#34;&#34;&#34;
        adds a ReadWrappedPackets object to the ReadResult
        :param wrapped_packets: a ReadWrappedPackets object
        &#34;&#34;&#34;
        self.all_wrapped_packets.append(wrapped_packets)

    def add_packet(self, wrapped_packet: api_m_wp.WrappedRedvoxPacketM):
        &#34;&#34;&#34;
        adds a single wrapped API M redvox packet to the ensemble
        :param wrapped_packet: a single wrapped API M redvox packet
        &#34;&#34;&#34;
        for packets in self.all_wrapped_packets:
            if packets.add_packet(wrapped_packet):
                # packet got added, stop function
                return
        # went through for loop and nothing got added, so we assume it&#39;s a new id to add
        self.all_wrapped_packets.append(ReadWrappedPackets([wrapped_packet]))

    def add_list_of_packets(self, wrapped_packets: List[api_m_wp.WrappedRedvoxPacketM]):
        &#34;&#34;&#34;
        adds a list of WrappedRedvoxPacketM files to the ReadResult
        :param wrapped_packets: the list of wrapped API M redvox packets to add
        &#34;&#34;&#34;
        for packet in wrapped_packets:
            self.add_packet(packet)
        end_result = self.reorganize_packets()
        self.all_wrapped_packets = end_result.all_wrapped_packets

    def identify_gaps(self, timing_gap_s: float = 5.0) -&gt; &#39;ReadResult&#39;:
        &#34;&#34;&#34;
        checks all_wrapped_packets for any time gaps and splits them into continuous objects
        returns a copy of the calling object if no gaps detected
        :param timing_gap_s: amount of seconds allowed between packets to be considered a gap
        :return: an updated ReadResult object
        &#34;&#34;&#34;
        updated_result = ReadResult(self.start_timestamp, self.end_timestamp)
        for packets in self.all_wrapped_packets:
            gaps = packets.identify_gaps(timing_gap_s)
            start = 0
            for index in gaps:
                split_val = ReadWrappedPackets(packets.wrapped_packets[start:index])
                updated_result.all_wrapped_packets.append(split_val)
                start = index
            # do this one last time to get the rest of the data that wasn&#39;t split yet
            split_val = ReadWrappedPackets(packets.wrapped_packets[start:])
            updated_result.all_wrapped_packets.append(split_val)
        return updated_result

    def reorganize_packets(self, timing_gap_s: float = 5.0) -&gt; &#39;ReadResult&#39;:
        &#34;&#34;&#34;
        takes all_wrapped_packets and recreates the ReadResult object
        :param timing_gap_s: amount of seconds allowed between packets to be considered a gap
        :return: an updated ReadResult object
        &#34;&#34;&#34;
        updated_result = ReadResult(self.start_timestamp, self.end_timestamp)
        for packets in self.all_wrapped_packets:
            for packet in packets.wrapped_packets:
                updated_result.add_packet(packet)
        return updated_result.identify_gaps(timing_gap_s)

    def get_by_id(self, redvox_id: str) -&gt; List[api_m_wp.WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        gets all the packets with the id specified
        :param redvox_id: the redvox id to return values for
        :return: list of API M redvox packets with the redvox_id specified
        &#34;&#34;&#34;
        results: List[api_m_wp.WrappedRedvoxPacketM] = []
        for packets in self.all_wrapped_packets:
            if packets.redvox_id == redvox_id:
                results.extend(packets.wrapped_packets)
        return results


class StreamResult:
    pass


def wrap(redvox_packet: api_m_wp.RedvoxPacketM) -&gt; api_m_wp.WrappedRedvoxPacketM:
    &#34;&#34;&#34;
    Wraps a protobuf packet in a WrappedRedocPacket.
    :param redvox_packet: Protobuf packet to wrap.
    :return: A WrappedRedvoxPacket.
    &#34;&#34;&#34;
    return api_m_wp.WrappedRedvoxPacketM(redvox_packet)


def read_buffer(buf: bytes, is_compressed: bool = True) -&gt; api_m_wp.RedvoxPacketM:
    &#34;&#34;&#34;
    Deserializes a serialized protobuf RedvoxPacket buffer.
    :param buf: Buffer to deserialize.
    :param is_compressed: Whether or not the buffer is compressed or decompressed.
    :return: Deserialized protobuf redvox packet.
    &#34;&#34;&#34;
    buffer = redvox.api1000.common.lz4.decompress(buf) if is_compressed else buf
    redvox_packet = api_m_wp.RedvoxPacketM()
    redvox_packet.ParseFromString(buffer)
    return redvox_packet


def read_file(file: str, is_compressed: bool = None) -&gt; api_m_wp.RedvoxPacketM:
    &#34;&#34;&#34;
    Deserializes a serialized protobuf RedvoxPacketM file.
    :param file: File to deserialize.
    :param is_compressed: Whether or not the file is compressed or decompressed.
    :return: Deserialized protobuf API M redvox packet.
    &#34;&#34;&#34;
    file_ext = file.split(&#34;.&#34;)[-1]

    if is_compressed is None:
        _is_compressed = True if file_ext == REDVOX_API_M_FILE_EXT else False
    else:
        _is_compressed = is_compressed
    with open(file, &#34;rb&#34;) as fin:
        return read_buffer(fin.read(), _is_compressed)


def read_rdvxm_file(path: str) -&gt; api_m_wp.WrappedRedvoxPacketM:
    &#34;&#34;&#34;
    Reads a .rdvxm file from the specified path and returns a WrappedRedvoxPacketM.
    :param path: The path of the file.
    :return: A WrappedRedvoxPacketM.
    &#34;&#34;&#34;
    return wrap(read_file(path))


def read_rdvxm_buffer(buf: bytes) -&gt; api_m_wp.WrappedRedvoxPacketM:
    &#34;&#34;&#34;
    reads a .rdvxm file from the provided buffer and returns a WrappedRedvoxPacketM
    :param buf: buffer of bytes to read
    :return: A WrappedRedvoxPacketM
    &#34;&#34;&#34;
    return wrap(read_buffer(buf))


def _extract_timestamp(path: str) -&gt; int:
    &#34;&#34;&#34;
    Extracts a timestamp in microseconds from a file path.
    :param path: Path to extract a timestamp from.
    :return: The timestamp in seconds from a path.
    &#34;&#34;&#34;
    file = path.split(os.path.sep)[-1].split(&#34;.&#34;)[0]
    return int(date_time_utils.microseconds_to_seconds(int(file.split(&#34;_&#34;)[1])))


def _extract_redvox_id(path: str) -&gt; str:
    &#34;&#34;&#34;
    Extracts a redvox id from a file path.
    :param path: A path to extract the id from.
    :return: The redvox id.
    &#34;&#34;&#34;
    file = path.split(os.path.sep)[-1]
    return file.split(&#34;_&#34;)[0]


def _is_int(int_as_str: str) -&gt; bool:
    &#34;&#34;&#34;
    Returns true if the given string can be parsed as an int.
    :param int_as_str: String to test.
    :return: True if it is an int, False otherwise.
    &#34;&#34;&#34;
    try:
        int(int_as_str)
        return True
    except ValueError:
        return False


def _is_valid_redvox_api_m_filename(filename: str) -&gt; bool:
    &#34;&#34;&#34;
    Given a filename, determine if the filename is a valid API M redvox file name.
    :param filename: Filename to test.
    :return: True if it is valid, false otherwise.
    &#34;&#34;&#34;
    return len(filename) == 33 and _is_int(filename[0:10]) \
        and filename[10:11] == &#34;_&#34; and _is_int(filename[11:27]) \
        and filename[27:len(filename)] == f&#34;.{REDVOX_API_M_FILE_EXT}&#34;


def _is_path_in_set(path: str,
                    start_timestamp_utc_s: int,
                    end_timestamp_utc_s: int,
                    redvox_ids: Set[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Determines whether a given path is in a provided time range and set of redvox_ids.
    :param path: The path to check.
    :param start_timestamp_utc_s: Start of time range in seconds since epoch UTC.
    :param end_timestamp_utc_s: End of time range in seconds since epoch UTC.
    :param redvox_ids: Optional set of redvox ids.
    :return: True if path is in set false otherwise.
    &#34;&#34;&#34;
    if redvox_ids is None:
        redvox_ids = set()
    filename = path.split(os.sep)[-1]

    if not _is_valid_redvox_api_m_filename(filename):
        return False

    timestamp = int(date_time_utils.microseconds_to_seconds(float(filename[11:27])))

    if not start_timestamp_utc_s &lt;= timestamp &lt;= end_timestamp_utc_s:
        return False

    if len(redvox_ids) &gt; 0:
        if len(redvox_ids) &gt; 0:
            redvox_id = filename[0:10]
            if redvox_id not in redvox_ids:
                return False

    return True


def _get_time_range_paths(paths: List[str],
                          redvox_ids: Optional[Set[str]]) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    Given a set of paths, get the start and end timestamps.
    :param paths: Paths to get time range from.
    :param redvox_ids: Redvox ids to filter on.
    :return: A tuple containing the start and end timestamps of the data range.
    &#34;&#34;&#34;
    if redvox_ids is not None:
        paths = list(filter(lambda path: _extract_redvox_id(path) in redvox_ids, paths))

    if len(paths) == 0:
        return -1, -1

    if len(paths) == 1:
        timestamp = _extract_timestamp(paths[0])
        return timestamp, timestamp

    timestamps = sorted(list(map(_extract_timestamp, paths)))
    return timestamps[0], timestamps[-1]


def _get_paths_time_range(directory: str,
                          redvox_ids: Optional[Set[str]],
                          recursive: bool) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    Gets the start and end time range of a given set of API M data.
    :param directory: The base directory of the data.
    :param redvox_ids: Redvox ids to filter on.
    :param recursive: Whether or not to perform a recursive search.
    :return: A tuple containing the start and end timestamps of the given data set.
    &#34;&#34;&#34;
    if recursive:
        all_paths = glob.glob(os.path.join(directory, &#34;**&#34;, f&#34;*.{REDVOX_API_M_FILE_EXT}&#34;),
                              recursive=recursive)
    else:
        all_paths = glob.glob(os.path.join(directory, f&#34;*.{REDVOX_API_M_FILE_EXT}&#34;),
                              recursive=recursive)

    return _get_time_range_paths(all_paths, redvox_ids)


def _get_structured_paths(directory: str,
                          start_timestamp_utc_s: int,
                          end_timestamp_utc_s: int,
                          redvox_ids: Set[str] = None) -&gt; List[str]:
    &#34;&#34;&#34;
    Given a base directory (which should end with api1000), find the paths of all structured API M redvox files.
    :param directory: The base directory path (which should end with api1000)
    :param start_timestamp_utc_s: Start timestamp as seconds since the epoch UTC.
    :param end_timestamp_utc_s: End timestamp as seconds since the epoch UTC.
    :param redvox_ids: An optional set of redvox_ids to filter against.
    :return: A list of paths in a structured layout of filtered API M redvox files.
    &#34;&#34;&#34;
    if redvox_ids is None:
        redvox_ids = set()
    paths = []
    for (year, month, day, hour) in date_time_utils.DateIteratorAPIM(start_timestamp_utc_s, end_timestamp_utc_s):
        all_paths = glob.glob(os.path.join(directory, year, month, day, hour, f&#34;*.{REDVOX_API_M_FILE_EXT}&#34;))
        valid_paths = list(
            filter(lambda path: _is_path_in_set(path, start_timestamp_utc_s, end_timestamp_utc_s, redvox_ids),
                   all_paths))
        paths.extend(valid_paths)
    return paths


def read_structured(directory: str,
                    start_timestamp_utc_s: Optional[int] = None,
                    end_timestamp_utc_s: Optional[int] = None,
                    redvox_ids: Optional[List[str]] = None,
                    structured_layout: bool = True) -&gt; ReadResult:
    &#34;&#34;&#34;
    read API M data from a directory that contains a specific structure (directory/YYYY/MM/DD/HH)
    Timestamps in directory are in microseconds since epoch UTC
    :param directory: the root directory that contains the data
    :param start_timestamp_utc_s: starting timestamp in seconds since epoch UTC.  if None, get all data, default None
    :param end_timestamp_utc_s: ending timestamp in seconds since epoch UTC.  if None, get all data, default None
    :param redvox_ids: specific redvox ids to get data for.  if None, get all ids, default None
    :param structured_layout: specifies if directory has specific structure, default True
    :return: a ReadResult object that stores the packets with metadata
    &#34;&#34;&#34;
    # Remove trailing directory separators
    if redvox_ids is None:
        redvox_ids = []
    while directory.endswith(&#34;/&#34;) or directory.endswith(&#34;\\&#34;):
        directory = directory[:-1]

    if start_timestamp_utc_s is None or end_timestamp_utc_s is None:
        ids = None if len(redvox_ids) == 0 else redvox_ids
        start_adjusted, end_adjusted = _get_paths_time_range(directory, ids, structured_layout)

        if start_timestamp_utc_s is None:
            start_timestamp_utc_s = start_adjusted

        if end_timestamp_utc_s is None:
            end_timestamp_utc_s = end_adjusted

    if structured_layout:
        paths = _get_structured_paths(directory,
                                      start_timestamp_utc_s,
                                      end_timestamp_utc_s,
                                      set(redvox_ids))
    else:
        all_paths = glob.glob(os.path.join(directory, f&#34;*.{REDVOX_API_M_FILE_EXT}&#34;))
        paths = list(
            filter(lambda pth: _is_path_in_set(pth, start_timestamp_utc_s, end_timestamp_utc_s, set(redvox_ids)),
                   all_paths))

    read_result = ReadResult(start_timestamp_utc_s, end_timestamp_utc_s)

    for path in paths:
        read_result.add_packet(read_rdvxm_file(path))

    return read_result


def read_dir(directory_path: str) -&gt; ReadResult:
    &#34;&#34;&#34;
    read API M data from a single directory of unsorted API M redvox data
    :param directory_path: the directory path that contains all the data
    :return: the data as a ReadResult
    &#34;&#34;&#34;
    # Make sure the directory ends with a trailing slash &#34;/&#34;
    if directory_path[-1] != &#34;/&#34;:
        directory_path = directory_path + &#34;/&#34;

    read_result = ReadResult()

    file_paths = sorted(glob.glob(directory_path + f&#34;*.{REDVOX_API_M_FILE_EXT}&#34;))

    for path in file_paths:
        read_result.add_packet(read_rdvxm_file(path))

    return read_result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.api1000.io.calc_evenly_sampled_timestamps"><code class="name flex">
<span>def <span class="ident">calc_evenly_sampled_timestamps</span></span>(<span>start: float, samples: int, rate_hz: float) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>given a start time, calculates samples amount of evenly spaced timestamps at rate_hz
:param start: float, start timestamp
:param samples: int, number of samples
:param rate_hz: float, sample rate in hz
:return: np.array with evenly spaced timestamps starting at start</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_evenly_sampled_timestamps(start: float, samples: int, rate_hz: float) -&gt; np.array:
    &#34;&#34;&#34;
    given a start time, calculates samples amount of evenly spaced timestamps at rate_hz
    :param start: float, start timestamp
    :param samples: int, number of samples
    :param rate_hz: float, sample rate in hz
    :return: np.array with evenly spaced timestamps starting at start
    &#34;&#34;&#34;
    return np.array(start + date_time_utils.seconds_to_microseconds(np.arange(0, samples) / rate_hz))</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.read_buffer"><code class="name flex">
<span>def <span class="ident">read_buffer</span></span>(<span>buf: bytes, is_compressed: bool = True) ‑> src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM</span>
</code></dt>
<dd>
<div class="desc"><p>Deserializes a serialized protobuf RedvoxPacket buffer.
:param buf: Buffer to deserialize.
:param is_compressed: Whether or not the buffer is compressed or decompressed.
:return: Deserialized protobuf redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_buffer(buf: bytes, is_compressed: bool = True) -&gt; api_m_wp.RedvoxPacketM:
    &#34;&#34;&#34;
    Deserializes a serialized protobuf RedvoxPacket buffer.
    :param buf: Buffer to deserialize.
    :param is_compressed: Whether or not the buffer is compressed or decompressed.
    :return: Deserialized protobuf redvox packet.
    &#34;&#34;&#34;
    buffer = redvox.api1000.common.lz4.decompress(buf) if is_compressed else buf
    redvox_packet = api_m_wp.RedvoxPacketM()
    redvox_packet.ParseFromString(buffer)
    return redvox_packet</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.read_dir"><code class="name flex">
<span>def <span class="ident">read_dir</span></span>(<span>directory_path: str) ‑> <a title="redvox.api1000.io.ReadResult" href="#redvox.api1000.io.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>read API M data from a single directory of unsorted API M redvox data
:param directory_path: the directory path that contains all the data
:return: the data as a ReadResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_dir(directory_path: str) -&gt; ReadResult:
    &#34;&#34;&#34;
    read API M data from a single directory of unsorted API M redvox data
    :param directory_path: the directory path that contains all the data
    :return: the data as a ReadResult
    &#34;&#34;&#34;
    # Make sure the directory ends with a trailing slash &#34;/&#34;
    if directory_path[-1] != &#34;/&#34;:
        directory_path = directory_path + &#34;/&#34;

    read_result = ReadResult()

    file_paths = sorted(glob.glob(directory_path + f&#34;*.{REDVOX_API_M_FILE_EXT}&#34;))

    for path in file_paths:
        read_result.add_packet(read_rdvxm_file(path))

    return read_result</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.read_file"><code class="name flex">
<span>def <span class="ident">read_file</span></span>(<span>file: str, is_compressed: bool = None) ‑> src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM</span>
</code></dt>
<dd>
<div class="desc"><p>Deserializes a serialized protobuf RedvoxPacketM file.
:param file: File to deserialize.
:param is_compressed: Whether or not the file is compressed or decompressed.
:return: Deserialized protobuf API M redvox packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_file(file: str, is_compressed: bool = None) -&gt; api_m_wp.RedvoxPacketM:
    &#34;&#34;&#34;
    Deserializes a serialized protobuf RedvoxPacketM file.
    :param file: File to deserialize.
    :param is_compressed: Whether or not the file is compressed or decompressed.
    :return: Deserialized protobuf API M redvox packet.
    &#34;&#34;&#34;
    file_ext = file.split(&#34;.&#34;)[-1]

    if is_compressed is None:
        _is_compressed = True if file_ext == REDVOX_API_M_FILE_EXT else False
    else:
        _is_compressed = is_compressed
    with open(file, &#34;rb&#34;) as fin:
        return read_buffer(fin.read(), _is_compressed)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.read_rdvxm_buffer"><code class="name flex">
<span>def <span class="ident">read_rdvxm_buffer</span></span>(<span>buf: bytes) ‑> <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a></span>
</code></dt>
<dd>
<div class="desc"><p>reads a .rdvxm file from the provided buffer and returns a WrappedRedvoxPacketM
:param buf: buffer of bytes to read
:return: A WrappedRedvoxPacketM</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_rdvxm_buffer(buf: bytes) -&gt; api_m_wp.WrappedRedvoxPacketM:
    &#34;&#34;&#34;
    reads a .rdvxm file from the provided buffer and returns a WrappedRedvoxPacketM
    :param buf: buffer of bytes to read
    :return: A WrappedRedvoxPacketM
    &#34;&#34;&#34;
    return wrap(read_buffer(buf))</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.read_rdvxm_file"><code class="name flex">
<span>def <span class="ident">read_rdvxm_file</span></span>(<span>path: str) ‑> <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a></span>
</code></dt>
<dd>
<div class="desc"><p>Reads a .rdvxm file from the specified path and returns a WrappedRedvoxPacketM.
:param path: The path of the file.
:return: A WrappedRedvoxPacketM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_rdvxm_file(path: str) -&gt; api_m_wp.WrappedRedvoxPacketM:
    &#34;&#34;&#34;
    Reads a .rdvxm file from the specified path and returns a WrappedRedvoxPacketM.
    :param path: The path of the file.
    :return: A WrappedRedvoxPacketM.
    &#34;&#34;&#34;
    return wrap(read_file(path))</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.read_structured"><code class="name flex">
<span>def <span class="ident">read_structured</span></span>(<span>directory: str, start_timestamp_utc_s: typing.Optional[int] = None, end_timestamp_utc_s: typing.Optional[int] = None, redvox_ids: typing.Optional[typing.List[str]] = None, structured_layout: bool = True) ‑> <a title="redvox.api1000.io.ReadResult" href="#redvox.api1000.io.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>read API M data from a directory that contains a specific structure (directory/YYYY/MM/DD/HH)
Timestamps in directory are in microseconds since epoch UTC
:param directory: the root directory that contains the data
:param start_timestamp_utc_s: starting timestamp in seconds since epoch UTC.
if None, get all data, default None
:param end_timestamp_utc_s: ending timestamp in seconds since epoch UTC.
if None, get all data, default None
:param redvox_ids: specific redvox ids to get data for.
if None, get all ids, default None
:param structured_layout: specifies if directory has specific structure, default True
:return: a ReadResult object that stores the packets with metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_structured(directory: str,
                    start_timestamp_utc_s: Optional[int] = None,
                    end_timestamp_utc_s: Optional[int] = None,
                    redvox_ids: Optional[List[str]] = None,
                    structured_layout: bool = True) -&gt; ReadResult:
    &#34;&#34;&#34;
    read API M data from a directory that contains a specific structure (directory/YYYY/MM/DD/HH)
    Timestamps in directory are in microseconds since epoch UTC
    :param directory: the root directory that contains the data
    :param start_timestamp_utc_s: starting timestamp in seconds since epoch UTC.  if None, get all data, default None
    :param end_timestamp_utc_s: ending timestamp in seconds since epoch UTC.  if None, get all data, default None
    :param redvox_ids: specific redvox ids to get data for.  if None, get all ids, default None
    :param structured_layout: specifies if directory has specific structure, default True
    :return: a ReadResult object that stores the packets with metadata
    &#34;&#34;&#34;
    # Remove trailing directory separators
    if redvox_ids is None:
        redvox_ids = []
    while directory.endswith(&#34;/&#34;) or directory.endswith(&#34;\\&#34;):
        directory = directory[:-1]

    if start_timestamp_utc_s is None or end_timestamp_utc_s is None:
        ids = None if len(redvox_ids) == 0 else redvox_ids
        start_adjusted, end_adjusted = _get_paths_time_range(directory, ids, structured_layout)

        if start_timestamp_utc_s is None:
            start_timestamp_utc_s = start_adjusted

        if end_timestamp_utc_s is None:
            end_timestamp_utc_s = end_adjusted

    if structured_layout:
        paths = _get_structured_paths(directory,
                                      start_timestamp_utc_s,
                                      end_timestamp_utc_s,
                                      set(redvox_ids))
    else:
        all_paths = glob.glob(os.path.join(directory, f&#34;*.{REDVOX_API_M_FILE_EXT}&#34;))
        paths = list(
            filter(lambda pth: _is_path_in_set(pth, start_timestamp_utc_s, end_timestamp_utc_s, set(redvox_ids)),
                   all_paths))

    read_result = ReadResult(start_timestamp_utc_s, end_timestamp_utc_s)

    for path in paths:
        read_result.add_packet(read_rdvxm_file(path))

    return read_result</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>redvox_packet: src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM) ‑> <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a></span>
</code></dt>
<dd>
<div class="desc"><p>Wraps a protobuf packet in a WrappedRedocPacket.
:param redvox_packet: Protobuf packet to wrap.
:return: A WrappedRedvoxPacket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(redvox_packet: api_m_wp.RedvoxPacketM) -&gt; api_m_wp.WrappedRedvoxPacketM:
    &#34;&#34;&#34;
    Wraps a protobuf packet in a WrappedRedocPacket.
    :param redvox_packet: Protobuf packet to wrap.
    :return: A WrappedRedvoxPacket.
    &#34;&#34;&#34;
    return api_m_wp.WrappedRedvoxPacketM(redvox_packet)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.api1000.io.ReadResult"><code class="flex name class">
<span>class <span class="ident">ReadResult</span></span>
<span>(</span><span>start_time: typing.Optional[float] = None, end_time: typing.Optional[float] = None, wrapped_packets: typing.Optional[typing.List[<a title="redvox.api1000.io.ReadWrappedPackets" href="#redvox.api1000.io.ReadWrappedPackets">ReadWrappedPackets</a>]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Results from reading a directory containing API M redvox data
properties:
start_timestamp: optional float, start timestamp in microseconds of the data being read
end_timestamp: optional float, end timestamp in microseconds of the data being read
all_wrapped_packets: list of lists of wrapped API M redvox packets</p>
<p>initialize a ReadResult
:param start_time: start time of the data being read, default None
:param end_time: end time of the data being read, default None
:param wrapped_packets: list of lists of wrapped API M packets containing all the data, default None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadResult:
    &#34;&#34;&#34;
    Results from reading a directory containing API M redvox data
    properties:
        start_timestamp: optional float, start timestamp in microseconds of the data being read
        end_timestamp: optional float, end timestamp in microseconds of the data being read
        all_wrapped_packets: list of lists of wrapped API M redvox packets
    &#34;&#34;&#34;
    def __init__(self, start_time: Optional[float] = None, end_time: Optional[float] = None,
                 wrapped_packets: Optional[List[ReadWrappedPackets]] = None):
        &#34;&#34;&#34;
        initialize a ReadResult
        :param start_time: start time of the data being read, default None
        :param end_time: end time of the data being read, default None
        :param wrapped_packets: list of lists of wrapped API M packets containing all the data, default None
        &#34;&#34;&#34;
        self.start_timestamp: Optional[float] = start_time
        self.end_timestamp: Optional[float] = end_time
        if wrapped_packets is None:
            self.all_wrapped_packets = []
        else:
            self.all_wrapped_packets = wrapped_packets

    def add_result(self, wrapped_packets: ReadWrappedPackets):
        &#34;&#34;&#34;
        adds a ReadWrappedPackets object to the ReadResult
        :param wrapped_packets: a ReadWrappedPackets object
        &#34;&#34;&#34;
        self.all_wrapped_packets.append(wrapped_packets)

    def add_packet(self, wrapped_packet: api_m_wp.WrappedRedvoxPacketM):
        &#34;&#34;&#34;
        adds a single wrapped API M redvox packet to the ensemble
        :param wrapped_packet: a single wrapped API M redvox packet
        &#34;&#34;&#34;
        for packets in self.all_wrapped_packets:
            if packets.add_packet(wrapped_packet):
                # packet got added, stop function
                return
        # went through for loop and nothing got added, so we assume it&#39;s a new id to add
        self.all_wrapped_packets.append(ReadWrappedPackets([wrapped_packet]))

    def add_list_of_packets(self, wrapped_packets: List[api_m_wp.WrappedRedvoxPacketM]):
        &#34;&#34;&#34;
        adds a list of WrappedRedvoxPacketM files to the ReadResult
        :param wrapped_packets: the list of wrapped API M redvox packets to add
        &#34;&#34;&#34;
        for packet in wrapped_packets:
            self.add_packet(packet)
        end_result = self.reorganize_packets()
        self.all_wrapped_packets = end_result.all_wrapped_packets

    def identify_gaps(self, timing_gap_s: float = 5.0) -&gt; &#39;ReadResult&#39;:
        &#34;&#34;&#34;
        checks all_wrapped_packets for any time gaps and splits them into continuous objects
        returns a copy of the calling object if no gaps detected
        :param timing_gap_s: amount of seconds allowed between packets to be considered a gap
        :return: an updated ReadResult object
        &#34;&#34;&#34;
        updated_result = ReadResult(self.start_timestamp, self.end_timestamp)
        for packets in self.all_wrapped_packets:
            gaps = packets.identify_gaps(timing_gap_s)
            start = 0
            for index in gaps:
                split_val = ReadWrappedPackets(packets.wrapped_packets[start:index])
                updated_result.all_wrapped_packets.append(split_val)
                start = index
            # do this one last time to get the rest of the data that wasn&#39;t split yet
            split_val = ReadWrappedPackets(packets.wrapped_packets[start:])
            updated_result.all_wrapped_packets.append(split_val)
        return updated_result

    def reorganize_packets(self, timing_gap_s: float = 5.0) -&gt; &#39;ReadResult&#39;:
        &#34;&#34;&#34;
        takes all_wrapped_packets and recreates the ReadResult object
        :param timing_gap_s: amount of seconds allowed between packets to be considered a gap
        :return: an updated ReadResult object
        &#34;&#34;&#34;
        updated_result = ReadResult(self.start_timestamp, self.end_timestamp)
        for packets in self.all_wrapped_packets:
            for packet in packets.wrapped_packets:
                updated_result.add_packet(packet)
        return updated_result.identify_gaps(timing_gap_s)

    def get_by_id(self, redvox_id: str) -&gt; List[api_m_wp.WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        gets all the packets with the id specified
        :param redvox_id: the redvox id to return values for
        :return: list of API M redvox packets with the redvox_id specified
        &#34;&#34;&#34;
        results: List[api_m_wp.WrappedRedvoxPacketM] = []
        for packets in self.all_wrapped_packets:
            if packets.redvox_id == redvox_id:
                results.extend(packets.wrapped_packets)
        return results</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="redvox.api1000.io.ReadResult.add_list_of_packets"><code class="name flex">
<span>def <span class="ident">add_list_of_packets</span></span>(<span>self, wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>adds a list of WrappedRedvoxPacketM files to the ReadResult
:param wrapped_packets: the list of wrapped API M redvox packets to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_list_of_packets(self, wrapped_packets: List[api_m_wp.WrappedRedvoxPacketM]):
    &#34;&#34;&#34;
    adds a list of WrappedRedvoxPacketM files to the ReadResult
    :param wrapped_packets: the list of wrapped API M redvox packets to add
    &#34;&#34;&#34;
    for packet in wrapped_packets:
        self.add_packet(packet)
    end_result = self.reorganize_packets()
    self.all_wrapped_packets = end_result.all_wrapped_packets</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.ReadResult.add_packet"><code class="name flex">
<span>def <span class="ident">add_packet</span></span>(<span>self, wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a single wrapped API M redvox packet to the ensemble
:param wrapped_packet: a single wrapped API M redvox packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_packet(self, wrapped_packet: api_m_wp.WrappedRedvoxPacketM):
    &#34;&#34;&#34;
    adds a single wrapped API M redvox packet to the ensemble
    :param wrapped_packet: a single wrapped API M redvox packet
    &#34;&#34;&#34;
    for packets in self.all_wrapped_packets:
        if packets.add_packet(wrapped_packet):
            # packet got added, stop function
            return
    # went through for loop and nothing got added, so we assume it&#39;s a new id to add
    self.all_wrapped_packets.append(ReadWrappedPackets([wrapped_packet]))</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.ReadResult.add_result"><code class="name flex">
<span>def <span class="ident">add_result</span></span>(<span>self, wrapped_packets: <a title="redvox.api1000.io.ReadWrappedPackets" href="#redvox.api1000.io.ReadWrappedPackets">ReadWrappedPackets</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a ReadWrappedPackets object to the ReadResult
:param wrapped_packets: a ReadWrappedPackets object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_result(self, wrapped_packets: ReadWrappedPackets):
    &#34;&#34;&#34;
    adds a ReadWrappedPackets object to the ReadResult
    :param wrapped_packets: a ReadWrappedPackets object
    &#34;&#34;&#34;
    self.all_wrapped_packets.append(wrapped_packets)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.ReadResult.get_by_id"><code class="name flex">
<span>def <span class="ident">get_by_id</span></span>(<span>self, redvox_id: str) ‑> typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>gets all the packets with the id specified
:param redvox_id: the redvox id to return values for
:return: list of API M redvox packets with the redvox_id specified</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_id(self, redvox_id: str) -&gt; List[api_m_wp.WrappedRedvoxPacketM]:
    &#34;&#34;&#34;
    gets all the packets with the id specified
    :param redvox_id: the redvox id to return values for
    :return: list of API M redvox packets with the redvox_id specified
    &#34;&#34;&#34;
    results: List[api_m_wp.WrappedRedvoxPacketM] = []
    for packets in self.all_wrapped_packets:
        if packets.redvox_id == redvox_id:
            results.extend(packets.wrapped_packets)
    return results</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.ReadResult.identify_gaps"><code class="name flex">
<span>def <span class="ident">identify_gaps</span></span>(<span>self, timing_gap_s: float = 5.0) ‑> <a title="redvox.api1000.io.ReadResult" href="#redvox.api1000.io.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>checks all_wrapped_packets for any time gaps and splits them into continuous objects
returns a copy of the calling object if no gaps detected
:param timing_gap_s: amount of seconds allowed between packets to be considered a gap
:return: an updated ReadResult object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_gaps(self, timing_gap_s: float = 5.0) -&gt; &#39;ReadResult&#39;:
    &#34;&#34;&#34;
    checks all_wrapped_packets for any time gaps and splits them into continuous objects
    returns a copy of the calling object if no gaps detected
    :param timing_gap_s: amount of seconds allowed between packets to be considered a gap
    :return: an updated ReadResult object
    &#34;&#34;&#34;
    updated_result = ReadResult(self.start_timestamp, self.end_timestamp)
    for packets in self.all_wrapped_packets:
        gaps = packets.identify_gaps(timing_gap_s)
        start = 0
        for index in gaps:
            split_val = ReadWrappedPackets(packets.wrapped_packets[start:index])
            updated_result.all_wrapped_packets.append(split_val)
            start = index
        # do this one last time to get the rest of the data that wasn&#39;t split yet
        split_val = ReadWrappedPackets(packets.wrapped_packets[start:])
        updated_result.all_wrapped_packets.append(split_val)
    return updated_result</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.ReadResult.reorganize_packets"><code class="name flex">
<span>def <span class="ident">reorganize_packets</span></span>(<span>self, timing_gap_s: float = 5.0) ‑> <a title="redvox.api1000.io.ReadResult" href="#redvox.api1000.io.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>takes all_wrapped_packets and recreates the ReadResult object
:param timing_gap_s: amount of seconds allowed between packets to be considered a gap
:return: an updated ReadResult object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reorganize_packets(self, timing_gap_s: float = 5.0) -&gt; &#39;ReadResult&#39;:
    &#34;&#34;&#34;
    takes all_wrapped_packets and recreates the ReadResult object
    :param timing_gap_s: amount of seconds allowed between packets to be considered a gap
    :return: an updated ReadResult object
    &#34;&#34;&#34;
    updated_result = ReadResult(self.start_timestamp, self.end_timestamp)
    for packets in self.all_wrapped_packets:
        for packet in packets.wrapped_packets:
            updated_result.add_packet(packet)
    return updated_result.identify_gaps(timing_gap_s)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.api1000.io.ReadWrappedPackets"><code class="flex name class">
<span>class <span class="ident">ReadWrappedPackets</span></span>
<span>(</span><span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>A searchable/sortable list of continuous wrapped API M redvox packets
A set of API M packets are continuous if:
* their redvox ids are equal
* their uuids are equal
* their app start machine timestamps are equal
* their sample rate is constant
* their sensors do not change
* there is no considerable gap between the end of one packet and the start of the next
properties:
wrapped_packets: list of wrapped redvox API M packets
redvox_id: string, redvox id of all the packets
uuid: string, uuid of all the packets
start_mach_timestamp: float, app_start_mach_timestamp of all the packets
audio_sample_rate: float, sample rate of the audio sensor</p>
<p>initialize ReadWrappedPackets
:param wrapped_packets: the packets to add; must be continuous</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadWrappedPackets:
    &#34;&#34;&#34;
    A searchable/sortable list of continuous wrapped API M redvox packets
    A set of API M packets are continuous if:
        * their redvox ids are equal
        * their uuids are equal
        * their app start machine timestamps are equal
        * their sample rate is constant
        * their sensors do not change
        * there is no considerable gap between the end of one packet and the start of the next
    properties:
        wrapped_packets: list of wrapped redvox API M packets
        redvox_id: string, redvox id of all the packets
        uuid: string, uuid of all the packets
        start_mach_timestamp: float, app_start_mach_timestamp of all the packets
        audio_sample_rate: float, sample rate of the audio sensor
    &#34;&#34;&#34;
    def __init__(self, wrapped_packets: List[api_m_wp.WrappedRedvoxPacketM]):
        &#34;&#34;&#34;
        initialize ReadWrappedPackets
        :param wrapped_packets: the packets to add; must be continuous
        &#34;&#34;&#34;
        # set the values used to check continuity
        self.redvox_id: str = wrapped_packets[0].get_station_information().get_id()
        self.uuid: str = wrapped_packets[0].get_station_information().get_uuid()
        self.start_mach_timestamp: float = wrapped_packets[0].get_timing_information().get_app_start_mach_timestamp()
        self.audio_sample_rate: float = wrapped_packets[0].get_sensors().get_audio().get_sample_rate()
        # set the packets
        self.wrapped_packets: List[api_m_wp.WrappedRedvoxPacketM] = wrapped_packets
        if len(wrapped_packets) &gt; 1:
            self.wrapped_packets = self.sort_packets()

    @staticmethod
    def _default_sort_packets(packet: api_m_wp.WrappedRedvoxPacketM):
        return packet.get_timing_information().get_packet_start_mach_timestamp()

    # this is for below to allow custom criteria to sort on
    T = TypeVar(&#34;T&#34;)

    def sort_packets(self, sort_func: Optional[Callable[[api_m_wp.WrappedRedvoxPacketM], T]] = None,
                     reverse: bool = False) -&gt; List[api_m_wp.WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        sort packets by custom user function, or by default, packet_start_timestamp
        :param sort_func: Optional function defining how to sort the packets, default None (uses packet start mach time)
        :param reverse: bool, if True, sort results in reverse, default False
        :return: the sorted list of packets
        &#34;&#34;&#34;
        if sort_func is None:
            sort_func = self._default_sort_packets
        return sorted(self.wrapped_packets, key=sort_func, reverse=reverse)

    def add_packet(self, wrapped_packet: api_m_wp.WrappedRedvoxPacketM) -&gt; bool:
        &#34;&#34;&#34;
        Adds the wrapped packet to the list if it is from the same device
        :param wrapped_packet: packet to potentially add to list
        :return: True if successful, False otherwise
        &#34;&#34;&#34;
        if wrapped_packet.get_station_information().get_id() == self.redvox_id \
                and wrapped_packet.get_station_information().get_uuid() == self.uuid \
                and wrapped_packet.get_timing_information().get_app_start_mach_timestamp() == self.start_mach_timestamp\
                and self.validate_sensors(wrapped_packet):
            self.wrapped_packets.append(wrapped_packet)
            self.wrapped_packets = self.sort_packets()
            return True
        return False

    def validate_sensors(self, wrapped_packet: api_m_wp.WrappedRedvoxPacketM) -&gt; bool:
        &#34;&#34;&#34;
        Checks for difference between sensors of the wrapped_packet and the ReadWrappedPacket
        :param wrapped_packet: packet to check for differences
        :return: True if no change in any sensors, False otherwise
        &#34;&#34;&#34;
        # only 1 packet means sensors don&#39;t change
        if len(self.wrapped_packets) &lt;= 1:
            return True
        prev_sensors = [wrapped_packet.get_sensors().has_audio(),
                        wrapped_packet.get_sensors().has_pressure(),
                        wrapped_packet.get_sensors().has_accelerometer(),
                        wrapped_packet.get_sensors().has_gyroscope(),
                        wrapped_packet.get_sensors().has_light(),
                        wrapped_packet.get_sensors().has_image(),
                        wrapped_packet.get_sensors().has_location(),
                        wrapped_packet.get_sensors().has_magnetometer(),
                        wrapped_packet.get_sensors().has_ambient_temperature(),
                        wrapped_packet.get_sensors().has_compress_audio(),
                        wrapped_packet.get_sensors().has_gravity(),
                        wrapped_packet.get_sensors().has_linear_acceleration(),
                        wrapped_packet.get_sensors().has_orientation(),
                        wrapped_packet.get_sensors().has_proximity(),
                        wrapped_packet.get_sensors().has_relative_humidity(),
                        wrapped_packet.get_sensors().has_rotation_vector()]
        for packet in self.wrapped_packets:
            next_sensors = [packet.get_sensors().has_audio(),
                            packet.get_sensors().has_pressure(),
                            packet.get_sensors().has_accelerometer(),
                            packet.get_sensors().has_gyroscope(),
                            packet.get_sensors().has_light(),
                            packet.get_sensors().has_image(),
                            packet.get_sensors().has_location(),
                            packet.get_sensors().has_magnetometer(),
                            packet.get_sensors().has_ambient_temperature(),
                            packet.get_sensors().has_compress_audio(),
                            packet.get_sensors().has_gravity(),
                            packet.get_sensors().has_linear_acceleration(),
                            packet.get_sensors().has_orientation(),
                            packet.get_sensors().has_proximity(),
                            packet.get_sensors().has_relative_humidity(),
                            packet.get_sensors().has_rotation_vector()]
            if prev_sensors != next_sensors:
                return False
        # if here, all sensors match
        return True

    def identify_gaps(self, allowed_timing_error_s: float, debug: bool = False) -&gt; List[int]:
        &#34;&#34;&#34;
        Identifies discontinuities in sensor data by checking if sensors drop in and out and by comparing timing info.
        :param allowed_timing_error_s: float, the amount of timing error in seconds.
        :param debug: bool, if True, output information as function is running, default False
        :return: A list of indices into the original list where gaps were found.
        &#34;&#34;&#34;
        if len(self.wrapped_packets) &lt;= 1:
            return []

        gaps = set()

        for i in range(1, len(self.wrapped_packets)):
            prev_packet = self.wrapped_packets[i - 1]
            next_packet = self.wrapped_packets[i]

            prev_timestamp = prev_packet.get_timing_information().get_packet_end_mach_timestamp()
            next_timestamp = next_packet.get_timing_information().get_packet_start_mach_timestamp()
            if debug:
                print(next_timestamp - prev_timestamp)
            # timestamps of audio data should be close together
            if date_time_utils.microseconds_to_seconds(next_timestamp - prev_timestamp) &gt; allowed_timing_error_s:
                gaps.add(i)
                if debug:
                    print(&#34;time gap&#34;)

        return sorted(list(gaps))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.api1000.io.ReadWrappedPackets.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.api1000.io.ReadWrappedPackets.add_packet"><code class="name flex">
<span>def <span class="ident">add_packet</span></span>(<span>self, wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the wrapped packet to the list if it is from the same device
:param wrapped_packet: packet to potentially add to list
:return: True if successful, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_packet(self, wrapped_packet: api_m_wp.WrappedRedvoxPacketM) -&gt; bool:
    &#34;&#34;&#34;
    Adds the wrapped packet to the list if it is from the same device
    :param wrapped_packet: packet to potentially add to list
    :return: True if successful, False otherwise
    &#34;&#34;&#34;
    if wrapped_packet.get_station_information().get_id() == self.redvox_id \
            and wrapped_packet.get_station_information().get_uuid() == self.uuid \
            and wrapped_packet.get_timing_information().get_app_start_mach_timestamp() == self.start_mach_timestamp\
            and self.validate_sensors(wrapped_packet):
        self.wrapped_packets.append(wrapped_packet)
        self.wrapped_packets = self.sort_packets()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.ReadWrappedPackets.identify_gaps"><code class="name flex">
<span>def <span class="ident">identify_gaps</span></span>(<span>self, allowed_timing_error_s: float, debug: bool = False) ‑> typing.List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Identifies discontinuities in sensor data by checking if sensors drop in and out and by comparing timing info.
:param allowed_timing_error_s: float, the amount of timing error in seconds.
:param debug: bool, if True, output information as function is running, default False
:return: A list of indices into the original list where gaps were found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_gaps(self, allowed_timing_error_s: float, debug: bool = False) -&gt; List[int]:
    &#34;&#34;&#34;
    Identifies discontinuities in sensor data by checking if sensors drop in and out and by comparing timing info.
    :param allowed_timing_error_s: float, the amount of timing error in seconds.
    :param debug: bool, if True, output information as function is running, default False
    :return: A list of indices into the original list where gaps were found.
    &#34;&#34;&#34;
    if len(self.wrapped_packets) &lt;= 1:
        return []

    gaps = set()

    for i in range(1, len(self.wrapped_packets)):
        prev_packet = self.wrapped_packets[i - 1]
        next_packet = self.wrapped_packets[i]

        prev_timestamp = prev_packet.get_timing_information().get_packet_end_mach_timestamp()
        next_timestamp = next_packet.get_timing_information().get_packet_start_mach_timestamp()
        if debug:
            print(next_timestamp - prev_timestamp)
        # timestamps of audio data should be close together
        if date_time_utils.microseconds_to_seconds(next_timestamp - prev_timestamp) &gt; allowed_timing_error_s:
            gaps.add(i)
            if debug:
                print(&#34;time gap&#34;)

    return sorted(list(gaps))</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.ReadWrappedPackets.sort_packets"><code class="name flex">
<span>def <span class="ident">sort_packets</span></span>(<span>self, sort_func: typing.Optional[typing.Callable[[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>], ~T]] = None, reverse: bool = False) ‑> typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>sort packets by custom user function, or by default, packet_start_timestamp
:param sort_func: Optional function defining how to sort the packets, default None (uses packet start mach time)
:param reverse: bool, if True, sort results in reverse, default False
:return: the sorted list of packets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_packets(self, sort_func: Optional[Callable[[api_m_wp.WrappedRedvoxPacketM], T]] = None,
                 reverse: bool = False) -&gt; List[api_m_wp.WrappedRedvoxPacketM]:
    &#34;&#34;&#34;
    sort packets by custom user function, or by default, packet_start_timestamp
    :param sort_func: Optional function defining how to sort the packets, default None (uses packet start mach time)
    :param reverse: bool, if True, sort results in reverse, default False
    :return: the sorted list of packets
    &#34;&#34;&#34;
    if sort_func is None:
        sort_func = self._default_sort_packets
    return sorted(self.wrapped_packets, key=sort_func, reverse=reverse)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io.ReadWrappedPackets.validate_sensors"><code class="name flex">
<span>def <span class="ident">validate_sensors</span></span>(<span>self, wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks for difference between sensors of the wrapped_packet and the ReadWrappedPacket
:param wrapped_packet: packet to check for differences
:return: True if no change in any sensors, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_sensors(self, wrapped_packet: api_m_wp.WrappedRedvoxPacketM) -&gt; bool:
    &#34;&#34;&#34;
    Checks for difference between sensors of the wrapped_packet and the ReadWrappedPacket
    :param wrapped_packet: packet to check for differences
    :return: True if no change in any sensors, False otherwise
    &#34;&#34;&#34;
    # only 1 packet means sensors don&#39;t change
    if len(self.wrapped_packets) &lt;= 1:
        return True
    prev_sensors = [wrapped_packet.get_sensors().has_audio(),
                    wrapped_packet.get_sensors().has_pressure(),
                    wrapped_packet.get_sensors().has_accelerometer(),
                    wrapped_packet.get_sensors().has_gyroscope(),
                    wrapped_packet.get_sensors().has_light(),
                    wrapped_packet.get_sensors().has_image(),
                    wrapped_packet.get_sensors().has_location(),
                    wrapped_packet.get_sensors().has_magnetometer(),
                    wrapped_packet.get_sensors().has_ambient_temperature(),
                    wrapped_packet.get_sensors().has_compress_audio(),
                    wrapped_packet.get_sensors().has_gravity(),
                    wrapped_packet.get_sensors().has_linear_acceleration(),
                    wrapped_packet.get_sensors().has_orientation(),
                    wrapped_packet.get_sensors().has_proximity(),
                    wrapped_packet.get_sensors().has_relative_humidity(),
                    wrapped_packet.get_sensors().has_rotation_vector()]
    for packet in self.wrapped_packets:
        next_sensors = [packet.get_sensors().has_audio(),
                        packet.get_sensors().has_pressure(),
                        packet.get_sensors().has_accelerometer(),
                        packet.get_sensors().has_gyroscope(),
                        packet.get_sensors().has_light(),
                        packet.get_sensors().has_image(),
                        packet.get_sensors().has_location(),
                        packet.get_sensors().has_magnetometer(),
                        packet.get_sensors().has_ambient_temperature(),
                        packet.get_sensors().has_compress_audio(),
                        packet.get_sensors().has_gravity(),
                        packet.get_sensors().has_linear_acceleration(),
                        packet.get_sensors().has_orientation(),
                        packet.get_sensors().has_proximity(),
                        packet.get_sensors().has_relative_humidity(),
                        packet.get_sensors().has_rotation_vector()]
        if prev_sensors != next_sensors:
            return False
    # if here, all sensors match
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.api1000.io.StreamResult"><code class="flex name class">
<span>class <span class="ident">StreamResult</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamResult:
    pass</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.api1000" href="index.html">redvox.api1000</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.api1000.io.calc_evenly_sampled_timestamps" href="#redvox.api1000.io.calc_evenly_sampled_timestamps">calc_evenly_sampled_timestamps</a></code></li>
<li><code><a title="redvox.api1000.io.read_buffer" href="#redvox.api1000.io.read_buffer">read_buffer</a></code></li>
<li><code><a title="redvox.api1000.io.read_dir" href="#redvox.api1000.io.read_dir">read_dir</a></code></li>
<li><code><a title="redvox.api1000.io.read_file" href="#redvox.api1000.io.read_file">read_file</a></code></li>
<li><code><a title="redvox.api1000.io.read_rdvxm_buffer" href="#redvox.api1000.io.read_rdvxm_buffer">read_rdvxm_buffer</a></code></li>
<li><code><a title="redvox.api1000.io.read_rdvxm_file" href="#redvox.api1000.io.read_rdvxm_file">read_rdvxm_file</a></code></li>
<li><code><a title="redvox.api1000.io.read_structured" href="#redvox.api1000.io.read_structured">read_structured</a></code></li>
<li><code><a title="redvox.api1000.io.wrap" href="#redvox.api1000.io.wrap">wrap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.api1000.io.ReadResult" href="#redvox.api1000.io.ReadResult">ReadResult</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.api1000.io.ReadResult.add_list_of_packets" href="#redvox.api1000.io.ReadResult.add_list_of_packets">add_list_of_packets</a></code></li>
<li><code><a title="redvox.api1000.io.ReadResult.add_packet" href="#redvox.api1000.io.ReadResult.add_packet">add_packet</a></code></li>
<li><code><a title="redvox.api1000.io.ReadResult.add_result" href="#redvox.api1000.io.ReadResult.add_result">add_result</a></code></li>
<li><code><a title="redvox.api1000.io.ReadResult.get_by_id" href="#redvox.api1000.io.ReadResult.get_by_id">get_by_id</a></code></li>
<li><code><a title="redvox.api1000.io.ReadResult.identify_gaps" href="#redvox.api1000.io.ReadResult.identify_gaps">identify_gaps</a></code></li>
<li><code><a title="redvox.api1000.io.ReadResult.reorganize_packets" href="#redvox.api1000.io.ReadResult.reorganize_packets">reorganize_packets</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.api1000.io.ReadWrappedPackets" href="#redvox.api1000.io.ReadWrappedPackets">ReadWrappedPackets</a></code></h4>
<ul class="">
<li><code><a title="redvox.api1000.io.ReadWrappedPackets.T" href="#redvox.api1000.io.ReadWrappedPackets.T">T</a></code></li>
<li><code><a title="redvox.api1000.io.ReadWrappedPackets.add_packet" href="#redvox.api1000.io.ReadWrappedPackets.add_packet">add_packet</a></code></li>
<li><code><a title="redvox.api1000.io.ReadWrappedPackets.identify_gaps" href="#redvox.api1000.io.ReadWrappedPackets.identify_gaps">identify_gaps</a></code></li>
<li><code><a title="redvox.api1000.io.ReadWrappedPackets.sort_packets" href="#redvox.api1000.io.ReadWrappedPackets.sort_packets">sort_packets</a></code></li>
<li><code><a title="redvox.api1000.io.ReadWrappedPackets.validate_sensors" href="#redvox.api1000.io.ReadWrappedPackets.validate_sensors">validate_sensors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.api1000.io.StreamResult" href="#redvox.api1000.io.StreamResult">StreamResult</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>