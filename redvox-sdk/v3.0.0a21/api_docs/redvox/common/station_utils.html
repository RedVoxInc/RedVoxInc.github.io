<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>redvox.common.station_utils API documentation</title>
<meta name="description" content="Defines generic station metadata for API-independent analysis
all timestamps are integers in microseconds unless otherwise stated" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.station_utils</code></h1>
</header>
<section id="section-intro">
<p>Defines generic station metadata for API-independent analysis
all timestamps are integers in microseconds unless otherwise stated</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines generic station metadata for API-independent analysis
all timestamps are integers in microseconds unless otherwise stated
&#34;&#34;&#34;
from dataclasses import dataclass, field
from typing import List, Optional, Tuple

import numpy as np
import pandas as pd

from redvox.common import tri_message_stats as tms
from redvox.api1000.wrapped_redvox_packet.sensors.location import LocationProvider


@dataclass
class StationKey:
    &#34;&#34;&#34;
    A set of values that uniquely define a station
    Properties:
        id: str, id of the station
        uuid: str, uuid of the station
        start_timestamp_micros: float, starting time of the station in microseconds since epoch UTC
    &#34;&#34;&#34;
    id: str
    uuid: str
    start_timestamp_micros: float

    def get_key(self) -&gt; Tuple[str, str, float]:
        return self.id, self.uuid, self.start_timestamp_micros


@dataclass
class StationLocation:
    &#34;&#34;&#34;
    Generic StationLocation class for API-independent analysis
    Properties:
        lat_lon_timestamp: float, timestamp of the latitude and longitude, default np.nan
        altitude_timestamp: float, timestamp of the altitude, default np.nan
        speed_timestamp: float, timestamp of the speed, default np.nan
        bearing_timestamp: float, timestamp of the bearing, default np.nan
        provider: str, method/device name that provided the location, default &#34;None&#34;
        score: float, the value of the location&#39;s quality, default np.nan
        latitude: float, the latitude in degrees of the location, default np.nan
        longitude: float, the longitude in degrees of the location, default np.nan
        altitude: float, the altitude in meters of the location, default np.nan
        speed: float, the speed in meters/second of the location, default np.nan
        bearing: float, the bearing in degrees of the location, default np.nan
        horizontal_accuracy: float, the horizontal accuracy in meters of the location, default np.nan
        vertical_accuracy: float, the vertical accuracy in meters of the location, default np.nan
        speed_accuracy: float, the speed accuracy in meters/second of the location, default np.nan
        bearing_accuracy: float, the bearing accuracy in degrees of the location, default np.nan
    &#34;&#34;&#34;
    lat_lon_timestamp: float = np.nan
    altitude_timestamp: float = np.nan
    speed_timestamp: float = np.nan
    bearing_timestamp: float = np.nan
    provider: str = &#34;None&#34;
    score: float = np.nan
    latitude: float = np.nan
    longitude: float = np.nan
    altitude: float = np.nan
    speed: float = np.nan
    bearing: float = np.nan
    horizontal_accuracy: float = np.nan
    vertical_accuracy: float = np.nan
    speed_accuracy: float = np.nan
    bearing_accuracy: float = np.nan

    def update_timestamps(self, time_delta: float):
        &#34;&#34;&#34;
        adds the time_delta to the location&#39;s timestamps; use negative values to go backwards in time
        :param time_delta: time to add to location&#39;s timestamps
        &#34;&#34;&#34;
        self.lat_lon_timestamp += time_delta
        self.altitude_timestamp += time_delta
        self.speed_timestamp += time_delta
        self.bearing_timestamp += time_delta

    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: True if there is no lat_lon_timestamp
        &#34;&#34;&#34;
        return np.isnan(self.lat_lon_timestamp)


def station_location_from_data(data_location: pd.Series) -&gt; StationLocation:
    &#34;&#34;&#34;
    function to convert a location sensor pandas series to a StationLocation
    :param data_location: a pandas series object to convert
    :return: StationLocation with data from data_location
    &#34;&#34;&#34;
    return StationLocation(data_location[&#34;timestamps&#34;], data_location[&#34;timestamps&#34;],
                           data_location[&#34;timestamps&#34;], data_location[&#34;timestamps&#34;],
                           LocationProvider(data_location[&#34;location_provider&#34;]).name,
                           np.nan, data_location[&#34;latitude&#34;], data_location[&#34;longitude&#34;],
                           data_location[&#34;altitude&#34;], data_location[&#34;speed&#34;], data_location[&#34;bearing&#34;],
                           data_location[&#34;horizontal_accuracy&#34;], data_location[&#34;vertical_accuracy&#34;],
                           data_location[&#34;speed_accuracy&#34;], data_location[&#34;bearing_accuracy&#34;])


def _location_sorter(best_location: StationLocation, other_location: StationLocation, new_location: StationLocation,
                     ascending: bool = True) -&gt; Tuple[StationLocation, StationLocation]:
    &#34;&#34;&#34;
    Sorts up to three locations for quality purposes.
    the ascending parameter is used specifically for timestamps that come before a target time.
    :param best_location: current best location
    :param other_location: current other best location
    :param new_location: new location to compare against
    :param ascending: if True, values are sorted in ascending order, default True
    :return: the new best and other best locations
    &#34;&#34;&#34;
    if best_location.is_empty():
        new_best_location = new_location
        new_other_location = other_location
    else:
        locs_to_sort = [best_location, other_location, new_location]
        times_to_sort = np.array([x.lat_lon_timestamp for x in locs_to_sort])
        if not ascending:
            times_to_sort *= -1
        sorted_locs = [locs_to_sort[i] for i in np.argsort(times_to_sort)]
        new_best_location = sorted_locs[0]
        new_other_location = sorted_locs[1]
    return new_best_location, new_other_location


@dataclass
class LocationData:
    &#34;&#34;&#34;
    Location metadata statistics for the station
    Properties:
        best_location: Optional StationLocation object, the best rated location for the station, default None
        all_locations: List of StationLocation objects, all locations for the station including best, default empty list
        mean_latitude: float, the mean latitude in degrees of all locations, default np.nan
        std_latitude: float, the std dev of latitude in degrees of all locations, default 0.0
        mean_longitude: float, the mean longitude in degrees of all locations, default np.nan
        std_longitude: float, the std dev of longitude in degrees of all locations, default 0.0
        mean_altitude: float, the mean altitude in meters of all locations, default np.nan
        std_altitude: float, the std dev of altitude in meters of all locations, default 0.0
        mean_speed: float, the mean speed in meters/second of all locations, default np.nan
        std_speed: float, the std dev of speed in meters/second of all locations, default 0.0
        mean_bearing: float, the mean bearing in degrees of all locations, default np.nan
        std_bearing: float, the std dev of bearing in degrees of all locations, default 0.0
        mean_horizontal_accuracy: float, the mean horizontal accuracy in meters of all locations, default np.nan
        std_horizontal_accuracy: float, the std dev of horizontal accuracy in meters of all locations, default 0.0
        mean_vertical_accuracy: float, the mean vertical accuracy in meters of all locations, default np.nan
        std_vertical_accuracy: float, the std dev of vertical accuracy in meters of all locations, default 0.0
        mean_speed_accuracy: float, the mean speed accuracy in meters/second of all locations, default np.nan
        std_speed_accuracy: float, the std dev of speed accuracy in meters/second of all locations, default 0.0
        mean_bearing_accuracy: float, the mean bearing accuracy in degrees of all locations, default np.nan
        std_bearing_accuracy: float, the std dev of bearing accuracy in degrees of all locations, default 0.0
        mean_provider: str, method/device name that provided the mean location, default &#34;None&#34;
    &#34;&#34;&#34;
    best_location: Optional[StationLocation] = None
    all_locations: List[StationLocation] = field(default_factory=list)
    mean_latitude: float = np.nan
    std_latitude: float = 0.0
    mean_longitude: float = np.nan
    std_longitude: float = 0.0
    mean_altitude: float = np.nan
    std_altitude: float = 0.0
    mean_speed: float = np.nan
    std_speed: float = 0.0
    mean_bearing: float = np.nan
    std_bearing: float = 0.0
    mean_horizontal_accuracy: float = np.nan
    std_horizontal_accuracy: float = 0.0
    mean_vertical_accuracy: float = np.nan
    std_vertical_accuracy: float = 0.0
    mean_speed_accuracy: float = np.nan
    std_speed_accuracy: float = 0.0
    mean_bearing_accuracy: float = np.nan
    std_bearing_accuracy: float = 0.0
    mean_provider: str = &#34;None&#34;

    def update_timestamps(self, time_delta: float):
        &#34;&#34;&#34;
        adds the time_delta to all locations&#39; timestamps; use negative values to go backwards in time
        :param time_delta: time to add to all locations&#39; timestamps
        &#34;&#34;&#34;
        for location in self.all_locations:
            location.lat_lon_timestamp += time_delta
            location.altitude_timestamp += time_delta
            location.speed_timestamp += time_delta
            location.bearing_timestamp += time_delta

    def get_sorted_all_locations(self) -&gt; List[StationLocation]:
        &#34;&#34;&#34;
        :return: sorted list of self.all_locations by lat_lon_timestamp
        &#34;&#34;&#34;
        sorted_indices = np.argsort([x.lat_lon_timestamp for x in self.all_locations])
        return [self.all_locations[i] for i in sorted_indices]

    def update_window_locations(self, start_datetime: float, end_datetime: float):
        &#34;&#34;&#34;
        Updates all_locations to be any location within the window and up to two locations outside the window.
        Locations with timestamp equal to start or end datetimes are considered outside
        :param start_datetime: the start timestamp in microseconds since epoch UTC of the window to consider
        :param end_datetime: the end timestamp in microseconds since epoch UTC of the window to consider
        &#34;&#34;&#34;
        valid_locations: List[StationLocation] = []
        before_location: StationLocation = StationLocation()
        after_location: StationLocation = StationLocation()
        other_before_location: StationLocation = StationLocation()
        other_after_location: StationLocation = StationLocation()

        for location in self.all_locations:
            if start_datetime &lt; location.lat_lon_timestamp &lt; end_datetime:
                valid_locations.append(location)
            elif start_datetime &gt;= location.lat_lon_timestamp:
                before_location, other_before_location = \
                    _location_sorter(before_location, other_before_location, location, False)
            else:
                after_location, other_after_location = _location_sorter(after_location, other_after_location, location)

        if not before_location.is_empty():
            valid_locations.append(before_location)
        if not after_location.is_empty():
            valid_locations.append(after_location)
        if len(valid_locations) &lt; 2:
            if after_location.is_empty() and not other_before_location.is_empty():
                valid_locations.append(other_before_location)
            elif before_location.is_empty() and not other_after_location.is_empty():
                valid_locations.append(other_after_location)
        self.all_locations = valid_locations

    # noinspection PyTypeChecker
    def calc_mean_and_std_from_locations(self, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        compute the mean and std dev from the locations in the object
        :param debug: if True, output warnings when they occur, default False
        :return: True if success, False if failed
        &#34;&#34;&#34;
        if len(self.all_locations) &gt; 0:
            self.mean_latitude = np.mean([x.latitude for x in self.all_locations], axis=0)
            self.std_latitude = np.std([x.latitude for x in self.all_locations], axis=0)
            self.mean_longitude = np.mean([x.longitude for x in self.all_locations], axis=0)
            self.std_longitude = np.std([x.longitude for x in self.all_locations], axis=0)
            self.mean_altitude = np.mean([x.altitude for x in self.all_locations], axis=0)
            self.std_altitude = np.std([x.altitude for x in self.all_locations], axis=0)
            self.mean_speed = np.mean([x.speed for x in self.all_locations], axis=0)
            self.std_speed = np.std([x.speed for x in self.all_locations], axis=0)
            self.mean_bearing = np.mean([x.bearing for x in self.all_locations], axis=0)
            self.std_bearing = np.std([x.bearing for x in self.all_locations], axis=0)
            self.mean_horizontal_accuracy = np.mean([x.horizontal_accuracy for x in self.all_locations], axis=0)
            self.std_horizontal_accuracy = np.std([x.horizontal_accuracy for x in self.all_locations], axis=0)
            self.mean_vertical_accuracy = np.mean([x.vertical_accuracy for x in self.all_locations], axis=0)
            self.std_vertical_accuracy = np.std([x.vertical_accuracy for x in self.all_locations], axis=0)
            self.mean_speed_accuracy = np.mean([x.speed_accuracy for x in self.all_locations], axis=0)
            self.std_speed_accuracy = np.std([x.speed_accuracy for x in self.all_locations], axis=0)
            self.mean_bearing_accuracy = np.mean([x.bearing_accuracy for x in self.all_locations], axis=0)
            self.std_bearing_accuracy = np.std([x.bearing_accuracy for x in self.all_locations], axis=0)
        else:
            if debug:
                print(&#34;WARNING: Not enough locations to process mean and std dev on!&#34;)
            return False
        return True


class TimeSyncData:
    &#34;&#34;&#34;
    Generic TimeSync object for packets
    Properties:
        timesync_data: dataframe of the timestamps of the sync exchanges, default empty dataframe
                                Must be a multiple of 6 elements long.
        best_latency: float, best latency of the time sync exchanges, default np.nan
        best_offset: float, best offset of the time sync exchanges, default 0.0
    &#34;&#34;&#34;
    def __init__(self, timesync_data: np.array = np.array([]),
                 best_latency: float = np.nan, best_offset: float = 0.0):
        &#34;&#34;&#34;
        initialize the TimeSyncData object
        :param timesync_data: np.array of the timestamps of the sync exchanges, default empty np.array
                                Must be a multiple of 6 elements long.
                                May be 1 dimension, in which case will be converted into a 2-d np.ndarray
        :param best_latency: float, best latency of the time sync exchanges, default np.nan
        :param best_offset: float, best offset of the time sync exchanges, default 0.0
        &#34;&#34;&#34;
        if len(timesync_data) &gt; 0 and len(timesync_data.shape) != 2:
            timesync_data = np.transpose(tms.transmit_receive_timestamps_microsec(timesync_data))
        elif len(timesync_data) == 0:
            timesync_data = []
        self.timesync_data = pd.DataFrame(timesync_data, columns=[&#34;a1&#34;, &#34;a2&#34;, &#34;a3&#34;, &#34;b1&#34;, &#34;b2&#34;, &#34;b3&#34;])
        self.best_latency = best_latency
        self.best_offset = best_offset

    def num_samples(self) -&gt; int:
        &#34;&#34;&#34;
        :return: the number of time sync exchanges, which are the rows in the dataframe
        &#34;&#34;&#34;
        return self.timesync_data.shape[0]


@dataclass
class DataPacket:
    &#34;&#34;&#34;
    Generic DataPacket class for API-independent analysis
    Properties:
        server_received_timestamp: float, server timestamp of when data was received by the server
        app_start_timestamp: float, machine timestamp of when app started
        data_start_timestamp: float, machine timestamp of the start of the packet&#39;s data
        data_end_timestamp: float, machine timestamp of the end of the packet&#39;s data, default np.nan
        duration_s: float, duration of data packet in seconds, default 0.0
        num_audio_samples: int, number of audio samples in the data packet, default 0
        timesync: TimeSyncData object, the timesync data associated with the packet, default empty TimeSyncData object
        micros_to_next_packet: float, the length of time in microseconds to reach the next
                                packet&#39;s (in the station&#39;s data) start time, default np.nan
                                Should be close to 0 or close to self.expected_sample_interval_s
                                (when converted to same units)
        best_location: Optional StationLocation metadata, default None
    &#34;&#34;&#34;
    server_timestamp: float
    app_start_timestamp: float
    data_start_timestamp: float
    data_end_timestamp: float = np.nan
    duration_s: float = 0.0
    num_audio_samples: int = 0
    timesync: TimeSyncData = TimeSyncData()
    micros_to_next_packet: float = np.nan
    best_location: Optional[StationLocation] = None

    def expected_sample_interval_s(self) -&gt; float:
        &#34;&#34;&#34;
        the packet&#39;s expected sample interval based on its own data
        :return: the packet&#39;s expected sample interval in seconds
        &#34;&#34;&#34;
        return self.duration_s / self.num_audio_samples


@dataclass
class StationTiming:
    &#34;&#34;&#34;
    Generic StationTiming class for API-independent analysis
    Properties:
        station_start_timestamp: float, timestamp when station started recording
        audio_sample_rate_hz: float, sample rate in hz of audio sensor
        station_first_data_timestamp: float, first timestamp chronologically of the data
        episode_start_timestamp_s: float, timestamp of start of segment of interest in seconds since epoch UTC,
                                    default np.nan
        episode_end_timestamp_s: float, timestamp of end of segment of interest in seconds since epoch UTC,
                                    default np.nan
        station_best_latency: float, best latency of data, default np.nan
        station_best_offset: float, best offset of data, default 0.0
        station_mean_offset: float, mean offset of data, default 0.0
        station_std_offset: float, std dev of offset of data, default 0.0
    &#34;&#34;&#34;
    station_start_timestamp: float
    audio_sample_rate_hz: float
    station_first_data_timestamp: float
    episode_start_timestamp_s: float = np.nan
    episode_end_timestamp_s: float = np.nan
    station_best_latency: float = np.nan
    station_best_offset: float = 0.0
    station_mean_offset: float = 0.0
    station_std_offset: float = 0.0


@dataclass
class StationMetadata:
    &#34;&#34;&#34;
    Generic StationMetadata class for API-independent analysis
    Properties:
        station_id: str, id of the station
        station_make: str, maker of the station
        station_model: str, model of the station
        station_timing_is_corrected: bool, if True, the station&#39;s timestamps have been altered from their raw values
                                        default False
        station_os: optional str, operating system of the station, default None
        station_os_version: optional str, station OS version, default None
        station_app: optional str, the name of the recording software used by the station, default None
        station_app_version: optional str, the recording software version, default None
        is_mic_scrambled: optional bool, True if mic data is scrambled, default False
        timing_data: optional StationTiming metadata, default None
        station_calib: optional float, station calibration value, default None
        station_network_name: optional str, name/code of network station belongs to, default None
        station_name: optional str, name/code of station, default None
        station_location_name: optional str, name/code of location station is at, default None
        station_channel_name: optional str, name/code of channel station is recording, default None
        station_channel_encoding: optional str, name/code of channel encoding method, default None
        station_uuid: optional str, uuid of the station, default is the same value as station_id
        best_location: optional StationLocation metadata, default empty LocationData
    &#34;&#34;&#34;
    station_id: str
    station_make: str
    station_model: str
    station_timing_is_corrected: bool = False
    station_os: Optional[str] = None
    station_os_version: Optional[str] = None
    station_app: Optional[str] = None
    station_app_version: Optional[str] = None
    is_mic_scrambled: Optional[bool] = False
    timing_data: Optional[StationTiming] = None
    station_calib: Optional[float] = None
    station_network_name: Optional[str] = None
    station_name: Optional[str] = None
    station_location_name: Optional[str] = None
    station_channel_name: Optional[str] = None
    station_channel_encoding: Optional[str] = None
    station_uuid: Optional[str] = None
    location_data: Optional[LocationData] = None

    def __post_init__(self):
        &#34;&#34;&#34;
        if the station_uuid is None, set it to be station_id
        if the location data is None, set it to empty LocationData
        &#34;&#34;&#34;
        if not self.station_uuid:
            self.station_uuid = self.station_id
        if not self.location_data:
            self.location_data = LocationData()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.common.station_utils.station_location_from_data"><code class="name flex">
<span>def <span class="ident">station_location_from_data</span></span>(<span>data_location: pandas.core.series.Series) ‑> <a title="redvox.common.station_utils.StationLocation" href="#redvox.common.station_utils.StationLocation">StationLocation</a></span>
</code></dt>
<dd>
<div class="desc"><p>function to convert a location sensor pandas series to a StationLocation
:param data_location: a pandas series object to convert
:return: StationLocation with data from data_location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def station_location_from_data(data_location: pd.Series) -&gt; StationLocation:
    &#34;&#34;&#34;
    function to convert a location sensor pandas series to a StationLocation
    :param data_location: a pandas series object to convert
    :return: StationLocation with data from data_location
    &#34;&#34;&#34;
    return StationLocation(data_location[&#34;timestamps&#34;], data_location[&#34;timestamps&#34;],
                           data_location[&#34;timestamps&#34;], data_location[&#34;timestamps&#34;],
                           LocationProvider(data_location[&#34;location_provider&#34;]).name,
                           np.nan, data_location[&#34;latitude&#34;], data_location[&#34;longitude&#34;],
                           data_location[&#34;altitude&#34;], data_location[&#34;speed&#34;], data_location[&#34;bearing&#34;],
                           data_location[&#34;horizontal_accuracy&#34;], data_location[&#34;vertical_accuracy&#34;],
                           data_location[&#34;speed_accuracy&#34;], data_location[&#34;bearing_accuracy&#34;])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.common.station_utils.DataPacket"><code class="flex name class">
<span>class <span class="ident">DataPacket</span></span>
<span>(</span><span>server_timestamp: float, app_start_timestamp: float, data_start_timestamp: float, data_end_timestamp: float = nan, duration_s: float = 0.0, num_audio_samples: int = 0, timesync: <a title="redvox.common.station_utils.TimeSyncData" href="#redvox.common.station_utils.TimeSyncData">TimeSyncData</a> = &lt;redvox.common.station_utils.TimeSyncData object&gt;, micros_to_next_packet: float = nan, best_location: typing.Optional[<a title="redvox.common.station_utils.StationLocation" href="#redvox.common.station_utils.StationLocation">StationLocation</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic DataPacket class for API-independent analysis</p>
<h2 id="properties">Properties</h2>
<p>server_received_timestamp: float, server timestamp of when data was received by the server
app_start_timestamp: float, machine timestamp of when app started
data_start_timestamp: float, machine timestamp of the start of the packet's data
data_end_timestamp: float, machine timestamp of the end of the packet's data, default np.nan
duration_s: float, duration of data packet in seconds, default 0.0
num_audio_samples: int, number of audio samples in the data packet, default 0
timesync: TimeSyncData object, the timesync data associated with the packet, default empty TimeSyncData object
micros_to_next_packet: float, the length of time in microseconds to reach the next
packet's (in the station's data) start time, default np.nan
Should be close to 0 or close to self.expected_sample_interval_s
(when converted to same units)
best_location: Optional StationLocation metadata, default None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DataPacket:
    &#34;&#34;&#34;
    Generic DataPacket class for API-independent analysis
    Properties:
        server_received_timestamp: float, server timestamp of when data was received by the server
        app_start_timestamp: float, machine timestamp of when app started
        data_start_timestamp: float, machine timestamp of the start of the packet&#39;s data
        data_end_timestamp: float, machine timestamp of the end of the packet&#39;s data, default np.nan
        duration_s: float, duration of data packet in seconds, default 0.0
        num_audio_samples: int, number of audio samples in the data packet, default 0
        timesync: TimeSyncData object, the timesync data associated with the packet, default empty TimeSyncData object
        micros_to_next_packet: float, the length of time in microseconds to reach the next
                                packet&#39;s (in the station&#39;s data) start time, default np.nan
                                Should be close to 0 or close to self.expected_sample_interval_s
                                (when converted to same units)
        best_location: Optional StationLocation metadata, default None
    &#34;&#34;&#34;
    server_timestamp: float
    app_start_timestamp: float
    data_start_timestamp: float
    data_end_timestamp: float = np.nan
    duration_s: float = 0.0
    num_audio_samples: int = 0
    timesync: TimeSyncData = TimeSyncData()
    micros_to_next_packet: float = np.nan
    best_location: Optional[StationLocation] = None

    def expected_sample_interval_s(self) -&gt; float:
        &#34;&#34;&#34;
        the packet&#39;s expected sample interval based on its own data
        :return: the packet&#39;s expected sample interval in seconds
        &#34;&#34;&#34;
        return self.duration_s / self.num_audio_samples</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.station_utils.DataPacket.app_start_timestamp"><code class="name">var <span class="ident">app_start_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.DataPacket.best_location"><code class="name">var <span class="ident">best_location</span> : typing.Optional[<a title="redvox.common.station_utils.StationLocation" href="#redvox.common.station_utils.StationLocation">StationLocation</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.DataPacket.data_end_timestamp"><code class="name">var <span class="ident">data_end_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.DataPacket.data_start_timestamp"><code class="name">var <span class="ident">data_start_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.DataPacket.duration_s"><code class="name">var <span class="ident">duration_s</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.DataPacket.micros_to_next_packet"><code class="name">var <span class="ident">micros_to_next_packet</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.DataPacket.num_audio_samples"><code class="name">var <span class="ident">num_audio_samples</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.DataPacket.server_timestamp"><code class="name">var <span class="ident">server_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.DataPacket.timesync"><code class="name">var <span class="ident">timesync</span> : <a title="redvox.common.station_utils.TimeSyncData" href="#redvox.common.station_utils.TimeSyncData">TimeSyncData</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.station_utils.DataPacket.expected_sample_interval_s"><code class="name flex">
<span>def <span class="ident">expected_sample_interval_s</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>the packet's expected sample interval based on its own data
:return: the packet's expected sample interval in seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expected_sample_interval_s(self) -&gt; float:
    &#34;&#34;&#34;
    the packet&#39;s expected sample interval based on its own data
    :return: the packet&#39;s expected sample interval in seconds
    &#34;&#34;&#34;
    return self.duration_s / self.num_audio_samples</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.station_utils.LocationData"><code class="flex name class">
<span>class <span class="ident">LocationData</span></span>
<span>(</span><span>best_location: typing.Optional[<a title="redvox.common.station_utils.StationLocation" href="#redvox.common.station_utils.StationLocation">StationLocation</a>] = None, all_locations: typing.List[<a title="redvox.common.station_utils.StationLocation" href="#redvox.common.station_utils.StationLocation">StationLocation</a>] = &lt;factory&gt;, mean_latitude: float = nan, std_latitude: float = 0.0, mean_longitude: float = nan, std_longitude: float = 0.0, mean_altitude: float = nan, std_altitude: float = 0.0, mean_speed: float = nan, std_speed: float = 0.0, mean_bearing: float = nan, std_bearing: float = 0.0, mean_horizontal_accuracy: float = nan, std_horizontal_accuracy: float = 0.0, mean_vertical_accuracy: float = nan, std_vertical_accuracy: float = 0.0, mean_speed_accuracy: float = nan, std_speed_accuracy: float = 0.0, mean_bearing_accuracy: float = nan, std_bearing_accuracy: float = 0.0, mean_provider: str = 'None')</span>
</code></dt>
<dd>
<div class="desc"><p>Location metadata statistics for the station</p>
<h2 id="properties">Properties</h2>
<p>best_location: Optional StationLocation object, the best rated location for the station, default None
all_locations: List of StationLocation objects, all locations for the station including best, default empty list
mean_latitude: float, the mean latitude in degrees of all locations, default np.nan
std_latitude: float, the std dev of latitude in degrees of all locations, default 0.0
mean_longitude: float, the mean longitude in degrees of all locations, default np.nan
std_longitude: float, the std dev of longitude in degrees of all locations, default 0.0
mean_altitude: float, the mean altitude in meters of all locations, default np.nan
std_altitude: float, the std dev of altitude in meters of all locations, default 0.0
mean_speed: float, the mean speed in meters/second of all locations, default np.nan
std_speed: float, the std dev of speed in meters/second of all locations, default 0.0
mean_bearing: float, the mean bearing in degrees of all locations, default np.nan
std_bearing: float, the std dev of bearing in degrees of all locations, default 0.0
mean_horizontal_accuracy: float, the mean horizontal accuracy in meters of all locations, default np.nan
std_horizontal_accuracy: float, the std dev of horizontal accuracy in meters of all locations, default 0.0
mean_vertical_accuracy: float, the mean vertical accuracy in meters of all locations, default np.nan
std_vertical_accuracy: float, the std dev of vertical accuracy in meters of all locations, default 0.0
mean_speed_accuracy: float, the mean speed accuracy in meters/second of all locations, default np.nan
std_speed_accuracy: float, the std dev of speed accuracy in meters/second of all locations, default 0.0
mean_bearing_accuracy: float, the mean bearing accuracy in degrees of all locations, default np.nan
std_bearing_accuracy: float, the std dev of bearing accuracy in degrees of all locations, default 0.0
mean_provider: str, method/device name that provided the mean location, default "None"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class LocationData:
    &#34;&#34;&#34;
    Location metadata statistics for the station
    Properties:
        best_location: Optional StationLocation object, the best rated location for the station, default None
        all_locations: List of StationLocation objects, all locations for the station including best, default empty list
        mean_latitude: float, the mean latitude in degrees of all locations, default np.nan
        std_latitude: float, the std dev of latitude in degrees of all locations, default 0.0
        mean_longitude: float, the mean longitude in degrees of all locations, default np.nan
        std_longitude: float, the std dev of longitude in degrees of all locations, default 0.0
        mean_altitude: float, the mean altitude in meters of all locations, default np.nan
        std_altitude: float, the std dev of altitude in meters of all locations, default 0.0
        mean_speed: float, the mean speed in meters/second of all locations, default np.nan
        std_speed: float, the std dev of speed in meters/second of all locations, default 0.0
        mean_bearing: float, the mean bearing in degrees of all locations, default np.nan
        std_bearing: float, the std dev of bearing in degrees of all locations, default 0.0
        mean_horizontal_accuracy: float, the mean horizontal accuracy in meters of all locations, default np.nan
        std_horizontal_accuracy: float, the std dev of horizontal accuracy in meters of all locations, default 0.0
        mean_vertical_accuracy: float, the mean vertical accuracy in meters of all locations, default np.nan
        std_vertical_accuracy: float, the std dev of vertical accuracy in meters of all locations, default 0.0
        mean_speed_accuracy: float, the mean speed accuracy in meters/second of all locations, default np.nan
        std_speed_accuracy: float, the std dev of speed accuracy in meters/second of all locations, default 0.0
        mean_bearing_accuracy: float, the mean bearing accuracy in degrees of all locations, default np.nan
        std_bearing_accuracy: float, the std dev of bearing accuracy in degrees of all locations, default 0.0
        mean_provider: str, method/device name that provided the mean location, default &#34;None&#34;
    &#34;&#34;&#34;
    best_location: Optional[StationLocation] = None
    all_locations: List[StationLocation] = field(default_factory=list)
    mean_latitude: float = np.nan
    std_latitude: float = 0.0
    mean_longitude: float = np.nan
    std_longitude: float = 0.0
    mean_altitude: float = np.nan
    std_altitude: float = 0.0
    mean_speed: float = np.nan
    std_speed: float = 0.0
    mean_bearing: float = np.nan
    std_bearing: float = 0.0
    mean_horizontal_accuracy: float = np.nan
    std_horizontal_accuracy: float = 0.0
    mean_vertical_accuracy: float = np.nan
    std_vertical_accuracy: float = 0.0
    mean_speed_accuracy: float = np.nan
    std_speed_accuracy: float = 0.0
    mean_bearing_accuracy: float = np.nan
    std_bearing_accuracy: float = 0.0
    mean_provider: str = &#34;None&#34;

    def update_timestamps(self, time_delta: float):
        &#34;&#34;&#34;
        adds the time_delta to all locations&#39; timestamps; use negative values to go backwards in time
        :param time_delta: time to add to all locations&#39; timestamps
        &#34;&#34;&#34;
        for location in self.all_locations:
            location.lat_lon_timestamp += time_delta
            location.altitude_timestamp += time_delta
            location.speed_timestamp += time_delta
            location.bearing_timestamp += time_delta

    def get_sorted_all_locations(self) -&gt; List[StationLocation]:
        &#34;&#34;&#34;
        :return: sorted list of self.all_locations by lat_lon_timestamp
        &#34;&#34;&#34;
        sorted_indices = np.argsort([x.lat_lon_timestamp for x in self.all_locations])
        return [self.all_locations[i] for i in sorted_indices]

    def update_window_locations(self, start_datetime: float, end_datetime: float):
        &#34;&#34;&#34;
        Updates all_locations to be any location within the window and up to two locations outside the window.
        Locations with timestamp equal to start or end datetimes are considered outside
        :param start_datetime: the start timestamp in microseconds since epoch UTC of the window to consider
        :param end_datetime: the end timestamp in microseconds since epoch UTC of the window to consider
        &#34;&#34;&#34;
        valid_locations: List[StationLocation] = []
        before_location: StationLocation = StationLocation()
        after_location: StationLocation = StationLocation()
        other_before_location: StationLocation = StationLocation()
        other_after_location: StationLocation = StationLocation()

        for location in self.all_locations:
            if start_datetime &lt; location.lat_lon_timestamp &lt; end_datetime:
                valid_locations.append(location)
            elif start_datetime &gt;= location.lat_lon_timestamp:
                before_location, other_before_location = \
                    _location_sorter(before_location, other_before_location, location, False)
            else:
                after_location, other_after_location = _location_sorter(after_location, other_after_location, location)

        if not before_location.is_empty():
            valid_locations.append(before_location)
        if not after_location.is_empty():
            valid_locations.append(after_location)
        if len(valid_locations) &lt; 2:
            if after_location.is_empty() and not other_before_location.is_empty():
                valid_locations.append(other_before_location)
            elif before_location.is_empty() and not other_after_location.is_empty():
                valid_locations.append(other_after_location)
        self.all_locations = valid_locations

    # noinspection PyTypeChecker
    def calc_mean_and_std_from_locations(self, debug: bool = False) -&gt; bool:
        &#34;&#34;&#34;
        compute the mean and std dev from the locations in the object
        :param debug: if True, output warnings when they occur, default False
        :return: True if success, False if failed
        &#34;&#34;&#34;
        if len(self.all_locations) &gt; 0:
            self.mean_latitude = np.mean([x.latitude for x in self.all_locations], axis=0)
            self.std_latitude = np.std([x.latitude for x in self.all_locations], axis=0)
            self.mean_longitude = np.mean([x.longitude for x in self.all_locations], axis=0)
            self.std_longitude = np.std([x.longitude for x in self.all_locations], axis=0)
            self.mean_altitude = np.mean([x.altitude for x in self.all_locations], axis=0)
            self.std_altitude = np.std([x.altitude for x in self.all_locations], axis=0)
            self.mean_speed = np.mean([x.speed for x in self.all_locations], axis=0)
            self.std_speed = np.std([x.speed for x in self.all_locations], axis=0)
            self.mean_bearing = np.mean([x.bearing for x in self.all_locations], axis=0)
            self.std_bearing = np.std([x.bearing for x in self.all_locations], axis=0)
            self.mean_horizontal_accuracy = np.mean([x.horizontal_accuracy for x in self.all_locations], axis=0)
            self.std_horizontal_accuracy = np.std([x.horizontal_accuracy for x in self.all_locations], axis=0)
            self.mean_vertical_accuracy = np.mean([x.vertical_accuracy for x in self.all_locations], axis=0)
            self.std_vertical_accuracy = np.std([x.vertical_accuracy for x in self.all_locations], axis=0)
            self.mean_speed_accuracy = np.mean([x.speed_accuracy for x in self.all_locations], axis=0)
            self.std_speed_accuracy = np.std([x.speed_accuracy for x in self.all_locations], axis=0)
            self.mean_bearing_accuracy = np.mean([x.bearing_accuracy for x in self.all_locations], axis=0)
            self.std_bearing_accuracy = np.std([x.bearing_accuracy for x in self.all_locations], axis=0)
        else:
            if debug:
                print(&#34;WARNING: Not enough locations to process mean and std dev on!&#34;)
            return False
        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.station_utils.LocationData.all_locations"><code class="name">var <span class="ident">all_locations</span> : typing.List[<a title="redvox.common.station_utils.StationLocation" href="#redvox.common.station_utils.StationLocation">StationLocation</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.best_location"><code class="name">var <span class="ident">best_location</span> : typing.Optional[<a title="redvox.common.station_utils.StationLocation" href="#redvox.common.station_utils.StationLocation">StationLocation</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_altitude"><code class="name">var <span class="ident">mean_altitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_bearing"><code class="name">var <span class="ident">mean_bearing</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_bearing_accuracy"><code class="name">var <span class="ident">mean_bearing_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_horizontal_accuracy"><code class="name">var <span class="ident">mean_horizontal_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_latitude"><code class="name">var <span class="ident">mean_latitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_longitude"><code class="name">var <span class="ident">mean_longitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_provider"><code class="name">var <span class="ident">mean_provider</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_speed"><code class="name">var <span class="ident">mean_speed</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_speed_accuracy"><code class="name">var <span class="ident">mean_speed_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.mean_vertical_accuracy"><code class="name">var <span class="ident">mean_vertical_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.std_altitude"><code class="name">var <span class="ident">std_altitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.std_bearing"><code class="name">var <span class="ident">std_bearing</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.std_bearing_accuracy"><code class="name">var <span class="ident">std_bearing_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.std_horizontal_accuracy"><code class="name">var <span class="ident">std_horizontal_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.std_latitude"><code class="name">var <span class="ident">std_latitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.std_longitude"><code class="name">var <span class="ident">std_longitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.std_speed"><code class="name">var <span class="ident">std_speed</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.std_speed_accuracy"><code class="name">var <span class="ident">std_speed_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.LocationData.std_vertical_accuracy"><code class="name">var <span class="ident">std_vertical_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.station_utils.LocationData.calc_mean_and_std_from_locations"><code class="name flex">
<span>def <span class="ident">calc_mean_and_std_from_locations</span></span>(<span>self, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>compute the mean and std dev from the locations in the object
:param debug: if True, output warnings when they occur, default False
:return: True if success, False if failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_mean_and_std_from_locations(self, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    compute the mean and std dev from the locations in the object
    :param debug: if True, output warnings when they occur, default False
    :return: True if success, False if failed
    &#34;&#34;&#34;
    if len(self.all_locations) &gt; 0:
        self.mean_latitude = np.mean([x.latitude for x in self.all_locations], axis=0)
        self.std_latitude = np.std([x.latitude for x in self.all_locations], axis=0)
        self.mean_longitude = np.mean([x.longitude for x in self.all_locations], axis=0)
        self.std_longitude = np.std([x.longitude for x in self.all_locations], axis=0)
        self.mean_altitude = np.mean([x.altitude for x in self.all_locations], axis=0)
        self.std_altitude = np.std([x.altitude for x in self.all_locations], axis=0)
        self.mean_speed = np.mean([x.speed for x in self.all_locations], axis=0)
        self.std_speed = np.std([x.speed for x in self.all_locations], axis=0)
        self.mean_bearing = np.mean([x.bearing for x in self.all_locations], axis=0)
        self.std_bearing = np.std([x.bearing for x in self.all_locations], axis=0)
        self.mean_horizontal_accuracy = np.mean([x.horizontal_accuracy for x in self.all_locations], axis=0)
        self.std_horizontal_accuracy = np.std([x.horizontal_accuracy for x in self.all_locations], axis=0)
        self.mean_vertical_accuracy = np.mean([x.vertical_accuracy for x in self.all_locations], axis=0)
        self.std_vertical_accuracy = np.std([x.vertical_accuracy for x in self.all_locations], axis=0)
        self.mean_speed_accuracy = np.mean([x.speed_accuracy for x in self.all_locations], axis=0)
        self.std_speed_accuracy = np.std([x.speed_accuracy for x in self.all_locations], axis=0)
        self.mean_bearing_accuracy = np.mean([x.bearing_accuracy for x in self.all_locations], axis=0)
        self.std_bearing_accuracy = np.std([x.bearing_accuracy for x in self.all_locations], axis=0)
    else:
        if debug:
            print(&#34;WARNING: Not enough locations to process mean and std dev on!&#34;)
        return False
    return True</code></pre>
</details>
</dd>
<dt id="redvox.common.station_utils.LocationData.get_sorted_all_locations"><code class="name flex">
<span>def <span class="ident">get_sorted_all_locations</span></span>(<span>self) ‑> typing.List[<a title="redvox.common.station_utils.StationLocation" href="#redvox.common.station_utils.StationLocation">StationLocation</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: sorted list of self.all_locations by lat_lon_timestamp</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sorted_all_locations(self) -&gt; List[StationLocation]:
    &#34;&#34;&#34;
    :return: sorted list of self.all_locations by lat_lon_timestamp
    &#34;&#34;&#34;
    sorted_indices = np.argsort([x.lat_lon_timestamp for x in self.all_locations])
    return [self.all_locations[i] for i in sorted_indices]</code></pre>
</details>
</dd>
<dt id="redvox.common.station_utils.LocationData.update_timestamps"><code class="name flex">
<span>def <span class="ident">update_timestamps</span></span>(<span>self, time_delta: float)</span>
</code></dt>
<dd>
<div class="desc"><p>adds the time_delta to all locations' timestamps; use negative values to go backwards in time
:param time_delta: time to add to all locations' timestamps</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_timestamps(self, time_delta: float):
    &#34;&#34;&#34;
    adds the time_delta to all locations&#39; timestamps; use negative values to go backwards in time
    :param time_delta: time to add to all locations&#39; timestamps
    &#34;&#34;&#34;
    for location in self.all_locations:
        location.lat_lon_timestamp += time_delta
        location.altitude_timestamp += time_delta
        location.speed_timestamp += time_delta
        location.bearing_timestamp += time_delta</code></pre>
</details>
</dd>
<dt id="redvox.common.station_utils.LocationData.update_window_locations"><code class="name flex">
<span>def <span class="ident">update_window_locations</span></span>(<span>self, start_datetime: float, end_datetime: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates all_locations to be any location within the window and up to two locations outside the window.
Locations with timestamp equal to start or end datetimes are considered outside
:param start_datetime: the start timestamp in microseconds since epoch UTC of the window to consider
:param end_datetime: the end timestamp in microseconds since epoch UTC of the window to consider</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_window_locations(self, start_datetime: float, end_datetime: float):
    &#34;&#34;&#34;
    Updates all_locations to be any location within the window and up to two locations outside the window.
    Locations with timestamp equal to start or end datetimes are considered outside
    :param start_datetime: the start timestamp in microseconds since epoch UTC of the window to consider
    :param end_datetime: the end timestamp in microseconds since epoch UTC of the window to consider
    &#34;&#34;&#34;
    valid_locations: List[StationLocation] = []
    before_location: StationLocation = StationLocation()
    after_location: StationLocation = StationLocation()
    other_before_location: StationLocation = StationLocation()
    other_after_location: StationLocation = StationLocation()

    for location in self.all_locations:
        if start_datetime &lt; location.lat_lon_timestamp &lt; end_datetime:
            valid_locations.append(location)
        elif start_datetime &gt;= location.lat_lon_timestamp:
            before_location, other_before_location = \
                _location_sorter(before_location, other_before_location, location, False)
        else:
            after_location, other_after_location = _location_sorter(after_location, other_after_location, location)

    if not before_location.is_empty():
        valid_locations.append(before_location)
    if not after_location.is_empty():
        valid_locations.append(after_location)
    if len(valid_locations) &lt; 2:
        if after_location.is_empty() and not other_before_location.is_empty():
            valid_locations.append(other_before_location)
        elif before_location.is_empty() and not other_after_location.is_empty():
            valid_locations.append(other_after_location)
    self.all_locations = valid_locations</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.station_utils.StationKey"><code class="flex name class">
<span>class <span class="ident">StationKey</span></span>
<span>(</span><span>id: str, uuid: str, start_timestamp_micros: float)</span>
</code></dt>
<dd>
<div class="desc"><p>A set of values that uniquely define a station</p>
<h2 id="properties">Properties</h2>
<p>id: str, id of the station
uuid: str, uuid of the station
start_timestamp_micros: float, starting time of the station in microseconds since epoch UTC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class StationKey:
    &#34;&#34;&#34;
    A set of values that uniquely define a station
    Properties:
        id: str, id of the station
        uuid: str, uuid of the station
        start_timestamp_micros: float, starting time of the station in microseconds since epoch UTC
    &#34;&#34;&#34;
    id: str
    uuid: str
    start_timestamp_micros: float

    def get_key(self) -&gt; Tuple[str, str, float]:
        return self.id, self.uuid, self.start_timestamp_micros</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.station_utils.StationKey.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationKey.start_timestamp_micros"><code class="name">var <span class="ident">start_timestamp_micros</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationKey.uuid"><code class="name">var <span class="ident">uuid</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.station_utils.StationKey.get_key"><code class="name flex">
<span>def <span class="ident">get_key</span></span>(<span>self) ‑> typing.Tuple[str, str, float]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_key(self) -&gt; Tuple[str, str, float]:
    return self.id, self.uuid, self.start_timestamp_micros</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.station_utils.StationLocation"><code class="flex name class">
<span>class <span class="ident">StationLocation</span></span>
<span>(</span><span>lat_lon_timestamp: float = nan, altitude_timestamp: float = nan, speed_timestamp: float = nan, bearing_timestamp: float = nan, provider: str = 'None', score: float = nan, latitude: float = nan, longitude: float = nan, altitude: float = nan, speed: float = nan, bearing: float = nan, horizontal_accuracy: float = nan, vertical_accuracy: float = nan, speed_accuracy: float = nan, bearing_accuracy: float = nan)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic StationLocation class for API-independent analysis</p>
<h2 id="properties">Properties</h2>
<p>lat_lon_timestamp: float, timestamp of the latitude and longitude, default np.nan
altitude_timestamp: float, timestamp of the altitude, default np.nan
speed_timestamp: float, timestamp of the speed, default np.nan
bearing_timestamp: float, timestamp of the bearing, default np.nan
provider: str, method/device name that provided the location, default "None"
score: float, the value of the location's quality, default np.nan
latitude: float, the latitude in degrees of the location, default np.nan
longitude: float, the longitude in degrees of the location, default np.nan
altitude: float, the altitude in meters of the location, default np.nan
speed: float, the speed in meters/second of the location, default np.nan
bearing: float, the bearing in degrees of the location, default np.nan
horizontal_accuracy: float, the horizontal accuracy in meters of the location, default np.nan
vertical_accuracy: float, the vertical accuracy in meters of the location, default np.nan
speed_accuracy: float, the speed accuracy in meters/second of the location, default np.nan
bearing_accuracy: float, the bearing accuracy in degrees of the location, default np.nan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class StationLocation:
    &#34;&#34;&#34;
    Generic StationLocation class for API-independent analysis
    Properties:
        lat_lon_timestamp: float, timestamp of the latitude and longitude, default np.nan
        altitude_timestamp: float, timestamp of the altitude, default np.nan
        speed_timestamp: float, timestamp of the speed, default np.nan
        bearing_timestamp: float, timestamp of the bearing, default np.nan
        provider: str, method/device name that provided the location, default &#34;None&#34;
        score: float, the value of the location&#39;s quality, default np.nan
        latitude: float, the latitude in degrees of the location, default np.nan
        longitude: float, the longitude in degrees of the location, default np.nan
        altitude: float, the altitude in meters of the location, default np.nan
        speed: float, the speed in meters/second of the location, default np.nan
        bearing: float, the bearing in degrees of the location, default np.nan
        horizontal_accuracy: float, the horizontal accuracy in meters of the location, default np.nan
        vertical_accuracy: float, the vertical accuracy in meters of the location, default np.nan
        speed_accuracy: float, the speed accuracy in meters/second of the location, default np.nan
        bearing_accuracy: float, the bearing accuracy in degrees of the location, default np.nan
    &#34;&#34;&#34;
    lat_lon_timestamp: float = np.nan
    altitude_timestamp: float = np.nan
    speed_timestamp: float = np.nan
    bearing_timestamp: float = np.nan
    provider: str = &#34;None&#34;
    score: float = np.nan
    latitude: float = np.nan
    longitude: float = np.nan
    altitude: float = np.nan
    speed: float = np.nan
    bearing: float = np.nan
    horizontal_accuracy: float = np.nan
    vertical_accuracy: float = np.nan
    speed_accuracy: float = np.nan
    bearing_accuracy: float = np.nan

    def update_timestamps(self, time_delta: float):
        &#34;&#34;&#34;
        adds the time_delta to the location&#39;s timestamps; use negative values to go backwards in time
        :param time_delta: time to add to location&#39;s timestamps
        &#34;&#34;&#34;
        self.lat_lon_timestamp += time_delta
        self.altitude_timestamp += time_delta
        self.speed_timestamp += time_delta
        self.bearing_timestamp += time_delta

    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: True if there is no lat_lon_timestamp
        &#34;&#34;&#34;
        return np.isnan(self.lat_lon_timestamp)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.station_utils.StationLocation.altitude"><code class="name">var <span class="ident">altitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.altitude_timestamp"><code class="name">var <span class="ident">altitude_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.bearing"><code class="name">var <span class="ident">bearing</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.bearing_accuracy"><code class="name">var <span class="ident">bearing_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.bearing_timestamp"><code class="name">var <span class="ident">bearing_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.horizontal_accuracy"><code class="name">var <span class="ident">horizontal_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.lat_lon_timestamp"><code class="name">var <span class="ident">lat_lon_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.latitude"><code class="name">var <span class="ident">latitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.longitude"><code class="name">var <span class="ident">longitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.provider"><code class="name">var <span class="ident">provider</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.score"><code class="name">var <span class="ident">score</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.speed"><code class="name">var <span class="ident">speed</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.speed_accuracy"><code class="name">var <span class="ident">speed_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.speed_timestamp"><code class="name">var <span class="ident">speed_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationLocation.vertical_accuracy"><code class="name">var <span class="ident">vertical_accuracy</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.station_utils.StationLocation.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True if there is no lat_lon_timestamp</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self) -&gt; bool:
    &#34;&#34;&#34;
    :return: True if there is no lat_lon_timestamp
    &#34;&#34;&#34;
    return np.isnan(self.lat_lon_timestamp)</code></pre>
</details>
</dd>
<dt id="redvox.common.station_utils.StationLocation.update_timestamps"><code class="name flex">
<span>def <span class="ident">update_timestamps</span></span>(<span>self, time_delta: float)</span>
</code></dt>
<dd>
<div class="desc"><p>adds the time_delta to the location's timestamps; use negative values to go backwards in time
:param time_delta: time to add to location's timestamps</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_timestamps(self, time_delta: float):
    &#34;&#34;&#34;
    adds the time_delta to the location&#39;s timestamps; use negative values to go backwards in time
    :param time_delta: time to add to location&#39;s timestamps
    &#34;&#34;&#34;
    self.lat_lon_timestamp += time_delta
    self.altitude_timestamp += time_delta
    self.speed_timestamp += time_delta
    self.bearing_timestamp += time_delta</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.station_utils.StationMetadata"><code class="flex name class">
<span>class <span class="ident">StationMetadata</span></span>
<span>(</span><span>station_id: str, station_make: str, station_model: str, station_timing_is_corrected: bool = False, station_os: typing.Optional[str] = None, station_os_version: typing.Optional[str] = None, station_app: typing.Optional[str] = None, station_app_version: typing.Optional[str] = None, is_mic_scrambled: typing.Optional[bool] = False, timing_data: typing.Optional[<a title="redvox.common.station_utils.StationTiming" href="#redvox.common.station_utils.StationTiming">StationTiming</a>] = None, station_calib: typing.Optional[float] = None, station_network_name: typing.Optional[str] = None, station_name: typing.Optional[str] = None, station_location_name: typing.Optional[str] = None, station_channel_name: typing.Optional[str] = None, station_channel_encoding: typing.Optional[str] = None, station_uuid: typing.Optional[str] = None, location_data: typing.Optional[<a title="redvox.common.station_utils.LocationData" href="#redvox.common.station_utils.LocationData">LocationData</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic StationMetadata class for API-independent analysis</p>
<h2 id="properties">Properties</h2>
<p>station_id: str, id of the station
station_make: str, maker of the station
station_model: str, model of the station
station_timing_is_corrected: bool, if True, the station's timestamps have been altered from their raw values
default False
station_os: optional str, operating system of the station, default None
station_os_version: optional str, station OS version, default None
station_app: optional str, the name of the recording software used by the station, default None
station_app_version: optional str, the recording software version, default None
is_mic_scrambled: optional bool, True if mic data is scrambled, default False
timing_data: optional StationTiming metadata, default None
station_calib: optional float, station calibration value, default None
station_network_name: optional str, name/code of network station belongs to, default None
station_name: optional str, name/code of station, default None
station_location_name: optional str, name/code of location station is at, default None
station_channel_name: optional str, name/code of channel station is recording, default None
station_channel_encoding: optional str, name/code of channel encoding method, default None
station_uuid: optional str, uuid of the station, default is the same value as station_id
best_location: optional StationLocation metadata, default empty LocationData</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class StationMetadata:
    &#34;&#34;&#34;
    Generic StationMetadata class for API-independent analysis
    Properties:
        station_id: str, id of the station
        station_make: str, maker of the station
        station_model: str, model of the station
        station_timing_is_corrected: bool, if True, the station&#39;s timestamps have been altered from their raw values
                                        default False
        station_os: optional str, operating system of the station, default None
        station_os_version: optional str, station OS version, default None
        station_app: optional str, the name of the recording software used by the station, default None
        station_app_version: optional str, the recording software version, default None
        is_mic_scrambled: optional bool, True if mic data is scrambled, default False
        timing_data: optional StationTiming metadata, default None
        station_calib: optional float, station calibration value, default None
        station_network_name: optional str, name/code of network station belongs to, default None
        station_name: optional str, name/code of station, default None
        station_location_name: optional str, name/code of location station is at, default None
        station_channel_name: optional str, name/code of channel station is recording, default None
        station_channel_encoding: optional str, name/code of channel encoding method, default None
        station_uuid: optional str, uuid of the station, default is the same value as station_id
        best_location: optional StationLocation metadata, default empty LocationData
    &#34;&#34;&#34;
    station_id: str
    station_make: str
    station_model: str
    station_timing_is_corrected: bool = False
    station_os: Optional[str] = None
    station_os_version: Optional[str] = None
    station_app: Optional[str] = None
    station_app_version: Optional[str] = None
    is_mic_scrambled: Optional[bool] = False
    timing_data: Optional[StationTiming] = None
    station_calib: Optional[float] = None
    station_network_name: Optional[str] = None
    station_name: Optional[str] = None
    station_location_name: Optional[str] = None
    station_channel_name: Optional[str] = None
    station_channel_encoding: Optional[str] = None
    station_uuid: Optional[str] = None
    location_data: Optional[LocationData] = None

    def __post_init__(self):
        &#34;&#34;&#34;
        if the station_uuid is None, set it to be station_id
        if the location data is None, set it to empty LocationData
        &#34;&#34;&#34;
        if not self.station_uuid:
            self.station_uuid = self.station_id
        if not self.location_data:
            self.location_data = LocationData()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.station_utils.StationMetadata.is_mic_scrambled"><code class="name">var <span class="ident">is_mic_scrambled</span> : typing.Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.location_data"><code class="name">var <span class="ident">location_data</span> : typing.Optional[<a title="redvox.common.station_utils.LocationData" href="#redvox.common.station_utils.LocationData">LocationData</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_app"><code class="name">var <span class="ident">station_app</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_app_version"><code class="name">var <span class="ident">station_app_version</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_calib"><code class="name">var <span class="ident">station_calib</span> : typing.Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_channel_encoding"><code class="name">var <span class="ident">station_channel_encoding</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_channel_name"><code class="name">var <span class="ident">station_channel_name</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_id"><code class="name">var <span class="ident">station_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_location_name"><code class="name">var <span class="ident">station_location_name</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_make"><code class="name">var <span class="ident">station_make</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_model"><code class="name">var <span class="ident">station_model</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_name"><code class="name">var <span class="ident">station_name</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_network_name"><code class="name">var <span class="ident">station_network_name</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_os"><code class="name">var <span class="ident">station_os</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_os_version"><code class="name">var <span class="ident">station_os_version</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_timing_is_corrected"><code class="name">var <span class="ident">station_timing_is_corrected</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.station_uuid"><code class="name">var <span class="ident">station_uuid</span> : typing.Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationMetadata.timing_data"><code class="name">var <span class="ident">timing_data</span> : typing.Optional[<a title="redvox.common.station_utils.StationTiming" href="#redvox.common.station_utils.StationTiming">StationTiming</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="redvox.common.station_utils.StationTiming"><code class="flex name class">
<span>class <span class="ident">StationTiming</span></span>
<span>(</span><span>station_start_timestamp: float, audio_sample_rate_hz: float, station_first_data_timestamp: float, episode_start_timestamp_s: float = nan, episode_end_timestamp_s: float = nan, station_best_latency: float = nan, station_best_offset: float = 0.0, station_mean_offset: float = 0.0, station_std_offset: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic StationTiming class for API-independent analysis</p>
<h2 id="properties">Properties</h2>
<p>station_start_timestamp: float, timestamp when station started recording
audio_sample_rate_hz: float, sample rate in hz of audio sensor
station_first_data_timestamp: float, first timestamp chronologically of the data
episode_start_timestamp_s: float, timestamp of start of segment of interest in seconds since epoch UTC,
default np.nan
episode_end_timestamp_s: float, timestamp of end of segment of interest in seconds since epoch UTC,
default np.nan
station_best_latency: float, best latency of data, default np.nan
station_best_offset: float, best offset of data, default 0.0
station_mean_offset: float, mean offset of data, default 0.0
station_std_offset: float, std dev of offset of data, default 0.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class StationTiming:
    &#34;&#34;&#34;
    Generic StationTiming class for API-independent analysis
    Properties:
        station_start_timestamp: float, timestamp when station started recording
        audio_sample_rate_hz: float, sample rate in hz of audio sensor
        station_first_data_timestamp: float, first timestamp chronologically of the data
        episode_start_timestamp_s: float, timestamp of start of segment of interest in seconds since epoch UTC,
                                    default np.nan
        episode_end_timestamp_s: float, timestamp of end of segment of interest in seconds since epoch UTC,
                                    default np.nan
        station_best_latency: float, best latency of data, default np.nan
        station_best_offset: float, best offset of data, default 0.0
        station_mean_offset: float, mean offset of data, default 0.0
        station_std_offset: float, std dev of offset of data, default 0.0
    &#34;&#34;&#34;
    station_start_timestamp: float
    audio_sample_rate_hz: float
    station_first_data_timestamp: float
    episode_start_timestamp_s: float = np.nan
    episode_end_timestamp_s: float = np.nan
    station_best_latency: float = np.nan
    station_best_offset: float = 0.0
    station_mean_offset: float = 0.0
    station_std_offset: float = 0.0</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.station_utils.StationTiming.audio_sample_rate_hz"><code class="name">var <span class="ident">audio_sample_rate_hz</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationTiming.episode_end_timestamp_s"><code class="name">var <span class="ident">episode_end_timestamp_s</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationTiming.episode_start_timestamp_s"><code class="name">var <span class="ident">episode_start_timestamp_s</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationTiming.station_best_latency"><code class="name">var <span class="ident">station_best_latency</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationTiming.station_best_offset"><code class="name">var <span class="ident">station_best_offset</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationTiming.station_first_data_timestamp"><code class="name">var <span class="ident">station_first_data_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationTiming.station_mean_offset"><code class="name">var <span class="ident">station_mean_offset</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationTiming.station_start_timestamp"><code class="name">var <span class="ident">station_start_timestamp</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.station_utils.StationTiming.station_std_offset"><code class="name">var <span class="ident">station_std_offset</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="redvox.common.station_utils.TimeSyncData"><code class="flex name class">
<span>class <span class="ident">TimeSyncData</span></span>
<span>(</span><span>timesync_data: <built-in function array> = array([], dtype=float64), best_latency: float = nan, best_offset: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic TimeSync object for packets</p>
<h2 id="properties">Properties</h2>
<p>timesync_data: dataframe of the timestamps of the sync exchanges, default empty dataframe
Must be a multiple of 6 elements long.
best_latency: float, best latency of the time sync exchanges, default np.nan
best_offset: float, best offset of the time sync exchanges, default 0.0</p>
<p>initialize the TimeSyncData object
:param timesync_data: np.array of the timestamps of the sync exchanges, default empty np.array
Must be a multiple of 6 elements long.
May be 1 dimension, in which case will be converted into a 2-d np.ndarray
:param best_latency: float, best latency of the time sync exchanges, default np.nan
:param best_offset: float, best offset of the time sync exchanges, default 0.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeSyncData:
    &#34;&#34;&#34;
    Generic TimeSync object for packets
    Properties:
        timesync_data: dataframe of the timestamps of the sync exchanges, default empty dataframe
                                Must be a multiple of 6 elements long.
        best_latency: float, best latency of the time sync exchanges, default np.nan
        best_offset: float, best offset of the time sync exchanges, default 0.0
    &#34;&#34;&#34;
    def __init__(self, timesync_data: np.array = np.array([]),
                 best_latency: float = np.nan, best_offset: float = 0.0):
        &#34;&#34;&#34;
        initialize the TimeSyncData object
        :param timesync_data: np.array of the timestamps of the sync exchanges, default empty np.array
                                Must be a multiple of 6 elements long.
                                May be 1 dimension, in which case will be converted into a 2-d np.ndarray
        :param best_latency: float, best latency of the time sync exchanges, default np.nan
        :param best_offset: float, best offset of the time sync exchanges, default 0.0
        &#34;&#34;&#34;
        if len(timesync_data) &gt; 0 and len(timesync_data.shape) != 2:
            timesync_data = np.transpose(tms.transmit_receive_timestamps_microsec(timesync_data))
        elif len(timesync_data) == 0:
            timesync_data = []
        self.timesync_data = pd.DataFrame(timesync_data, columns=[&#34;a1&#34;, &#34;a2&#34;, &#34;a3&#34;, &#34;b1&#34;, &#34;b2&#34;, &#34;b3&#34;])
        self.best_latency = best_latency
        self.best_offset = best_offset

    def num_samples(self) -&gt; int:
        &#34;&#34;&#34;
        :return: the number of time sync exchanges, which are the rows in the dataframe
        &#34;&#34;&#34;
        return self.timesync_data.shape[0]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.station_utils.TimeSyncData.num_samples"><code class="name flex">
<span>def <span class="ident">num_samples</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the number of time sync exchanges, which are the rows in the dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_samples(self) -&gt; int:
    &#34;&#34;&#34;
    :return: the number of time sync exchanges, which are the rows in the dataframe
    &#34;&#34;&#34;
    return self.timesync_data.shape[0]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.common.station_utils.station_location_from_data" href="#redvox.common.station_utils.station_location_from_data">station_location_from_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.common.station_utils.DataPacket" href="#redvox.common.station_utils.DataPacket">DataPacket</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.station_utils.DataPacket.app_start_timestamp" href="#redvox.common.station_utils.DataPacket.app_start_timestamp">app_start_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.DataPacket.best_location" href="#redvox.common.station_utils.DataPacket.best_location">best_location</a></code></li>
<li><code><a title="redvox.common.station_utils.DataPacket.data_end_timestamp" href="#redvox.common.station_utils.DataPacket.data_end_timestamp">data_end_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.DataPacket.data_start_timestamp" href="#redvox.common.station_utils.DataPacket.data_start_timestamp">data_start_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.DataPacket.duration_s" href="#redvox.common.station_utils.DataPacket.duration_s">duration_s</a></code></li>
<li><code><a title="redvox.common.station_utils.DataPacket.expected_sample_interval_s" href="#redvox.common.station_utils.DataPacket.expected_sample_interval_s">expected_sample_interval_s</a></code></li>
<li><code><a title="redvox.common.station_utils.DataPacket.micros_to_next_packet" href="#redvox.common.station_utils.DataPacket.micros_to_next_packet">micros_to_next_packet</a></code></li>
<li><code><a title="redvox.common.station_utils.DataPacket.num_audio_samples" href="#redvox.common.station_utils.DataPacket.num_audio_samples">num_audio_samples</a></code></li>
<li><code><a title="redvox.common.station_utils.DataPacket.server_timestamp" href="#redvox.common.station_utils.DataPacket.server_timestamp">server_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.DataPacket.timesync" href="#redvox.common.station_utils.DataPacket.timesync">timesync</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.station_utils.LocationData" href="#redvox.common.station_utils.LocationData">LocationData</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.station_utils.LocationData.all_locations" href="#redvox.common.station_utils.LocationData.all_locations">all_locations</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.best_location" href="#redvox.common.station_utils.LocationData.best_location">best_location</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.calc_mean_and_std_from_locations" href="#redvox.common.station_utils.LocationData.calc_mean_and_std_from_locations">calc_mean_and_std_from_locations</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.get_sorted_all_locations" href="#redvox.common.station_utils.LocationData.get_sorted_all_locations">get_sorted_all_locations</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_altitude" href="#redvox.common.station_utils.LocationData.mean_altitude">mean_altitude</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_bearing" href="#redvox.common.station_utils.LocationData.mean_bearing">mean_bearing</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_bearing_accuracy" href="#redvox.common.station_utils.LocationData.mean_bearing_accuracy">mean_bearing_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_horizontal_accuracy" href="#redvox.common.station_utils.LocationData.mean_horizontal_accuracy">mean_horizontal_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_latitude" href="#redvox.common.station_utils.LocationData.mean_latitude">mean_latitude</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_longitude" href="#redvox.common.station_utils.LocationData.mean_longitude">mean_longitude</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_provider" href="#redvox.common.station_utils.LocationData.mean_provider">mean_provider</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_speed" href="#redvox.common.station_utils.LocationData.mean_speed">mean_speed</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_speed_accuracy" href="#redvox.common.station_utils.LocationData.mean_speed_accuracy">mean_speed_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.mean_vertical_accuracy" href="#redvox.common.station_utils.LocationData.mean_vertical_accuracy">mean_vertical_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.std_altitude" href="#redvox.common.station_utils.LocationData.std_altitude">std_altitude</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.std_bearing" href="#redvox.common.station_utils.LocationData.std_bearing">std_bearing</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.std_bearing_accuracy" href="#redvox.common.station_utils.LocationData.std_bearing_accuracy">std_bearing_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.std_horizontal_accuracy" href="#redvox.common.station_utils.LocationData.std_horizontal_accuracy">std_horizontal_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.std_latitude" href="#redvox.common.station_utils.LocationData.std_latitude">std_latitude</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.std_longitude" href="#redvox.common.station_utils.LocationData.std_longitude">std_longitude</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.std_speed" href="#redvox.common.station_utils.LocationData.std_speed">std_speed</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.std_speed_accuracy" href="#redvox.common.station_utils.LocationData.std_speed_accuracy">std_speed_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.std_vertical_accuracy" href="#redvox.common.station_utils.LocationData.std_vertical_accuracy">std_vertical_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.update_timestamps" href="#redvox.common.station_utils.LocationData.update_timestamps">update_timestamps</a></code></li>
<li><code><a title="redvox.common.station_utils.LocationData.update_window_locations" href="#redvox.common.station_utils.LocationData.update_window_locations">update_window_locations</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.station_utils.StationKey" href="#redvox.common.station_utils.StationKey">StationKey</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.station_utils.StationKey.get_key" href="#redvox.common.station_utils.StationKey.get_key">get_key</a></code></li>
<li><code><a title="redvox.common.station_utils.StationKey.id" href="#redvox.common.station_utils.StationKey.id">id</a></code></li>
<li><code><a title="redvox.common.station_utils.StationKey.start_timestamp_micros" href="#redvox.common.station_utils.StationKey.start_timestamp_micros">start_timestamp_micros</a></code></li>
<li><code><a title="redvox.common.station_utils.StationKey.uuid" href="#redvox.common.station_utils.StationKey.uuid">uuid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.station_utils.StationLocation" href="#redvox.common.station_utils.StationLocation">StationLocation</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.common.station_utils.StationLocation.altitude" href="#redvox.common.station_utils.StationLocation.altitude">altitude</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.altitude_timestamp" href="#redvox.common.station_utils.StationLocation.altitude_timestamp">altitude_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.bearing" href="#redvox.common.station_utils.StationLocation.bearing">bearing</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.bearing_accuracy" href="#redvox.common.station_utils.StationLocation.bearing_accuracy">bearing_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.bearing_timestamp" href="#redvox.common.station_utils.StationLocation.bearing_timestamp">bearing_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.horizontal_accuracy" href="#redvox.common.station_utils.StationLocation.horizontal_accuracy">horizontal_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.is_empty" href="#redvox.common.station_utils.StationLocation.is_empty">is_empty</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.lat_lon_timestamp" href="#redvox.common.station_utils.StationLocation.lat_lon_timestamp">lat_lon_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.latitude" href="#redvox.common.station_utils.StationLocation.latitude">latitude</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.longitude" href="#redvox.common.station_utils.StationLocation.longitude">longitude</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.provider" href="#redvox.common.station_utils.StationLocation.provider">provider</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.score" href="#redvox.common.station_utils.StationLocation.score">score</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.speed" href="#redvox.common.station_utils.StationLocation.speed">speed</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.speed_accuracy" href="#redvox.common.station_utils.StationLocation.speed_accuracy">speed_accuracy</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.speed_timestamp" href="#redvox.common.station_utils.StationLocation.speed_timestamp">speed_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.update_timestamps" href="#redvox.common.station_utils.StationLocation.update_timestamps">update_timestamps</a></code></li>
<li><code><a title="redvox.common.station_utils.StationLocation.vertical_accuracy" href="#redvox.common.station_utils.StationLocation.vertical_accuracy">vertical_accuracy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.station_utils.StationMetadata" href="#redvox.common.station_utils.StationMetadata">StationMetadata</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.station_utils.StationMetadata.is_mic_scrambled" href="#redvox.common.station_utils.StationMetadata.is_mic_scrambled">is_mic_scrambled</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.location_data" href="#redvox.common.station_utils.StationMetadata.location_data">location_data</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_app" href="#redvox.common.station_utils.StationMetadata.station_app">station_app</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_app_version" href="#redvox.common.station_utils.StationMetadata.station_app_version">station_app_version</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_calib" href="#redvox.common.station_utils.StationMetadata.station_calib">station_calib</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_channel_encoding" href="#redvox.common.station_utils.StationMetadata.station_channel_encoding">station_channel_encoding</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_channel_name" href="#redvox.common.station_utils.StationMetadata.station_channel_name">station_channel_name</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_id" href="#redvox.common.station_utils.StationMetadata.station_id">station_id</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_location_name" href="#redvox.common.station_utils.StationMetadata.station_location_name">station_location_name</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_make" href="#redvox.common.station_utils.StationMetadata.station_make">station_make</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_model" href="#redvox.common.station_utils.StationMetadata.station_model">station_model</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_name" href="#redvox.common.station_utils.StationMetadata.station_name">station_name</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_network_name" href="#redvox.common.station_utils.StationMetadata.station_network_name">station_network_name</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_os" href="#redvox.common.station_utils.StationMetadata.station_os">station_os</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_os_version" href="#redvox.common.station_utils.StationMetadata.station_os_version">station_os_version</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_timing_is_corrected" href="#redvox.common.station_utils.StationMetadata.station_timing_is_corrected">station_timing_is_corrected</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.station_uuid" href="#redvox.common.station_utils.StationMetadata.station_uuid">station_uuid</a></code></li>
<li><code><a title="redvox.common.station_utils.StationMetadata.timing_data" href="#redvox.common.station_utils.StationMetadata.timing_data">timing_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.station_utils.StationTiming" href="#redvox.common.station_utils.StationTiming">StationTiming</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.station_utils.StationTiming.audio_sample_rate_hz" href="#redvox.common.station_utils.StationTiming.audio_sample_rate_hz">audio_sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.station_utils.StationTiming.episode_end_timestamp_s" href="#redvox.common.station_utils.StationTiming.episode_end_timestamp_s">episode_end_timestamp_s</a></code></li>
<li><code><a title="redvox.common.station_utils.StationTiming.episode_start_timestamp_s" href="#redvox.common.station_utils.StationTiming.episode_start_timestamp_s">episode_start_timestamp_s</a></code></li>
<li><code><a title="redvox.common.station_utils.StationTiming.station_best_latency" href="#redvox.common.station_utils.StationTiming.station_best_latency">station_best_latency</a></code></li>
<li><code><a title="redvox.common.station_utils.StationTiming.station_best_offset" href="#redvox.common.station_utils.StationTiming.station_best_offset">station_best_offset</a></code></li>
<li><code><a title="redvox.common.station_utils.StationTiming.station_first_data_timestamp" href="#redvox.common.station_utils.StationTiming.station_first_data_timestamp">station_first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.StationTiming.station_mean_offset" href="#redvox.common.station_utils.StationTiming.station_mean_offset">station_mean_offset</a></code></li>
<li><code><a title="redvox.common.station_utils.StationTiming.station_start_timestamp" href="#redvox.common.station_utils.StationTiming.station_start_timestamp">station_start_timestamp</a></code></li>
<li><code><a title="redvox.common.station_utils.StationTiming.station_std_offset" href="#redvox.common.station_utils.StationTiming.station_std_offset">station_std_offset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.station_utils.TimeSyncData" href="#redvox.common.station_utils.TimeSyncData">TimeSyncData</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.station_utils.TimeSyncData.num_samples" href="#redvox.common.station_utils.TimeSyncData.num_samples">num_samples</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>