<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>redvox.api1000.io_raw API documentation</title>
<meta name="description" content="This module provides low level aggregate read functionality for RedVox API M data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.api1000.io_raw</code></h1>
</header>
<section id="section-intro">
<p>This module provides low level aggregate read functionality for RedVox API M data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides low level aggregate read functionality for RedVox API M data.
&#34;&#34;&#34;

from collections import defaultdict
from datetime import datetime, timedelta
from dataclasses import dataclass
from functools import reduce
from glob import glob
from multiprocessing import Pool
import os.path
from pathlib import Path
from typing import Dict, Iterator, List, Optional, Set

from redvox.common.date_time_utils import datetime_from_epoch_microseconds_utc as dt_us
from redvox.api1000.common.lz4 import decompress
import redvox.api1000.proto.redvox_api_m_pb2 as pb
from redvox.api1000.wrapped_redvox_packet.station_information import OsType
from redvox.api1000.wrapped_redvox_packet.wrapped_packet import WrappedRedvoxPacketM


# noinspection DuplicatedCode
@dataclass
class StationSummary:
    &#34;&#34;&#34;
    Contains a summary of each stations data read result.
    &#34;&#34;&#34;
    station_id: str
    station_uuid: str
    auth_id: str
    os: OsType
    os_version: str
    app_version: str
    audio_sampling_rate: float
    total_packets: int
    total_duration: timedelta
    start_dt: datetime
    end_dt: datetime

    @staticmethod
    def from_packets(packets: List[WrappedRedvoxPacketM]) -&gt; &#39;StationSummary&#39;:
        first_packet: WrappedRedvoxPacketM = packets[0]
        last_packet: WrappedRedvoxPacketM = packets[-1]
        total_duration: timedelta = reduce(lambda acc, packet: acc + packet.get_packet_duration(),
                                           packets,
                                           timedelta(seconds=0.0))
        start_dt: datetime = dt_us(first_packet.get_timing_information().get_packet_start_mach_timestamp())
        end_dt: datetime = dt_us(last_packet.get_timing_information().get_packet_start_mach_timestamp()) + \
                           last_packet.get_packet_duration()

        station_info = first_packet.get_station_information()
        audio = first_packet.get_sensors().get_audio()
        return StationSummary(
            station_info.get_id(),
            station_info.get_uuid(),
            station_info.get_auth_id(),
            station_info.get_os(),
            station_info.get_os_version(),
            station_info.get_app_version(),
            audio.get_sample_rate() if audio is not None else float(&#34;NaN&#34;),
            len(packets),
            total_duration,
            start_dt,
            end_dt
        )


@dataclass
class ReadFilter:
    &#34;&#34;&#34;
    Filter API M files from the file system.
    &#34;&#34;&#34;
    start_dt: Optional[datetime] = None
    end_dt: Optional[datetime] = None
    station_ids: Optional[Set[str]] = None
    extension: str = &#34;.rdvxm&#34;

    def with_start_dt(self, start_dt: datetime) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Adds a start datetime filter.
        :param start_dt: Start datetime that files should come after.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        self.start_dt = start_dt
        return self

    def with_start_ts(self, start_ts: float) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Adds a start time filter.
        :param start_ts: Start timestamp (microseconds)
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        return self.with_start_dt(dt_us(start_ts))

    def with_end_dt(self, end_dt: datetime) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Adds an end datetime filter.
        :param end_dt: Filter for which packets should come before.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        self.end_dt = end_dt
        return self

    def with_end_ts(self, end_ts: float) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Like with_end_dt, but uses a microsecond timestamp.
        :param end_ts: Timestamp microseconds.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        return self.with_end_dt(dt_us(end_ts))

    def with_station_ids(self, station_ids: Set[str]) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Add a station id filter. Filters against provided station ids.
        :param station_ids: Station ids to filter against.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        self.station_ids = station_ids
        return self

    def with_extension(self, extension: str) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Filters against a known file extension.
        :param extension: Extension to filter against
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        self.extension = extension
        return self

    def filter_dt(self, dt: datetime) -&gt; bool:
        &#34;&#34;&#34;
        Tests if a given datetime passes this filter.
        :param dt: Datetime to test
        :return: True if the datetime is included, False otherwise
        &#34;&#34;&#34;
        if self.start_dt is not None and dt &lt; self.start_dt:
            return False

        if self.end_dt is not None and dt &gt; self.end_dt:
            return False

        return True

    def filter_path(self, path: str) -&gt; bool:
        &#34;&#34;&#34;
        Tests a given file system path against this filter.
        :param path: Path to test.
        :return: True if the path is accepted, False otherwise
        &#34;&#34;&#34;
        _path: Path = Path(path)
        ext: str = &#34;&#34;.join(_path.suffixes)
        station_ts: str = _path.stem
        split: List[str] = station_ts.split(&#34;_&#34;)
        station_id: str = split[0]
        ts: float = float(split[1])
        dt: datetime = dt_us(ts)

        if not self.filter_dt(dt):
            return False

        if self.station_ids is not None and station_id not in self.station_ids:
            return False

        if self.extension is not None and self.extension != ext:
            return False

        return True


class ReadResult:
    &#34;&#34;&#34;
    Result of reading multiple API M files.
    &#34;&#34;&#34;

    def __init__(self,
                 station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]]):
        &#34;&#34;&#34;
        :param station_id_uuid_to_packets: station_id:station_uuid -&gt; packets
        &#34;&#34;&#34;
        self.station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = station_id_uuid_to_packets
        self.__station_id_to_id_uuid: Dict[str, str] = {}
        self.__station_summaries: List[StationSummary] = []

        for id_uuid, packets in self.station_id_uuid_to_packets.items():
            s: List[str] = id_uuid.split(&#34;:&#34;)
            self.__station_id_to_id_uuid[s[0]] = id_uuid
            self.__station_summaries.append(StationSummary.from_packets(packets))

    @staticmethod
    def from_packets(packets: List[WrappedRedvoxPacketM]) -&gt; &#39;ReadResult&#39;:
        &#34;&#34;&#34;
        Constructs a read result from the provided packets.
        :param packets: Packets to construct read result from.
        :return: ReadResult from provided packets
        &#34;&#34;&#34;
        station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = defaultdict(list)

        for packet in packets:
            station_info = packet.get_station_information()
            station_id: str = station_info.get_id()
            station_uuid: str = station_info.get_uuid()
            id_uuid: str = f&#34;{station_id}:{station_uuid}&#34;
            station_id_uuid_to_packets[id_uuid].append(packet)

        return ReadResult(station_id_uuid_to_packets)

    def __get_packets_for_station_id_uuid(self, station_id_uuid) -&gt; List[WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        Find packets given a station_id:uuid.
        :param station_id_uuid: Station id and uuid to get packets for.
        :return: A list of wrapped packets or an empty list if none match.
        &#34;&#34;&#34;
        if station_id_uuid in self.station_id_uuid_to_packets:
            return self.station_id_uuid_to_packets[station_id_uuid]

        return []

    def __get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        Get packets for an associated station id.
        :param station_id: The station id.
        :return: A list of wrapped packets or an empty list if none provided.
        &#34;&#34;&#34;
        if station_id in self.__station_id_to_id_uuid:
            return self.__get_packets_for_station_id_uuid(self.__station_id_to_id_uuid[station_id])

        return []

    def get_station_summaries(self) -&gt; List[StationSummary]:
        &#34;&#34;&#34;
        :return: A list of StationSummaries contained in this ReadResult
        &#34;&#34;&#34;
        return self.__station_summaries

    def get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        Gets packets either for the provided station_id or the provided station_id:uuid.
        :param station_id: station_id or station_id:uuid to get packets for.
        :return: A list of packets of an empty list of none provided.
        &#34;&#34;&#34;
        if &#34;:&#34; in station_id:
            return self.__get_packets_for_station_id_uuid(station_id)
        else:
            return self.__get_packets_for_station_id(station_id)


# We need to parse the API M structured directory structure. Here, we enumerate the valid values for the various
# levels in the hierarchy.
__VALID_YEARS: Set[str] = {f&#34;{i:04}&#34; for i in range(2018, 2031)}
__VALID_MONTHS: Set[str] = {f&#34;{i:02}&#34; for i in range(1, 13)}
__VALID_DATES: Set[str] = {f&#34;{i:02}&#34; for i in range(1, 32)}
__VALID_HOURS: Set[str] = {f&#34;{i:02}&#34; for i in range(0, 24)}


def __deserialize_path(path: str):
    with open(path, &#34;rb&#34;) as fin:
        buf: bytes = fin.read()
        debuf: bytes = decompress(buf)
        proto: pb.RedvoxPacketM = pb.RedvoxPacketM()
        proto.ParseFromString(debuf)
        return proto


def __deserialize_paths(paths: List[str], parallel: bool = False) -&gt; List[WrappedRedvoxPacketM]:
    &#34;&#34;&#34;
    Deserialize a list of paths into a list of WrappedRedvoxPacketMs
    :param paths: Paths to deserialize
    :param parallel: If True, a process pool is used to perform all decompression and deserialization. After
                     decompression and deserialization, wrapping takes place in the original process. If False,
                     decompression, deserialization, and wrapping take place in the original process serially.

    :return: A list of WrappedRedvoxPacketMs.
    &#34;&#34;&#34;
    if parallel:
        pool = Pool()
        deserialized = list(pool.map(__deserialize_path, paths))
        return sorted(list(map(lambda de: WrappedRedvoxPacketM(de), deserialized)))
    else:
        return sorted(list(map(WrappedRedvoxPacketM.from_compressed_path, paths)))


def __list_subdirs(base_dir: str, valid_choices: Set[str]) -&gt; List[str]:
    &#34;&#34;&#34;
    Lists sub-directors in a given base directory that match the provided choices.
    :param base_dir: Base dir to find sub dirs in.
    :param valid_choices: A list of valid directory names.
    :return: A list of valid subdirs.
    &#34;&#34;&#34;
    subdirs: Iterator[str] = map(lambda p: Path(p).name, glob(os.path.join(base_dir, &#34;*&#34;, &#34;&#34;)))
    return sorted(list(filter(valid_choices.__contains__, subdirs)))


def __parse_structured_layout(base_dir: str,
                              read_filter: ReadFilter = ReadFilter()) -&gt; List[str]:
    &#34;&#34;&#34;
    This parses a structured API M directory structure and identifies files that match the provided filter.
    :param base_dir: Base directory (should be named api1000)
    :param read_filter: Filter to filter files with
    :return: A list of wrapped packets on an empty list if none match the filter or none are found
    &#34;&#34;&#34;
    all_paths: List[str] = []
    for year in __list_subdirs(base_dir, __VALID_YEARS):
        for month in __list_subdirs(os.path.join(base_dir, year), __VALID_MONTHS):
            for day in __list_subdirs(os.path.join(base_dir, year, month), __VALID_DATES):
                for hour in __list_subdirs(os.path.join(base_dir, year, month, day), __VALID_HOURS):
                    # Before scanning for *.rdvxm files, let&#39;s see if the current year, month, day, hour are in the
                    # filter&#39;s range. If not, we can short circuit and skip getting the *.rdvxm files.
                    if not read_filter.filter_dt(datetime(int(year),
                                                          int(month),
                                                          int(day),
                                                          int(hour))):
                        continue

                    paths: List[str] = glob(os.path.join(base_dir,
                                                         year,
                                                         month,
                                                         day,
                                                         hour,
                                                         f&#34;*{read_filter.extension}&#34;))
                    # Filer paths that match the predicate
                    valid_paths: List[str] = list(filter(lambda path: read_filter.filter_path(path), paths))
                    if len(valid_paths) &gt; 0:
                        all_paths.extend(valid_paths)

    return all_paths


def read_bufs(bufs: List[bytes]) -&gt; ReadResult:
    &#34;&#34;&#34;
    Reads a list of API M packet buffers.
    :param bufs: Buffers to read.
    :return: A ReadResult of the read data.
    &#34;&#34;&#34;
    wrapped_packets: List[WrappedRedvoxPacketM] = list(sorted(map(WrappedRedvoxPacketM.from_compressed_bytes, bufs)))
    return ReadResult.from_packets(wrapped_packets)


def read_structured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; ReadResult:
    &#34;&#34;&#34;
    Read structured API M data. Structured API data is stored using the following directory hierarchy.
        api1000/[YYYY]/[MM]/[DD]/[HH]/*.rdvxm
    :param base_dir: Base directory of structured data (should be named api1000)
    :param read_filter: Filter to apply to files.
    :return: A ReadResult
    &#34;&#34;&#34;
    paths: List[str] = __parse_structured_layout(base_dir, read_filter)
    wrapped_packets: List[WrappedRedvoxPacketM] = __deserialize_paths(paths)
    return ReadResult.from_packets(wrapped_packets)


def read_unstructured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; ReadResult:
    &#34;&#34;&#34;
    Reads RedVox files from a provided directory.
    :param base_dir: Directory to read files from.
    :param read_filter: Filter to filter files with.
    :return: A ReadResult.
    &#34;&#34;&#34;
    pattern: str = os.path.join(base_dir, f&#34;*{read_filter.extension}&#34;)
    paths: List[str] = glob(os.path.join(base_dir, pattern))
    paths = list(filter(lambda path: read_filter.filter_path(path), paths))
    wrapped_packets: List[WrappedRedvoxPacketM] = __deserialize_paths(paths)
    return ReadResult.from_packets(wrapped_packets)


def stream_structured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; Iterator[WrappedRedvoxPacketM]:
    &#34;&#34;&#34;
    Lazily loads API M data from a structured layout.
    :param base_dir: Directory to read files from.
    :param read_filter: Filter to filter files with.
    :return: An iterator that reads and loads one WrappedRedvoxPacketM at a time.
    &#34;&#34;&#34;
    paths: List[str] = __parse_structured_layout(base_dir, read_filter)

    for path in paths:
        yield WrappedRedvoxPacketM.from_compressed_path(path)


def stream_unstructured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; Iterator[WrappedRedvoxPacketM]:
    &#34;&#34;&#34;
    Lazily loads API M data from an unstructured layout.
    :param base_dir: Directory to read files from.
    :param read_filter: Filter to filter files with.
    :return: An iterator that reads and loads one WrappedRedvoxPacketM at a time.
    &#34;&#34;&#34;
    pattern: str = os.path.join(base_dir, f&#34;*{read_filter.extension}&#34;)
    paths: List[str] = glob(os.path.join(base_dir, pattern))
    paths = list(filter(lambda path: read_filter.filter_path(path), paths))

    for path in paths:
        yield WrappedRedvoxPacketM.from_compressed_path(path)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.api1000.io_raw.read_bufs"><code class="name flex">
<span>def <span class="ident">read_bufs</span></span>(<span>bufs: typing.List[bytes]) ‑> <a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Reads a list of API M packet buffers.
:param bufs: Buffers to read.
:return: A ReadResult of the read data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_bufs(bufs: List[bytes]) -&gt; ReadResult:
    &#34;&#34;&#34;
    Reads a list of API M packet buffers.
    :param bufs: Buffers to read.
    :return: A ReadResult of the read data.
    &#34;&#34;&#34;
    wrapped_packets: List[WrappedRedvoxPacketM] = list(sorted(map(WrappedRedvoxPacketM.from_compressed_bytes, bufs)))
    return ReadResult.from_packets(wrapped_packets)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.read_structured"><code class="name flex">
<span>def <span class="ident">read_structured</span></span>(<span>base_dir: str, read_filter: <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extension='.rdvxm')) ‑> <a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Read structured API M data. Structured API data is stored using the following directory hierarchy.
api1000/[YYYY]/[MM]/[DD]/[HH]/*.rdvxm
:param base_dir: Base directory of structured data (should be named api1000)
:param read_filter: Filter to apply to files.
:return: A ReadResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_structured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; ReadResult:
    &#34;&#34;&#34;
    Read structured API M data. Structured API data is stored using the following directory hierarchy.
        api1000/[YYYY]/[MM]/[DD]/[HH]/*.rdvxm
    :param base_dir: Base directory of structured data (should be named api1000)
    :param read_filter: Filter to apply to files.
    :return: A ReadResult
    &#34;&#34;&#34;
    paths: List[str] = __parse_structured_layout(base_dir, read_filter)
    wrapped_packets: List[WrappedRedvoxPacketM] = __deserialize_paths(paths)
    return ReadResult.from_packets(wrapped_packets)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.read_unstructured"><code class="name flex">
<span>def <span class="ident">read_unstructured</span></span>(<span>base_dir: str, read_filter: <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extension='.rdvxm')) ‑> <a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Reads RedVox files from a provided directory.
:param base_dir: Directory to read files from.
:param read_filter: Filter to filter files with.
:return: A ReadResult.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_unstructured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; ReadResult:
    &#34;&#34;&#34;
    Reads RedVox files from a provided directory.
    :param base_dir: Directory to read files from.
    :param read_filter: Filter to filter files with.
    :return: A ReadResult.
    &#34;&#34;&#34;
    pattern: str = os.path.join(base_dir, f&#34;*{read_filter.extension}&#34;)
    paths: List[str] = glob(os.path.join(base_dir, pattern))
    paths = list(filter(lambda path: read_filter.filter_path(path), paths))
    wrapped_packets: List[WrappedRedvoxPacketM] = __deserialize_paths(paths)
    return ReadResult.from_packets(wrapped_packets)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.stream_structured"><code class="name flex">
<span>def <span class="ident">stream_structured</span></span>(<span>base_dir: str, read_filter: <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extension='.rdvxm')) ‑> typing.Iterator[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily loads API M data from a structured layout.
:param base_dir: Directory to read files from.
:param read_filter: Filter to filter files with.
:return: An iterator that reads and loads one WrappedRedvoxPacketM at a time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream_structured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; Iterator[WrappedRedvoxPacketM]:
    &#34;&#34;&#34;
    Lazily loads API M data from a structured layout.
    :param base_dir: Directory to read files from.
    :param read_filter: Filter to filter files with.
    :return: An iterator that reads and loads one WrappedRedvoxPacketM at a time.
    &#34;&#34;&#34;
    paths: List[str] = __parse_structured_layout(base_dir, read_filter)

    for path in paths:
        yield WrappedRedvoxPacketM.from_compressed_path(path)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.stream_unstructured"><code class="name flex">
<span>def <span class="ident">stream_unstructured</span></span>(<span>base_dir: str, read_filter: <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extension='.rdvxm')) ‑> typing.Iterator[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily loads API M data from an unstructured layout.
:param base_dir: Directory to read files from.
:param read_filter: Filter to filter files with.
:return: An iterator that reads and loads one WrappedRedvoxPacketM at a time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream_unstructured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; Iterator[WrappedRedvoxPacketM]:
    &#34;&#34;&#34;
    Lazily loads API M data from an unstructured layout.
    :param base_dir: Directory to read files from.
    :param read_filter: Filter to filter files with.
    :return: An iterator that reads and loads one WrappedRedvoxPacketM at a time.
    &#34;&#34;&#34;
    pattern: str = os.path.join(base_dir, f&#34;*{read_filter.extension}&#34;)
    paths: List[str] = glob(os.path.join(base_dir, pattern))
    paths = list(filter(lambda path: read_filter.filter_path(path), paths))

    for path in paths:
        yield WrappedRedvoxPacketM.from_compressed_path(path)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.api1000.io_raw.ReadFilter"><code class="flex name class">
<span>class <span class="ident">ReadFilter</span></span>
<span>(</span><span>start_dt: typing.Union[datetime.datetime, NoneType] = None, end_dt: typing.Union[datetime.datetime, NoneType] = None, station_ids: typing.Union[typing.Set[str], NoneType] = None, extension: str = '.rdvxm')</span>
</code></dt>
<dd>
<div class="desc"><p>Filter API M files from the file system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadFilter:
    &#34;&#34;&#34;
    Filter API M files from the file system.
    &#34;&#34;&#34;
    start_dt: Optional[datetime] = None
    end_dt: Optional[datetime] = None
    station_ids: Optional[Set[str]] = None
    extension: str = &#34;.rdvxm&#34;

    def with_start_dt(self, start_dt: datetime) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Adds a start datetime filter.
        :param start_dt: Start datetime that files should come after.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        self.start_dt = start_dt
        return self

    def with_start_ts(self, start_ts: float) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Adds a start time filter.
        :param start_ts: Start timestamp (microseconds)
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        return self.with_start_dt(dt_us(start_ts))

    def with_end_dt(self, end_dt: datetime) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Adds an end datetime filter.
        :param end_dt: Filter for which packets should come before.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        self.end_dt = end_dt
        return self

    def with_end_ts(self, end_ts: float) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Like with_end_dt, but uses a microsecond timestamp.
        :param end_ts: Timestamp microseconds.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        return self.with_end_dt(dt_us(end_ts))

    def with_station_ids(self, station_ids: Set[str]) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Add a station id filter. Filters against provided station ids.
        :param station_ids: Station ids to filter against.
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        self.station_ids = station_ids
        return self

    def with_extension(self, extension: str) -&gt; &#39;ReadFilter&#39;:
        &#34;&#34;&#34;
        Filters against a known file extension.
        :param extension: Extension to filter against
        :return: A modified instance of this filter
        &#34;&#34;&#34;
        self.extension = extension
        return self

    def filter_dt(self, dt: datetime) -&gt; bool:
        &#34;&#34;&#34;
        Tests if a given datetime passes this filter.
        :param dt: Datetime to test
        :return: True if the datetime is included, False otherwise
        &#34;&#34;&#34;
        if self.start_dt is not None and dt &lt; self.start_dt:
            return False

        if self.end_dt is not None and dt &gt; self.end_dt:
            return False

        return True

    def filter_path(self, path: str) -&gt; bool:
        &#34;&#34;&#34;
        Tests a given file system path against this filter.
        :param path: Path to test.
        :return: True if the path is accepted, False otherwise
        &#34;&#34;&#34;
        _path: Path = Path(path)
        ext: str = &#34;&#34;.join(_path.suffixes)
        station_ts: str = _path.stem
        split: List[str] = station_ts.split(&#34;_&#34;)
        station_id: str = split[0]
        ts: float = float(split[1])
        dt: datetime = dt_us(ts)

        if not self.filter_dt(dt):
            return False

        if self.station_ids is not None and station_id not in self.station_ids:
            return False

        if self.extension is not None and self.extension != ext:
            return False

        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.api1000.io_raw.ReadFilter.end_dt"><code class="name">var <span class="ident">end_dt</span> : typing.Union[datetime.datetime, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.extension"><code class="name">var <span class="ident">extension</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.start_dt"><code class="name">var <span class="ident">start_dt</span> : typing.Union[datetime.datetime, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.station_ids"><code class="name">var <span class="ident">station_ids</span> : typing.Union[typing.Set[str], NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.api1000.io_raw.ReadFilter.filter_dt"><code class="name flex">
<span>def <span class="ident">filter_dt</span></span>(<span>self, dt: datetime.datetime) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if a given datetime passes this filter.
:param dt: Datetime to test
:return: True if the datetime is included, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_dt(self, dt: datetime) -&gt; bool:
    &#34;&#34;&#34;
    Tests if a given datetime passes this filter.
    :param dt: Datetime to test
    :return: True if the datetime is included, False otherwise
    &#34;&#34;&#34;
    if self.start_dt is not None and dt &lt; self.start_dt:
        return False

    if self.end_dt is not None and dt &gt; self.end_dt:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.filter_path"><code class="name flex">
<span>def <span class="ident">filter_path</span></span>(<span>self, path: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests a given file system path against this filter.
:param path: Path to test.
:return: True if the path is accepted, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_path(self, path: str) -&gt; bool:
    &#34;&#34;&#34;
    Tests a given file system path against this filter.
    :param path: Path to test.
    :return: True if the path is accepted, False otherwise
    &#34;&#34;&#34;
    _path: Path = Path(path)
    ext: str = &#34;&#34;.join(_path.suffixes)
    station_ts: str = _path.stem
    split: List[str] = station_ts.split(&#34;_&#34;)
    station_id: str = split[0]
    ts: float = float(split[1])
    dt: datetime = dt_us(ts)

    if not self.filter_dt(dt):
        return False

    if self.station_ids is not None and station_id not in self.station_ids:
        return False

    if self.extension is not None and self.extension != ext:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_end_dt"><code class="name flex">
<span>def <span class="ident">with_end_dt</span></span>(<span>self, end_dt: datetime.datetime) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds an end datetime filter.
:param end_dt: Filter for which packets should come before.
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_end_dt(self, end_dt: datetime) -&gt; &#39;ReadFilter&#39;:
    &#34;&#34;&#34;
    Adds an end datetime filter.
    :param end_dt: Filter for which packets should come before.
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    self.end_dt = end_dt
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_end_ts"><code class="name flex">
<span>def <span class="ident">with_end_ts</span></span>(<span>self, end_ts: float) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Like with_end_dt, but uses a microsecond timestamp.
:param end_ts: Timestamp microseconds.
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_end_ts(self, end_ts: float) -&gt; &#39;ReadFilter&#39;:
    &#34;&#34;&#34;
    Like with_end_dt, but uses a microsecond timestamp.
    :param end_ts: Timestamp microseconds.
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    return self.with_end_dt(dt_us(end_ts))</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_extension"><code class="name flex">
<span>def <span class="ident">with_extension</span></span>(<span>self, extension: str) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Filters against a known file extension.
:param extension: Extension to filter against
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_extension(self, extension: str) -&gt; &#39;ReadFilter&#39;:
    &#34;&#34;&#34;
    Filters against a known file extension.
    :param extension: Extension to filter against
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    self.extension = extension
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_start_dt"><code class="name flex">
<span>def <span class="ident">with_start_dt</span></span>(<span>self, start_dt: datetime.datetime) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds a start datetime filter.
:param start_dt: Start datetime that files should come after.
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_start_dt(self, start_dt: datetime) -&gt; &#39;ReadFilter&#39;:
    &#34;&#34;&#34;
    Adds a start datetime filter.
    :param start_dt: Start datetime that files should come after.
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    self.start_dt = start_dt
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_start_ts"><code class="name flex">
<span>def <span class="ident">with_start_ts</span></span>(<span>self, start_ts: float) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds a start time filter.
:param start_ts: Start timestamp (microseconds)
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_start_ts(self, start_ts: float) -&gt; &#39;ReadFilter&#39;:
    &#34;&#34;&#34;
    Adds a start time filter.
    :param start_ts: Start timestamp (microseconds)
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    return self.with_start_dt(dt_us(start_ts))</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_station_ids"><code class="name flex">
<span>def <span class="ident">with_station_ids</span></span>(<span>self, station_ids: typing.Set[str]) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add a station id filter. Filters against provided station ids.
:param station_ids: Station ids to filter against.
:return: A modified instance of this filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_station_ids(self, station_ids: Set[str]) -&gt; &#39;ReadFilter&#39;:
    &#34;&#34;&#34;
    Add a station id filter. Filters against provided station ids.
    :param station_ids: Station ids to filter against.
    :return: A modified instance of this filter
    &#34;&#34;&#34;
    self.station_ids = station_ids
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.api1000.io_raw.ReadResult"><code class="flex name class">
<span>class <span class="ident">ReadResult</span></span>
<span>(</span><span>station_id_uuid_to_packets: typing.Dict[str, typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]])</span>
</code></dt>
<dd>
<div class="desc"><p>Result of reading multiple API M files.</p>
<p>:param station_id_uuid_to_packets: station_id:station_uuid -&gt; packets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadResult:
    &#34;&#34;&#34;
    Result of reading multiple API M files.
    &#34;&#34;&#34;

    def __init__(self,
                 station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]]):
        &#34;&#34;&#34;
        :param station_id_uuid_to_packets: station_id:station_uuid -&gt; packets
        &#34;&#34;&#34;
        self.station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = station_id_uuid_to_packets
        self.__station_id_to_id_uuid: Dict[str, str] = {}
        self.__station_summaries: List[StationSummary] = []

        for id_uuid, packets in self.station_id_uuid_to_packets.items():
            s: List[str] = id_uuid.split(&#34;:&#34;)
            self.__station_id_to_id_uuid[s[0]] = id_uuid
            self.__station_summaries.append(StationSummary.from_packets(packets))

    @staticmethod
    def from_packets(packets: List[WrappedRedvoxPacketM]) -&gt; &#39;ReadResult&#39;:
        &#34;&#34;&#34;
        Constructs a read result from the provided packets.
        :param packets: Packets to construct read result from.
        :return: ReadResult from provided packets
        &#34;&#34;&#34;
        station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = defaultdict(list)

        for packet in packets:
            station_info = packet.get_station_information()
            station_id: str = station_info.get_id()
            station_uuid: str = station_info.get_uuid()
            id_uuid: str = f&#34;{station_id}:{station_uuid}&#34;
            station_id_uuid_to_packets[id_uuid].append(packet)

        return ReadResult(station_id_uuid_to_packets)

    def __get_packets_for_station_id_uuid(self, station_id_uuid) -&gt; List[WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        Find packets given a station_id:uuid.
        :param station_id_uuid: Station id and uuid to get packets for.
        :return: A list of wrapped packets or an empty list if none match.
        &#34;&#34;&#34;
        if station_id_uuid in self.station_id_uuid_to_packets:
            return self.station_id_uuid_to_packets[station_id_uuid]

        return []

    def __get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        Get packets for an associated station id.
        :param station_id: The station id.
        :return: A list of wrapped packets or an empty list if none provided.
        &#34;&#34;&#34;
        if station_id in self.__station_id_to_id_uuid:
            return self.__get_packets_for_station_id_uuid(self.__station_id_to_id_uuid[station_id])

        return []

    def get_station_summaries(self) -&gt; List[StationSummary]:
        &#34;&#34;&#34;
        :return: A list of StationSummaries contained in this ReadResult
        &#34;&#34;&#34;
        return self.__station_summaries

    def get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
        &#34;&#34;&#34;
        Gets packets either for the provided station_id or the provided station_id:uuid.
        :param station_id: station_id or station_id:uuid to get packets for.
        :return: A list of packets of an empty list of none provided.
        &#34;&#34;&#34;
        if &#34;:&#34; in station_id:
            return self.__get_packets_for_station_id_uuid(station_id)
        else:
            return self.__get_packets_for_station_id(station_id)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="redvox.api1000.io_raw.ReadResult.from_packets"><code class="name flex">
<span>def <span class="ident">from_packets</span></span>(<span>packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> <a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a read result from the provided packets.
:param packets: Packets to construct read result from.
:return: ReadResult from provided packets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_packets(packets: List[WrappedRedvoxPacketM]) -&gt; &#39;ReadResult&#39;:
    &#34;&#34;&#34;
    Constructs a read result from the provided packets.
    :param packets: Packets to construct read result from.
    :return: ReadResult from provided packets
    &#34;&#34;&#34;
    station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = defaultdict(list)

    for packet in packets:
        station_info = packet.get_station_information()
        station_id: str = station_info.get_id()
        station_uuid: str = station_info.get_uuid()
        id_uuid: str = f&#34;{station_id}:{station_uuid}&#34;
        station_id_uuid_to_packets[id_uuid].append(packet)

    return ReadResult(station_id_uuid_to_packets)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.api1000.io_raw.ReadResult.get_packets_for_station_id"><code class="name flex">
<span>def <span class="ident">get_packets_for_station_id</span></span>(<span>self, station_id: str) ‑> typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets packets either for the provided station_id or the provided station_id:uuid.
:param station_id: station_id or station_id:uuid to get packets for.
:return: A list of packets of an empty list of none provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
    &#34;&#34;&#34;
    Gets packets either for the provided station_id or the provided station_id:uuid.
    :param station_id: station_id or station_id:uuid to get packets for.
    :return: A list of packets of an empty list of none provided.
    &#34;&#34;&#34;
    if &#34;:&#34; in station_id:
        return self.__get_packets_for_station_id_uuid(station_id)
    else:
        return self.__get_packets_for_station_id(station_id)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadResult.get_station_summaries"><code class="name flex">
<span>def <span class="ident">get_station_summaries</span></span>(<span>self) ‑> typing.List[<a title="redvox.api1000.io_raw.StationSummary" href="#redvox.api1000.io_raw.StationSummary">StationSummary</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: A list of StationSummaries contained in this ReadResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_station_summaries(self) -&gt; List[StationSummary]:
    &#34;&#34;&#34;
    :return: A list of StationSummaries contained in this ReadResult
    &#34;&#34;&#34;
    return self.__station_summaries</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary"><code class="flex name class">
<span>class <span class="ident">StationSummary</span></span>
<span>(</span><span>station_id: str, station_uuid: str, auth_id: str, os: <a title="redvox.api1000.wrapped_redvox_packet.station_information.OsType" href="wrapped_redvox_packet/station_information.html#redvox.api1000.wrapped_redvox_packet.station_information.OsType">OsType</a>, os_version: str, app_version: str, audio_sampling_rate: float, total_packets: int, total_duration: datetime.timedelta, start_dt: datetime.datetime, end_dt: datetime.datetime)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains a summary of each stations data read result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StationSummary:
    &#34;&#34;&#34;
    Contains a summary of each stations data read result.
    &#34;&#34;&#34;
    station_id: str
    station_uuid: str
    auth_id: str
    os: OsType
    os_version: str
    app_version: str
    audio_sampling_rate: float
    total_packets: int
    total_duration: timedelta
    start_dt: datetime
    end_dt: datetime

    @staticmethod
    def from_packets(packets: List[WrappedRedvoxPacketM]) -&gt; &#39;StationSummary&#39;:
        first_packet: WrappedRedvoxPacketM = packets[0]
        last_packet: WrappedRedvoxPacketM = packets[-1]
        total_duration: timedelta = reduce(lambda acc, packet: acc + packet.get_packet_duration(),
                                           packets,
                                           timedelta(seconds=0.0))
        start_dt: datetime = dt_us(first_packet.get_timing_information().get_packet_start_mach_timestamp())
        end_dt: datetime = dt_us(last_packet.get_timing_information().get_packet_start_mach_timestamp()) + \
                           last_packet.get_packet_duration()

        station_info = first_packet.get_station_information()
        audio = first_packet.get_sensors().get_audio()
        return StationSummary(
            station_info.get_id(),
            station_info.get_uuid(),
            station_info.get_auth_id(),
            station_info.get_os(),
            station_info.get_os_version(),
            station_info.get_app_version(),
            audio.get_sample_rate() if audio is not None else float(&#34;NaN&#34;),
            len(packets),
            total_duration,
            start_dt,
            end_dt
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.api1000.io_raw.StationSummary.app_version"><code class="name">var <span class="ident">app_version</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.audio_sampling_rate"><code class="name">var <span class="ident">audio_sampling_rate</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.auth_id"><code class="name">var <span class="ident">auth_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.end_dt"><code class="name">var <span class="ident">end_dt</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.os"><code class="name">var <span class="ident">os</span> : <a title="redvox.api1000.wrapped_redvox_packet.station_information.OsType" href="wrapped_redvox_packet/station_information.html#redvox.api1000.wrapped_redvox_packet.station_information.OsType">OsType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.os_version"><code class="name">var <span class="ident">os_version</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.start_dt"><code class="name">var <span class="ident">start_dt</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.station_id"><code class="name">var <span class="ident">station_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.station_uuid"><code class="name">var <span class="ident">station_uuid</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.total_duration"><code class="name">var <span class="ident">total_duration</span> : datetime.timedelta</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.StationSummary.total_packets"><code class="name">var <span class="ident">total_packets</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.api1000.io_raw.StationSummary.from_packets"><code class="name flex">
<span>def <span class="ident">from_packets</span></span>(<span>packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> <a title="redvox.api1000.io_raw.StationSummary" href="#redvox.api1000.io_raw.StationSummary">StationSummary</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_packets(packets: List[WrappedRedvoxPacketM]) -&gt; &#39;StationSummary&#39;:
    first_packet: WrappedRedvoxPacketM = packets[0]
    last_packet: WrappedRedvoxPacketM = packets[-1]
    total_duration: timedelta = reduce(lambda acc, packet: acc + packet.get_packet_duration(),
                                       packets,
                                       timedelta(seconds=0.0))
    start_dt: datetime = dt_us(first_packet.get_timing_information().get_packet_start_mach_timestamp())
    end_dt: datetime = dt_us(last_packet.get_timing_information().get_packet_start_mach_timestamp()) + \
                       last_packet.get_packet_duration()

    station_info = first_packet.get_station_information()
    audio = first_packet.get_sensors().get_audio()
    return StationSummary(
        station_info.get_id(),
        station_info.get_uuid(),
        station_info.get_auth_id(),
        station_info.get_os(),
        station_info.get_os_version(),
        station_info.get_app_version(),
        audio.get_sample_rate() if audio is not None else float(&#34;NaN&#34;),
        len(packets),
        total_duration,
        start_dt,
        end_dt
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.api1000" href="index.html">redvox.api1000</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.api1000.io_raw.read_bufs" href="#redvox.api1000.io_raw.read_bufs">read_bufs</a></code></li>
<li><code><a title="redvox.api1000.io_raw.read_structured" href="#redvox.api1000.io_raw.read_structured">read_structured</a></code></li>
<li><code><a title="redvox.api1000.io_raw.read_unstructured" href="#redvox.api1000.io_raw.read_unstructured">read_unstructured</a></code></li>
<li><code><a title="redvox.api1000.io_raw.stream_structured" href="#redvox.api1000.io_raw.stream_structured">stream_structured</a></code></li>
<li><code><a title="redvox.api1000.io_raw.stream_unstructured" href="#redvox.api1000.io_raw.stream_unstructured">stream_unstructured</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.api1000.io_raw.ReadFilter.end_dt" href="#redvox.api1000.io_raw.ReadFilter.end_dt">end_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.extension" href="#redvox.api1000.io_raw.ReadFilter.extension">extension</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.filter_dt" href="#redvox.api1000.io_raw.ReadFilter.filter_dt">filter_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.filter_path" href="#redvox.api1000.io_raw.ReadFilter.filter_path">filter_path</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.start_dt" href="#redvox.api1000.io_raw.ReadFilter.start_dt">start_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.station_ids" href="#redvox.api1000.io_raw.ReadFilter.station_ids">station_ids</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_end_dt" href="#redvox.api1000.io_raw.ReadFilter.with_end_dt">with_end_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_end_ts" href="#redvox.api1000.io_raw.ReadFilter.with_end_ts">with_end_ts</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_extension" href="#redvox.api1000.io_raw.ReadFilter.with_extension">with_extension</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_start_dt" href="#redvox.api1000.io_raw.ReadFilter.with_start_dt">with_start_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_start_ts" href="#redvox.api1000.io_raw.ReadFilter.with_start_ts">with_start_ts</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_station_ids" href="#redvox.api1000.io_raw.ReadFilter.with_station_ids">with_station_ids</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></code></h4>
<ul class="">
<li><code><a title="redvox.api1000.io_raw.ReadResult.from_packets" href="#redvox.api1000.io_raw.ReadResult.from_packets">from_packets</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadResult.get_packets_for_station_id" href="#redvox.api1000.io_raw.ReadResult.get_packets_for_station_id">get_packets_for_station_id</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadResult.get_station_summaries" href="#redvox.api1000.io_raw.ReadResult.get_station_summaries">get_station_summaries</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.api1000.io_raw.StationSummary" href="#redvox.api1000.io_raw.StationSummary">StationSummary</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.api1000.io_raw.StationSummary.app_version" href="#redvox.api1000.io_raw.StationSummary.app_version">app_version</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.audio_sampling_rate" href="#redvox.api1000.io_raw.StationSummary.audio_sampling_rate">audio_sampling_rate</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.auth_id" href="#redvox.api1000.io_raw.StationSummary.auth_id">auth_id</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.end_dt" href="#redvox.api1000.io_raw.StationSummary.end_dt">end_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.from_packets" href="#redvox.api1000.io_raw.StationSummary.from_packets">from_packets</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.os" href="#redvox.api1000.io_raw.StationSummary.os">os</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.os_version" href="#redvox.api1000.io_raw.StationSummary.os_version">os_version</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.start_dt" href="#redvox.api1000.io_raw.StationSummary.start_dt">start_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.station_id" href="#redvox.api1000.io_raw.StationSummary.station_id">station_id</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.station_uuid" href="#redvox.api1000.io_raw.StationSummary.station_uuid">station_uuid</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.total_duration" href="#redvox.api1000.io_raw.StationSummary.total_duration">total_duration</a></code></li>
<li><code><a title="redvox.api1000.io_raw.StationSummary.total_packets" href="#redvox.api1000.io_raw.StationSummary.total_packets">total_packets</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>