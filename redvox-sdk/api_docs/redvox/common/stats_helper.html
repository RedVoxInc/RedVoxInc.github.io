<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redvox.common.stats_helper API documentation</title>
<meta name="description" content="Support for computing statistics
Requires numpy" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.stats_helper</code></h1>
</header>
<section id="section-intro">
<p>Support for computing statistics
Requires numpy</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Support for computing statistics
Requires numpy
&#34;&#34;&#34;

from dataclasses import dataclass, field
from dataclasses_json import dataclass_json
from typing import List, Union, Tuple

import numpy as np


@dataclass_json
@dataclass
class WelfordAggregator:
    &#34;&#34;&#34;
    Helper class to compute Welford stats for a single data stream

    Properties:
        m2: float, aggregate squared distance from the mean.  Default 0.0

        mean: float, mean of the data.  Default 0.0

        count: int, number of data points.  Default 0
    &#34;&#34;&#34;
    m2: float = 0.0
    mean: float = 0.0
    count: int = 0

    def update(self, val: float):
        &#34;&#34;&#34;
        adds a new value to the WelfordAggregator

        :param val: value to add
        &#34;&#34;&#34;
        self.count += 1
        delta = val - self.mean
        self.mean += delta / float(self.count)
        delta2 = val - self.mean
        self.m2 += delta * delta2

    def update_multiple(self, vals: List[float]):
        &#34;&#34;&#34;
        adds each value from a list of values to the WelfordAggregator

        :param vals: list of values to add
        &#34;&#34;&#34;
        for v in vals:
            self.update(v)

    def finalize(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Note: If the count of elements is less than 2, returns a tuple containing np.nan values

        :return: the mean, the m2 divided by the count as a tuple
        &#34;&#34;&#34;
        if self.count &lt; 2:
            return np.nan, np.nan
        return self.mean, self.m2 / float(self.count)


@dataclass_json
@dataclass
class WelfordStatsContainer:
    &#34;&#34;&#34;
    Helper class to compute statistics for objects with a single data stream
    Stores the min, max and WelfordAggregator for the data

    Properties:
        min: float, minimum value of the data

        max: float, maximum value of the data

        welford: WelfordAggregator, collection of data used to compute mean, std deviation, variance, etc.
    &#34;&#34;&#34;
    min: float = float(&#34;inf&#34;)
    max: float = -float(&#34;inf&#34;)
    welford: WelfordAggregator = field(default_factory=WelfordAggregator)

    def __repr__(self):
        return f&#34;min: {self.min}, &#34; \
               f&#34;max: {self.max}, &#34; \
               f&#34;welford: {self.welford}&#34;

    def __str__(self):
        return f&#34;min: {self.min}, &#34; \
               f&#34;max: {self.max}, &#34; \
               f&#34;stats: {self.welford}&#34;

    def update(self, val: float):
        &#34;&#34;&#34;
        adds a new mean to the WelfordAggregator and updates the minimum and maximum values

        :param val: value to add
        &#34;&#34;&#34;
        if val &lt; self.min:
            self.min = val
        if val &gt; self.max:
            self.max = val
        self.welford.update(val)

    def update_multiple(self, vals: List[float]):
        &#34;&#34;&#34;
        adds many new means to the WelfordAggregator and updates the minimum and maximum values

        :param vals: values to add
        &#34;&#34;&#34;
        for v in vals:
            self.update(v)

    def finalized(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the WelfordAggregator
        &#34;&#34;&#34;
        return self.welford.finalize()


class StatsContainer:
    &#34;&#34;&#34;
    Helper class to compute statistics for a set of objects
    Stores the mean, std dev, number of data points (count), and best value per set object
    Calculates mean of means, mean of variance, variance of means, total variance,
    and total std dev for the set of objects

    Properties:
        mean_array: the mean of each object in the set
        std_dev_array: the std_dev of each object in the set
        count_array: the number of elements in each object in the set
        best_value: the best value to represent the set
        container_id: a string that identifies the StatsContainer
    &#34;&#34;&#34;

    def __init__(self, container_id: str) -&gt; None:
        &#34;&#34;&#34;
        Initialize the StatsContainer

        :param container_id: a string describing the container
        &#34;&#34;&#34;
        self.mean_array: List[Union[float, int]] = []
        self.std_dev_array: List[Union[float, int]] = []
        self.count_array: List[Union[float, int]] = []
        self.best_value: float = 0.0
        self.container_id: str = container_id

    def mean_of_means(self) -&gt; float:
        &#34;&#34;&#34;
        :return: mean of all means
        &#34;&#34;&#34;
        # convert non-numbers to 0s
        counts: np.ndarray = np.nan_to_num(self.count_array)
        if np.sum(counts) == 0:
            return np.nan
        # weight each mean by the number of elements in it
        total_means: np.ndarray = np.prod(
            [np.nan_to_num(self.mean_array), counts], axis=0
        )
        # if sum(counts) is 0, change sum(counts) to 1 to avoid divide by 0 errors
        return np.sum(total_means) / np.sum(counts)

    def mean_of_variance(self) -&gt; float:
        &#34;&#34;&#34;
        :return: mean of the variances
        &#34;&#34;&#34;
        # convert non-numbers to 0s
        counts: np.ndarray = np.nan_to_num(self.count_array)
        if np.sum(counts) == 0:
            return np.nan
        std_devs: np.ndarray = np.nan_to_num(self.std_dev_array)
        # variance is std dev squared, which is then weighted by the number of elements for that variance
        total_vars: np.ndarray = np.prod([counts, std_devs, std_devs], axis=0)
        # if sum(counts) is 0, change sum(counts) to 1 to avoid divide by 0 errors
        return np.sum(total_vars) / np.sum(counts)

    def variance_of_means(self) -&gt; float:
        &#34;&#34;&#34;
        :return: variance of the means
        &#34;&#34;&#34;
        counts: np.ndarray = np.nan_to_num(self.count_array)
        if np.sum(counts) == 0:
            return np.nan
        # get the difference of individual means and total mean
        mean_vars: np.ndarray = np.subtract(
            np.nan_to_num(self.mean_array), self.mean_of_means()
        )
        # square the differences then weight them by number of elements
        total: np.ndarray = np.prod([mean_vars, mean_vars, counts], axis=0)
        # if sum(counts) is 0, change sum(counts) to 1 to avoid divide by 0 errors
        return np.sum(total) / np.sum(counts)

    def total_variance(self) -&gt; float:
        &#34;&#34;&#34;
        :return: total variance of all elements
        &#34;&#34;&#34;
        # mean of variances + variance of means = total variance
        return self.mean_of_variance() + self.variance_of_means()

    def total_std_dev(self) -&gt; float:
        &#34;&#34;&#34;
        :return: std dev of all elements (sqrt of total variance)
        &#34;&#34;&#34;
        return np.sqrt(self.total_variance())  # std dev is square root of variance

    def add(
        self,
        mean: Union[float, int],
        std_dev: Union[float, int],
        count: Union[float, int],
    ) -&gt; None:
        &#34;&#34;&#34;
        Put an element into the arrays

        :param mean: a mean
        :param std_dev: the std dev for the mean
        :param count: how many values were used to calculate the mean
        &#34;&#34;&#34;
        self.mean_array.append(mean)
        self.std_dev_array.append(std_dev)
        self.count_array.append(count)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.common.stats_helper.StatsContainer"><code class="flex name class">
<span>class <span class="ident">StatsContainer</span></span>
<span>(</span><span>container_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class to compute statistics for a set of objects
Stores the mean, std dev, number of data points (count), and best value per set object
Calculates mean of means, mean of variance, variance of means, total variance,
and total std dev for the set of objects</p>
<h2 id="properties">Properties</h2>
<p>mean_array: the mean of each object in the set
std_dev_array: the std_dev of each object in the set
count_array: the number of elements in each object in the set
best_value: the best value to represent the set
container_id: a string that identifies the StatsContainer</p>
<p>Initialize the StatsContainer</p>
<p>:param container_id: a string describing the container</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatsContainer:
    &#34;&#34;&#34;
    Helper class to compute statistics for a set of objects
    Stores the mean, std dev, number of data points (count), and best value per set object
    Calculates mean of means, mean of variance, variance of means, total variance,
    and total std dev for the set of objects

    Properties:
        mean_array: the mean of each object in the set
        std_dev_array: the std_dev of each object in the set
        count_array: the number of elements in each object in the set
        best_value: the best value to represent the set
        container_id: a string that identifies the StatsContainer
    &#34;&#34;&#34;

    def __init__(self, container_id: str) -&gt; None:
        &#34;&#34;&#34;
        Initialize the StatsContainer

        :param container_id: a string describing the container
        &#34;&#34;&#34;
        self.mean_array: List[Union[float, int]] = []
        self.std_dev_array: List[Union[float, int]] = []
        self.count_array: List[Union[float, int]] = []
        self.best_value: float = 0.0
        self.container_id: str = container_id

    def mean_of_means(self) -&gt; float:
        &#34;&#34;&#34;
        :return: mean of all means
        &#34;&#34;&#34;
        # convert non-numbers to 0s
        counts: np.ndarray = np.nan_to_num(self.count_array)
        if np.sum(counts) == 0:
            return np.nan
        # weight each mean by the number of elements in it
        total_means: np.ndarray = np.prod(
            [np.nan_to_num(self.mean_array), counts], axis=0
        )
        # if sum(counts) is 0, change sum(counts) to 1 to avoid divide by 0 errors
        return np.sum(total_means) / np.sum(counts)

    def mean_of_variance(self) -&gt; float:
        &#34;&#34;&#34;
        :return: mean of the variances
        &#34;&#34;&#34;
        # convert non-numbers to 0s
        counts: np.ndarray = np.nan_to_num(self.count_array)
        if np.sum(counts) == 0:
            return np.nan
        std_devs: np.ndarray = np.nan_to_num(self.std_dev_array)
        # variance is std dev squared, which is then weighted by the number of elements for that variance
        total_vars: np.ndarray = np.prod([counts, std_devs, std_devs], axis=0)
        # if sum(counts) is 0, change sum(counts) to 1 to avoid divide by 0 errors
        return np.sum(total_vars) / np.sum(counts)

    def variance_of_means(self) -&gt; float:
        &#34;&#34;&#34;
        :return: variance of the means
        &#34;&#34;&#34;
        counts: np.ndarray = np.nan_to_num(self.count_array)
        if np.sum(counts) == 0:
            return np.nan
        # get the difference of individual means and total mean
        mean_vars: np.ndarray = np.subtract(
            np.nan_to_num(self.mean_array), self.mean_of_means()
        )
        # square the differences then weight them by number of elements
        total: np.ndarray = np.prod([mean_vars, mean_vars, counts], axis=0)
        # if sum(counts) is 0, change sum(counts) to 1 to avoid divide by 0 errors
        return np.sum(total) / np.sum(counts)

    def total_variance(self) -&gt; float:
        &#34;&#34;&#34;
        :return: total variance of all elements
        &#34;&#34;&#34;
        # mean of variances + variance of means = total variance
        return self.mean_of_variance() + self.variance_of_means()

    def total_std_dev(self) -&gt; float:
        &#34;&#34;&#34;
        :return: std dev of all elements (sqrt of total variance)
        &#34;&#34;&#34;
        return np.sqrt(self.total_variance())  # std dev is square root of variance

    def add(
        self,
        mean: Union[float, int],
        std_dev: Union[float, int],
        count: Union[float, int],
    ) -&gt; None:
        &#34;&#34;&#34;
        Put an element into the arrays

        :param mean: a mean
        :param std_dev: the std dev for the mean
        :param count: how many values were used to calculate the mean
        &#34;&#34;&#34;
        self.mean_array.append(mean)
        self.std_dev_array.append(std_dev)
        self.count_array.append(count)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.stats_helper.StatsContainer.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, mean: Union[float, int], std_dev: Union[float, int], count: Union[float, int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Put an element into the arrays</p>
<p>:param mean: a mean
:param std_dev: the std dev for the mean
:param count: how many values were used to calculate the mean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(
    self,
    mean: Union[float, int],
    std_dev: Union[float, int],
    count: Union[float, int],
) -&gt; None:
    &#34;&#34;&#34;
    Put an element into the arrays

    :param mean: a mean
    :param std_dev: the std dev for the mean
    :param count: how many values were used to calculate the mean
    &#34;&#34;&#34;
    self.mean_array.append(mean)
    self.std_dev_array.append(std_dev)
    self.count_array.append(count)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.StatsContainer.mean_of_means"><code class="name flex">
<span>def <span class="ident">mean_of_means</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: mean of all means</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_of_means(self) -&gt; float:
    &#34;&#34;&#34;
    :return: mean of all means
    &#34;&#34;&#34;
    # convert non-numbers to 0s
    counts: np.ndarray = np.nan_to_num(self.count_array)
    if np.sum(counts) == 0:
        return np.nan
    # weight each mean by the number of elements in it
    total_means: np.ndarray = np.prod(
        [np.nan_to_num(self.mean_array), counts], axis=0
    )
    # if sum(counts) is 0, change sum(counts) to 1 to avoid divide by 0 errors
    return np.sum(total_means) / np.sum(counts)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.StatsContainer.mean_of_variance"><code class="name flex">
<span>def <span class="ident">mean_of_variance</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: mean of the variances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_of_variance(self) -&gt; float:
    &#34;&#34;&#34;
    :return: mean of the variances
    &#34;&#34;&#34;
    # convert non-numbers to 0s
    counts: np.ndarray = np.nan_to_num(self.count_array)
    if np.sum(counts) == 0:
        return np.nan
    std_devs: np.ndarray = np.nan_to_num(self.std_dev_array)
    # variance is std dev squared, which is then weighted by the number of elements for that variance
    total_vars: np.ndarray = np.prod([counts, std_devs, std_devs], axis=0)
    # if sum(counts) is 0, change sum(counts) to 1 to avoid divide by 0 errors
    return np.sum(total_vars) / np.sum(counts)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.StatsContainer.total_std_dev"><code class="name flex">
<span>def <span class="ident">total_std_dev</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: std dev of all elements (sqrt of total variance)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total_std_dev(self) -&gt; float:
    &#34;&#34;&#34;
    :return: std dev of all elements (sqrt of total variance)
    &#34;&#34;&#34;
    return np.sqrt(self.total_variance())  # std dev is square root of variance</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.StatsContainer.total_variance"><code class="name flex">
<span>def <span class="ident">total_variance</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: total variance of all elements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total_variance(self) -&gt; float:
    &#34;&#34;&#34;
    :return: total variance of all elements
    &#34;&#34;&#34;
    # mean of variances + variance of means = total variance
    return self.mean_of_variance() + self.variance_of_means()</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.StatsContainer.variance_of_means"><code class="name flex">
<span>def <span class="ident">variance_of_means</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: variance of the means</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variance_of_means(self) -&gt; float:
    &#34;&#34;&#34;
    :return: variance of the means
    &#34;&#34;&#34;
    counts: np.ndarray = np.nan_to_num(self.count_array)
    if np.sum(counts) == 0:
        return np.nan
    # get the difference of individual means and total mean
    mean_vars: np.ndarray = np.subtract(
        np.nan_to_num(self.mean_array), self.mean_of_means()
    )
    # square the differences then weight them by number of elements
    total: np.ndarray = np.prod([mean_vars, mean_vars, counts], axis=0)
    # if sum(counts) is 0, change sum(counts) to 1 to avoid divide by 0 errors
    return np.sum(total) / np.sum(counts)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.stats_helper.WelfordAggregator"><code class="flex name class">
<span>class <span class="ident">WelfordAggregator</span></span>
<span>(</span><span>m2: float = 0.0, mean: float = 0.0, count: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class to compute Welford stats for a single data stream</p>
<h2 id="properties">Properties</h2>
<p>m2: float, aggregate squared distance from the mean.
Default 0.0</p>
<p>mean: float, mean of the data.
Default 0.0</p>
<p>count: int, number of data points.
Default 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class WelfordAggregator:
    &#34;&#34;&#34;
    Helper class to compute Welford stats for a single data stream

    Properties:
        m2: float, aggregate squared distance from the mean.  Default 0.0

        mean: float, mean of the data.  Default 0.0

        count: int, number of data points.  Default 0
    &#34;&#34;&#34;
    m2: float = 0.0
    mean: float = 0.0
    count: int = 0

    def update(self, val: float):
        &#34;&#34;&#34;
        adds a new value to the WelfordAggregator

        :param val: value to add
        &#34;&#34;&#34;
        self.count += 1
        delta = val - self.mean
        self.mean += delta / float(self.count)
        delta2 = val - self.mean
        self.m2 += delta * delta2

    def update_multiple(self, vals: List[float]):
        &#34;&#34;&#34;
        adds each value from a list of values to the WelfordAggregator

        :param vals: list of values to add
        &#34;&#34;&#34;
        for v in vals:
            self.update(v)

    def finalize(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Note: If the count of elements is less than 2, returns a tuple containing np.nan values

        :return: the mean, the m2 divided by the count as a tuple
        &#34;&#34;&#34;
        if self.count &lt; 2:
            return np.nan, np.nan
        return self.mean, self.m2 / float(self.count)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.stats_helper.WelfordAggregator.count"><code class="name">var <span class="ident">count</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.stats_helper.WelfordAggregator.m2"><code class="name">var <span class="ident">m2</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.stats_helper.WelfordAggregator.mean"><code class="name">var <span class="ident">mean</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.stats_helper.WelfordAggregator.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: Union[dict, list, str, int, float, bool, ForwardRef(None)], *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls: Type[A],
              kvs: Json,
              *,
              infer_missing=False) -&gt; A:
    return _decode_dataclass(cls, kvs, infer_missing)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordAggregator.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: Union[str, bytes, bytearray], *, parse_float=None, parse_int=None, parse_constant=None, infer_missing=False, **kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls: Type[A],
              s: JsonData,
              *,
              parse_float=None,
              parse_int=None,
              parse_constant=None,
              infer_missing=False,
              **kw) -&gt; A:
    kvs = json.loads(s,
                     parse_float=parse_float,
                     parse_int=parse_int,
                     parse_constant=parse_constant,
                     **kw)
    return cls.from_dict(kvs, infer_missing=infer_missing)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordAggregator.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*, infer_missing: bool = False, only=None, exclude=(), many: bool = False, context=None, load_only=(), dump_only=(), partial: bool = False, unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def schema(cls: Type[A],
           *,
           infer_missing: bool = False,
           only=None,
           exclude=(),
           many: bool = False,
           context=None,
           load_only=(),
           dump_only=(),
           partial: bool = False,
           unknown=None) -&gt; SchemaType:
    Schema = build_schema(cls, DataClassJsonMixin, infer_missing, partial)

    if unknown is None:
        undefined_parameter_action = _undefined_parameter_action_safe(cls)
        if undefined_parameter_action is not None:
            # We can just make use of the same-named mm keywords
            unknown = undefined_parameter_action.name.lower()

    return Schema(only=only,
                  exclude=exclude,
                  many=many,
                  context=context,
                  load_only=load_only,
                  dump_only=dump_only,
                  partial=partial,
                  unknown=unknown)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.stats_helper.WelfordAggregator.finalize"><code class="name flex">
<span>def <span class="ident">finalize</span></span>(<span>self) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Note: If the count of elements is less than 2, returns a tuple containing np.nan values</p>
<p>:return: the mean, the m2 divided by the count as a tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalize(self) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Note: If the count of elements is less than 2, returns a tuple containing np.nan values

    :return: the mean, the m2 divided by the count as a tuple
    &#34;&#34;&#34;
    if self.count &lt; 2:
        return np.nan, np.nan
    return self.mean, self.m2 / float(self.count)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordAggregator.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, Union[dict, list, str, int, float, bool, ForwardRef(None)]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordAggregator.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, ForwardRef(None)] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Tuple[str, str] = None,
            default: Callable = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordAggregator.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, val: float)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a new value to the WelfordAggregator</p>
<p>:param val: value to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, val: float):
    &#34;&#34;&#34;
    adds a new value to the WelfordAggregator

    :param val: value to add
    &#34;&#34;&#34;
    self.count += 1
    delta = val - self.mean
    self.mean += delta / float(self.count)
    delta2 = val - self.mean
    self.m2 += delta * delta2</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordAggregator.update_multiple"><code class="name flex">
<span>def <span class="ident">update_multiple</span></span>(<span>self, vals: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>adds each value from a list of values to the WelfordAggregator</p>
<p>:param vals: list of values to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_multiple(self, vals: List[float]):
    &#34;&#34;&#34;
    adds each value from a list of values to the WelfordAggregator

    :param vals: list of values to add
    &#34;&#34;&#34;
    for v in vals:
        self.update(v)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.stats_helper.WelfordStatsContainer"><code class="flex name class">
<span>class <span class="ident">WelfordStatsContainer</span></span>
<span>(</span><span>min: float = inf, max: float = -inf, welford: <a title="redvox.common.stats_helper.WelfordAggregator" href="#redvox.common.stats_helper.WelfordAggregator">WelfordAggregator</a> = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class to compute statistics for objects with a single data stream
Stores the min, max and WelfordAggregator for the data</p>
<h2 id="properties">Properties</h2>
<p>min: float, minimum value of the data</p>
<p>max: float, maximum value of the data</p>
<p>welford: WelfordAggregator, collection of data used to compute mean, std deviation, variance, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class WelfordStatsContainer:
    &#34;&#34;&#34;
    Helper class to compute statistics for objects with a single data stream
    Stores the min, max and WelfordAggregator for the data

    Properties:
        min: float, minimum value of the data

        max: float, maximum value of the data

        welford: WelfordAggregator, collection of data used to compute mean, std deviation, variance, etc.
    &#34;&#34;&#34;
    min: float = float(&#34;inf&#34;)
    max: float = -float(&#34;inf&#34;)
    welford: WelfordAggregator = field(default_factory=WelfordAggregator)

    def __repr__(self):
        return f&#34;min: {self.min}, &#34; \
               f&#34;max: {self.max}, &#34; \
               f&#34;welford: {self.welford}&#34;

    def __str__(self):
        return f&#34;min: {self.min}, &#34; \
               f&#34;max: {self.max}, &#34; \
               f&#34;stats: {self.welford}&#34;

    def update(self, val: float):
        &#34;&#34;&#34;
        adds a new mean to the WelfordAggregator and updates the minimum and maximum values

        :param val: value to add
        &#34;&#34;&#34;
        if val &lt; self.min:
            self.min = val
        if val &gt; self.max:
            self.max = val
        self.welford.update(val)

    def update_multiple(self, vals: List[float]):
        &#34;&#34;&#34;
        adds many new means to the WelfordAggregator and updates the minimum and maximum values

        :param vals: values to add
        &#34;&#34;&#34;
        for v in vals:
            self.update(v)

    def finalized(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the WelfordAggregator
        &#34;&#34;&#34;
        return self.welford.finalize()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.max"><code class="name">var <span class="ident">max</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.min"><code class="name">var <span class="ident">min</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.welford"><code class="name">var <span class="ident">welford</span> : <a title="redvox.common.stats_helper.WelfordAggregator" href="#redvox.common.stats_helper.WelfordAggregator">WelfordAggregator</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: Union[dict, list, str, int, float, bool, ForwardRef(None)], *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls: Type[A],
              kvs: Json,
              *,
              infer_missing=False) -&gt; A:
    return _decode_dataclass(cls, kvs, infer_missing)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: Union[str, bytes, bytearray], *, parse_float=None, parse_int=None, parse_constant=None, infer_missing=False, **kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls: Type[A],
              s: JsonData,
              *,
              parse_float=None,
              parse_int=None,
              parse_constant=None,
              infer_missing=False,
              **kw) -&gt; A:
    kvs = json.loads(s,
                     parse_float=parse_float,
                     parse_int=parse_int,
                     parse_constant=parse_constant,
                     **kw)
    return cls.from_dict(kvs, infer_missing=infer_missing)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*, infer_missing: bool = False, only=None, exclude=(), many: bool = False, context=None, load_only=(), dump_only=(), partial: bool = False, unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def schema(cls: Type[A],
           *,
           infer_missing: bool = False,
           only=None,
           exclude=(),
           many: bool = False,
           context=None,
           load_only=(),
           dump_only=(),
           partial: bool = False,
           unknown=None) -&gt; SchemaType:
    Schema = build_schema(cls, DataClassJsonMixin, infer_missing, partial)

    if unknown is None:
        undefined_parameter_action = _undefined_parameter_action_safe(cls)
        if undefined_parameter_action is not None:
            # We can just make use of the same-named mm keywords
            unknown = undefined_parameter_action.name.lower()

    return Schema(only=only,
                  exclude=exclude,
                  many=many,
                  context=context,
                  load_only=load_only,
                  dump_only=dump_only,
                  partial=partial,
                  unknown=unknown)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.finalized"><code class="name flex">
<span>def <span class="ident">finalized</span></span>(<span>self) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the mean and variance of the WelfordAggregator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalized(self) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    :return: the mean and variance of the WelfordAggregator
    &#34;&#34;&#34;
    return self.welford.finalize()</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, Union[dict, list, str, int, float, bool, ForwardRef(None)]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, ForwardRef(None)] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Tuple[str, str] = None,
            default: Callable = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, val: float)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a new mean to the WelfordAggregator and updates the minimum and maximum values</p>
<p>:param val: value to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, val: float):
    &#34;&#34;&#34;
    adds a new mean to the WelfordAggregator and updates the minimum and maximum values

    :param val: value to add
    &#34;&#34;&#34;
    if val &lt; self.min:
        self.min = val
    if val &gt; self.max:
        self.max = val
    self.welford.update(val)</code></pre>
</details>
</dd>
<dt id="redvox.common.stats_helper.WelfordStatsContainer.update_multiple"><code class="name flex">
<span>def <span class="ident">update_multiple</span></span>(<span>self, vals: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>adds many new means to the WelfordAggregator and updates the minimum and maximum values</p>
<p>:param vals: values to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_multiple(self, vals: List[float]):
    &#34;&#34;&#34;
    adds many new means to the WelfordAggregator and updates the minimum and maximum values

    :param vals: values to add
    &#34;&#34;&#34;
    for v in vals:
        self.update(v)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.common.stats_helper.StatsContainer" href="#redvox.common.stats_helper.StatsContainer">StatsContainer</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.common.stats_helper.StatsContainer.add" href="#redvox.common.stats_helper.StatsContainer.add">add</a></code></li>
<li><code><a title="redvox.common.stats_helper.StatsContainer.mean_of_means" href="#redvox.common.stats_helper.StatsContainer.mean_of_means">mean_of_means</a></code></li>
<li><code><a title="redvox.common.stats_helper.StatsContainer.mean_of_variance" href="#redvox.common.stats_helper.StatsContainer.mean_of_variance">mean_of_variance</a></code></li>
<li><code><a title="redvox.common.stats_helper.StatsContainer.total_std_dev" href="#redvox.common.stats_helper.StatsContainer.total_std_dev">total_std_dev</a></code></li>
<li><code><a title="redvox.common.stats_helper.StatsContainer.total_variance" href="#redvox.common.stats_helper.StatsContainer.total_variance">total_variance</a></code></li>
<li><code><a title="redvox.common.stats_helper.StatsContainer.variance_of_means" href="#redvox.common.stats_helper.StatsContainer.variance_of_means">variance_of_means</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.stats_helper.WelfordAggregator" href="#redvox.common.stats_helper.WelfordAggregator">WelfordAggregator</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.count" href="#redvox.common.stats_helper.WelfordAggregator.count">count</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.finalize" href="#redvox.common.stats_helper.WelfordAggregator.finalize">finalize</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.from_dict" href="#redvox.common.stats_helper.WelfordAggregator.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.from_json" href="#redvox.common.stats_helper.WelfordAggregator.from_json">from_json</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.m2" href="#redvox.common.stats_helper.WelfordAggregator.m2">m2</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.mean" href="#redvox.common.stats_helper.WelfordAggregator.mean">mean</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.schema" href="#redvox.common.stats_helper.WelfordAggregator.schema">schema</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.to_dict" href="#redvox.common.stats_helper.WelfordAggregator.to_dict">to_dict</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.to_json" href="#redvox.common.stats_helper.WelfordAggregator.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.update" href="#redvox.common.stats_helper.WelfordAggregator.update">update</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordAggregator.update_multiple" href="#redvox.common.stats_helper.WelfordAggregator.update_multiple">update_multiple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.stats_helper.WelfordStatsContainer" href="#redvox.common.stats_helper.WelfordStatsContainer">WelfordStatsContainer</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.finalized" href="#redvox.common.stats_helper.WelfordStatsContainer.finalized">finalized</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.from_dict" href="#redvox.common.stats_helper.WelfordStatsContainer.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.from_json" href="#redvox.common.stats_helper.WelfordStatsContainer.from_json">from_json</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.max" href="#redvox.common.stats_helper.WelfordStatsContainer.max">max</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.min" href="#redvox.common.stats_helper.WelfordStatsContainer.min">min</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.schema" href="#redvox.common.stats_helper.WelfordStatsContainer.schema">schema</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.to_dict" href="#redvox.common.stats_helper.WelfordStatsContainer.to_dict">to_dict</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.to_json" href="#redvox.common.stats_helper.WelfordStatsContainer.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.update" href="#redvox.common.stats_helper.WelfordStatsContainer.update">update</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.update_multiple" href="#redvox.common.stats_helper.WelfordStatsContainer.update_multiple">update_multiple</a></code></li>
<li><code><a title="redvox.common.stats_helper.WelfordStatsContainer.welford" href="#redvox.common.stats_helper.WelfordStatsContainer.welford">welford</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>