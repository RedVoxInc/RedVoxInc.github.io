<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redvox.common.sensor_data API documentation</title>
<meta name="description" content="Defines generic sensor data and data for API-independent analysis
all timestamps are integers in microseconds unless otherwise stated" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.sensor_data</code></h1>
</header>
<section id="section-intro">
<p>Defines generic sensor data and data for API-independent analysis
all timestamps are integers in microseconds unless otherwise stated</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines generic sensor data and data for API-independent analysis
all timestamps are integers in microseconds unless otherwise stated
&#34;&#34;&#34;
import enum
from typing import List, Dict, Optional, Tuple
from pathlib import Path
import os

import numpy as np
import pandas as pd
import pyarrow as pa
import pyarrow.compute as pc
import pyarrow.dataset as ds
import pyarrow.parquet as pq

import redvox.common.sensor_io as io
import redvox.common.date_time_utils as dtu
from redvox.common.io import FileSystemSaveMode, FileSystemWriter as Fsw
from redvox.common import offset_model as om
from redvox.common.errors import RedVoxExceptions
from redvox.common.gap_and_pad_utils import calc_evenly_sampled_timestamps, AudioWithGaps
from redvox.api1000.wrapped_redvox_packet.station_information import (
    NetworkType,
    PowerState,
    CellServiceState,
    WifiWakeLock,
    ScreenState,
)
from redvox.api1000.wrapped_redvox_packet.sensors.location import LocationProvider
from redvox.api1000.wrapped_redvox_packet.sensors.image import ImageCodec
from redvox.api1000.wrapped_redvox_packet.sensors.audio import AudioCodec

# function used to translate values of enumerated columns
COLUMN_TO_ENUM_FN = {&#34;location_provider&#34;: lambda l: LocationProvider(l).name,
                     &#34;image_codec&#34;: lambda l: ImageCodec(l).name,
                     &#34;audio_codec&#34;: lambda l: AudioCodec(l).name,
                     &#34;network_type&#34;: lambda l: NetworkType(l).name,
                     &#34;power_state&#34;: lambda l: PowerState(l).name,
                     &#34;cell_service&#34;: lambda l: CellServiceState(l).name,
                     &#34;wifi_wake_lock&#34;: lambda l: WifiWakeLock(l).name,
                     &#34;screen_state&#34;: lambda l: ScreenState(l).name}
# columns that cannot be interpolated
NON_INTERPOLATED_COLUMNS = [&#34;compressed_audio&#34;, &#34;image&#34;]
# columns that are not numeric but can be interpolated
NON_NUMERIC_COLUMNS = list(COLUMN_TO_ENUM_FN.keys())


class SensorType(enum.Enum):
    &#34;&#34;&#34;
    Enumeration of possible types of sensors to read data from
    &#34;&#34;&#34;

    UNKNOWN_SENSOR = 0  # unknown sensor
    ACCELEROMETER = 1  # meters/second^2
    AMBIENT_TEMPERATURE = 2  # degrees Celsius
    AUDIO = 3  # normalized counts
    COMPRESSED_AUDIO = 4  # bytes (codec specific)
    GRAVITY = 5  # meters/second^2
    GYROSCOPE = 6  # radians/second
    IMAGE = 7  # bytes (codec specific)
    LIGHT = 8  # lux
    LINEAR_ACCELERATION = 9  # meters/second^2
    LOCATION = 10  # See standard
    MAGNETOMETER = 11  # microtesla
    ORIENTATION = 12  # radians
    PRESSURE = 13  # kilopascal
    PROXIMITY = 14  # on, off, cm
    RELATIVE_HUMIDITY = 15  # percentage
    ROTATION_VECTOR = 16  # Unitless
    INFRARED = 17  # this is proximity
    STATION_HEALTH = 18
    # Health sensors: battery charge and current level, phone internal temperature, network source and strength,
    # available RAM of the system, cell service status, amount of hard disk space left, power charging state
    # wifi lock state, cpu utilization, screen state, and screen brightness
    BEST_LOCATION = 19  # See standard

    @staticmethod
    def type_from_str(type_str: str) -&gt; &#34;SensorType&#34;:
        &#34;&#34;&#34;
        converts a string to a sensor type

        :param type_str: string to convert
        :return: a sensor type, UNKNOWN_SENSOR is the default for invalid inputs
        &#34;&#34;&#34;
        if (
                type_str.lower() == &#34;audio&#34;
                or type_str.lower() == &#34;mic&#34;
                or type_str.lower() == &#34;microphone&#34;
        ):
            return SensorType.AUDIO
        elif type_str.lower() == &#34;accelerometer&#34; or type_str.lower() == &#34;accel&#34;:
            return SensorType.ACCELEROMETER
        elif type_str.lower() == &#34;ambient_temperature&#34;:
            return SensorType.AMBIENT_TEMPERATURE
        elif type_str.lower() == &#34;compressed_audio&#34;:
            return SensorType.COMPRESSED_AUDIO
        elif type_str.lower() == &#34;gravity&#34;:
            return SensorType.GRAVITY
        elif type_str.lower() == &#34;gyroscope&#34; or type_str.lower() == &#34;gyro&#34;:
            return SensorType.GYROSCOPE
        elif type_str.lower() == &#34;image&#34;:
            return SensorType.IMAGE
        elif type_str.lower() == &#34;light&#34;:
            return SensorType.LIGHT
        elif (
                type_str.lower() == &#34;linear_acceleration&#34;
                or type_str.lower() == &#34;linear_accel&#34;
        ):
            return SensorType.LINEAR_ACCELERATION
        elif type_str.lower() == &#34;location&#34; or type_str.lower() == &#34;loc&#34;:
            return SensorType.LOCATION
        elif type_str.lower() == &#34;best_location&#34; or type_str.lower() == &#34;best_loc&#34;:
            return SensorType.BEST_LOCATION
        elif type_str.lower() == &#34;magnetometer&#34; or type_str.lower() == &#34;mag&#34;:
            return SensorType.MAGNETOMETER
        elif type_str.lower() == &#34;orientation&#34;:
            return SensorType.ORIENTATION
        elif (
                type_str.lower() == &#34;pressure&#34;
                or type_str.lower() == &#34;bar&#34;
                or type_str.lower() == &#34;barometer&#34;
        ):
            return SensorType.PRESSURE
        elif type_str.lower() == &#34;proximity&#34; or type_str.lower() == &#34;infrared&#34;:
            return SensorType.PROXIMITY
        elif type_str.lower() == &#34;relative_humidity&#34;:
            return SensorType.RELATIVE_HUMIDITY
        elif type_str.lower() == &#34;rotation_vector&#34;:
            return SensorType.ROTATION_VECTOR
        else:
            return SensorType.UNKNOWN_SENSOR


class SensorData:
    &#34;&#34;&#34;
    Generic RedvoxSensor class for API-independent analysis

    Properties:
        name: string, name of sensor.  REQUIRED

    Protected:
        _type: SensorType, enumerated type of sensor, default UNKNOWN_SENSOR

        _sample_rate_hz: float, sample rate in Hz of the sensor, default np.nan, usually 1/sample_interval_s

        _sample_interval_s: float, mean duration in seconds between samples, default np.nan, usually 1/sample_rate

        _sample_interval_std_s: float, standard deviation in seconds between samples, default np.nan

        _is_sample_rate_fixed: bool, True if sample rate is constant, default False

        _timestamps_altered: bool, True if timestamps in the sensor have been altered from their original values
        default False

        _use_offset_model: bool, if True, use an offset model to correct timestamps, otherwise use the best known
        offset.  default False

        _errors: RedVoxExceptions, class containing a list of all errors encountered by the sensor.

        _gaps: List of Tuples of floats, timestamps of data points on the edge of gaps, default empty list

        _fs_writer: FileSystemWriter, handles file system i/o parameters

        _data: pyarrow Table, used to store the data when it&#39;s not written to the disk.  default None
    &#34;&#34;&#34;

    def __init__(
            self,
            sensor_name: str,
            sensor_data: Optional[pa.Table] = None,
            sensor_type: SensorType = SensorType.UNKNOWN_SENSOR,
            sample_rate_hz: float = np.nan,
            sample_interval_s: float = np.nan,
            sample_interval_std_s: float = np.nan,
            is_sample_rate_fixed: bool = False,
            are_timestamps_altered: bool = False,
            calculate_stats: bool = False,
            use_offset_model_for_correction: bool = False,
            save_data: bool = False,
            base_dir: str = &#34;.&#34;,
            gaps: Optional[List[Tuple[float, float]]] = None,
            show_errors: bool = False,
            use_temp_dir: bool = False
    ):
        &#34;&#34;&#34;
        initialize the sensor data with params

        :param sensor_name: name of the sensor.  REQUIRED
        :param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
        :param sensor_data: Optional pyarrow table with the timestamps and sensor data;
                            first column is always the timestamps,
                            the other columns are specific metadata and data channels in the sensor
                            default is None
        :param sample_rate_hz: sample rate in hz of the data
        :param sample_interval_s: sample interval in seconds of the data
        :param sample_interval_std_s: std dev of sample interval in seconds of the data
        :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
        :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                        original values, default False
        :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                                default False
        :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                                use the best known offset.  default False
        :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
        :param base_dir: directory to save pyarrow table, default &#34;.&#34; (current dir).  internally uses a temporary
                            dir if not saving data
        :param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.  anything between
                        the pairs of points exists to maintain sample rate and are not considered valid points.
                        Default None
        :param show_errors: if True, show any errors encountered.  Default False
        :param use_temp_dir: if True, use a temp directory to save data.  Default False
        &#34;&#34;&#34;
        self._errors: RedVoxExceptions = RedVoxExceptions(&#34;Sensor&#34;)
        self.name: str = sensor_name
        self._type: SensorType = sensor_type
        self._sample_rate_hz: float = sample_rate_hz
        self._sample_interval_s: float = sample_interval_s
        self._sample_interval_std_s: float = sample_interval_std_s
        self._is_sample_rate_fixed: bool = is_sample_rate_fixed
        self._timestamps_altered: bool = are_timestamps_altered
        self._use_offset_model: bool = use_offset_model_for_correction
        if save_data:
            save_mode = FileSystemSaveMode.DISK
        elif use_temp_dir:
            save_mode = FileSystemSaveMode.TEMP
        else:
            save_mode = FileSystemSaveMode.MEM
        self._fs_writer = Fsw(&#34;&#34;, &#34;parquet&#34;, base_dir, save_mode)
        self._gaps: List[Tuple] = gaps if gaps else []
        set_data_as_sensor_data = True
        if sensor_data is not None:
            if &#34;timestamps&#34; not in sensor_data.schema.names:
                self._errors.append(&#39;must have a column titled &#34;timestamps&#34;&#39;)
            elif sensor_data[&#39;timestamps&#39;].length() &gt; 0:
                set_data_as_sensor_data = False
                if calculate_stats and np.isnan(sample_interval_s) and np.isnan(sample_rate_hz) \
                        and np.isnan(sample_interval_std_s):
                    self.organize_and_update_stats(sensor_data)
                elif sensor_data[&#34;timestamps&#34;].length() &gt; 1:
                    self.sort_by_data_timestamps(sensor_data)
                else:
                    self.write_pyarrow_table(sensor_data)
        if set_data_as_sensor_data:
            self._data = sensor_data
        if show_errors:
            self.print_errors()

    @staticmethod
    def from_dir(
            sensor_name: str,
            data_path: str,
            sensor_type: SensorType = SensorType.UNKNOWN_SENSOR,
            sample_rate_hz: float = np.nan,
            sample_interval_s: float = np.nan,
            sample_interval_std_s: float = np.nan,
            is_sample_rate_fixed: bool = False,
            are_timestamps_altered: bool = False,
            calculate_stats: bool = False,
            use_offset_model_for_correction: bool = False,
            save_data: bool = False,
            use_temp_dir: bool = False) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        init but with a path to directory containing parquet file(s) instead of a table of data

        :param sensor_name: name of the sensor
        :param data_path: path to the directory containing the parquet files
        :param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
        :param sample_rate_hz: sample rate in hz of the data, default np.nan
        :param sample_interval_s: sample interval in seconds of the data, default np.nan
        :param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
        :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
        :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                        original values, default False
        :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                                default False
        :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                                use the best known offset.  default False
        :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
        :param use_temp_dir: if True, save the data using a temporary directory.  default False
        :return: RedvoxSensor object
        &#34;&#34;&#34;
        result = SensorData(sensor_name,
                            ds.dataset(data_path, format=&#34;parquet&#34;, exclude_invalid_files=True).to_table(),
                            sensor_type, sample_rate_hz, sample_interval_s, sample_interval_std_s,
                            is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                            use_offset_model_for_correction, save_data, data_path, use_temp_dir=use_temp_dir)
        return result

    @staticmethod
    def from_dict(
            sensor_name: str,
            sensor_data: Dict,
            sensor_type: SensorType = SensorType.UNKNOWN_SENSOR,
            sample_rate_hz: float = np.nan,
            sample_interval_s: float = np.nan,
            sample_interval_std_s: float = np.nan,
            is_sample_rate_fixed: bool = False,
            are_timestamps_altered: bool = False,
            calculate_stats: bool = False,
            use_offset_model_for_correction: bool = False,
            save_data: bool = False,
            arrow_dir: str = &#34;&#34;,
            use_temp_dir: bool = False
    ) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        init but with a dictionary

        :param sensor_name: name of the sensor
        :param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
        :param sensor_data: dict with the timestamps and sensor data; first column is always the timestamps,
                            the other columns are the data channels in the sensor
        :param sample_rate_hz: sample rate in hz of the data, default np.nan
        :param sample_interval_s: sample interval in seconds of the data, default np.nan
        :param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
        :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
        :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                        original values, default False
        :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                                default False
        :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                                use the best known offset.  default False
        :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
        :param arrow_dir: directory to save pyarrow table, default &#34;&#34; (current dir).  default temporary dir if not
                            saving data
        :param use_temp_dir: If True, use a temporary directory to save the data.  default False
        :return: RedvoxSensor object
        &#34;&#34;&#34;
        return SensorData(sensor_name, pa.Table.from_pydict(sensor_data), sensor_type, sample_rate_hz,
                          sample_interval_s, sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered,
                          calculate_stats, use_offset_model_for_correction, save_data, arrow_dir,
                          use_temp_dir=use_temp_dir)

    def save(self, file_name: Optional[str] = None) -&gt; Optional[Path]:
        &#34;&#34;&#34;
        Saves the RedvoxSensor to disk.  Does nothing if saving is not enabled

        :param file_name: Optional file name to save RedvoxSensor as.  Do not include a file extension.  Default None
                            If None, a default file name is created using this format:
                            [sensor_type]_[first_timestamp].json
        :return: The path to the saved file or None if unable to save.
        &#34;&#34;&#34;
        if self._fs_writer.is_save_disk():
            return self.to_json_file(file_name)
        return None

    def load(self, in_dir: str) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        :param in_dir: structured directory with json metadata file to load
        :return: RedvoxSensor using data from files
        &#34;&#34;&#34;
        file = io.get_json_file(in_dir)
        if file is None:
            st = SensorData(&#34;LoadError&#34;)
            st.append_error(&#34;File to load Sensor not found.&#34;)
            return self
        else:
            return self.from_json_file(in_dir, file)

    def set_save_mode(self, new_save_mode: FileSystemSaveMode):
        &#34;&#34;&#34;
        changes the save mode to new_save_mode

        :param new_save_mode: FileSystemSaveMode to change to
        &#34;&#34;&#34;
        self._fs_writer.set_save_mode(new_save_mode)

    def is_save_to_disk(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: True if sensor will be saved to disk
        &#34;&#34;&#34;
        return self._fs_writer.is_use_disk()

    def set_save_to_disk(self, save: bool):
        &#34;&#34;&#34;
        :param save: If True, save to disk
        &#34;&#34;&#34;
        self._fs_writer.set_use_disk(save)

    def set_file_name(self, new_file: Optional[str] = None):
        &#34;&#34;&#34;
        * set the pyarrow file name or use the default: {sensor_type}_{int(first_timestamp)}
        * Do not give an extension

        :param new_file: optional file name to change to; default None (use default name)
        &#34;&#34;&#34;
        self._fs_writer.file_name = new_file if new_file else f&#34;{self._type.name}_{int(self.first_data_timestamp())}&#34;

    def full_file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: full name of parquet file containing the data
        &#34;&#34;&#34;
        return self._fs_writer.full_name()

    def file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: file name without extension
        &#34;&#34;&#34;
        return self._fs_writer.file_name

    def set_save_dir(self, new_dir: str = &#34;.&#34;):
        &#34;&#34;&#34;
        set the pyarrow directory or use the default: &#34;.&#34; (current directory)

        :param new_dir: the directory to change to; default &#34;.&#34; (use current directory)
        &#34;&#34;&#34;
        self._fs_writer.base_dir = new_dir

    def save_dir(self) -&gt; str:
        &#34;&#34;&#34;
        :return: directory containing parquet files for the sensor
        &#34;&#34;&#34;
        return self._fs_writer.save_dir()

    def full_path(self) -&gt; str:
        &#34;&#34;&#34;
        :return: the full path to the data file
        &#34;&#34;&#34;
        return self._fs_writer.full_path()

    def fs_writer(self) -&gt; Fsw:
        &#34;&#34;&#34;
        :return: FileSystemWriter object
        &#34;&#34;&#34;
        return self._fs_writer

    def set_use_temp_dir(self, use_temp_dir: bool = False):
        &#34;&#34;&#34;
        :param use_temp_dir: if True, use temp dir to save data.  default False
        &#34;&#34;&#34;
        self._fs_writer.set_use_temp(use_temp_dir)

    def pyarrow_ds(self, base_dir: Optional[str] = None) -&gt; ds.Dataset:
        &#34;&#34;&#34;
        :param base_dir: optional directory to use when loading the dataset.  if None, use self.save_dir()
        :return: the dataset stored in base_dir
        &#34;&#34;&#34;
        if base_dir is None:
            base_dir = self.save_dir()
        return ds.dataset(base_dir, format=&#34;parquet&#34;, exclude_invalid_files=True)

    def pyarrow_table(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the table defined by the _data property or the dataset stored in self.save_dir()
        &#34;&#34;&#34;
        if self._data or self._fs_writer.is_use_mem():
            return self._data
        return self.pyarrow_ds().to_table()

    def data_df(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        :return: the pandas dataframe defined by the dataset stored in self.save_dir()
        &#34;&#34;&#34;
        return self.pyarrow_table().to_pandas()

    def write_pyarrow_table(self, table: pa.Table, update_file_name: Optional[bool] = True):
        &#34;&#34;&#34;
        saves the pyarrow table to disk or to memory.

        * if there is no data or there is no column named timestamps in the table, an error will be created
        * if writing to disk, uses a default filename: {sensor_type}_{first_timestamp}.parquet
        * uses the directory defined by self.save_dir().  Creates the directory if it doesn&#39;t exist and removes any
        existing parquet files from the directory if it exists

        :param table: the table to write
        :param update_file_name: if True, updates the file name to match the new data.  Default True
        &#34;&#34;&#34;
        if table.num_rows &lt; 1 or &#34;timestamps&#34; not in table.schema.names:
            self._errors.append(&#34;Attempted to write invalid table.&#34;)
        elif self._fs_writer.is_save_disk():
            self._fs_writer.create_dir()
            if update_file_name:
                self.set_file_name(f&#34;{self.type().name}_{int(table[&#39;timestamps&#39;][0].as_py())}&#34;)
            pq.write_table(table, self.full_path())
            self._data = None
        else:
            self._data = table

    def move_pyarrow_dir(self, new_dir: str) -&gt; Path:
        &#34;&#34;&#34;
        Move the sensor&#39;s pyarrow files to a new directory

        :param new_dir: directory to save files into
        &#34;&#34;&#34;
        old_sensor_save_dir = self.save_dir()
        self.set_save_dir(os.path.join(new_dir, self._type.name))
        for r, d, f in os.walk(old_sensor_save_dir):
            for file in f:
                self._fs_writer.create_dir()
                os.rename(os.path.join(old_sensor_save_dir, file), os.path.join(self.save_dir(), file))
        return Path(self.save_dir())

    def errors(self) -&gt; RedVoxExceptions:
        &#34;&#34;&#34;
        :return: errors of the sensor
        &#34;&#34;&#34;
        return self._errors

    def gaps(self) -&gt; List[Tuple]:
        &#34;&#34;&#34;
        :return: start and end timestamps of gaps in data
        &#34;&#34;&#34;
        return self._gaps

    def type(self) -&gt; SensorType:
        &#34;&#34;&#34;
        :return: type of sensor
        &#34;&#34;&#34;
        return self._type

    def type_as_str(self) -&gt; str:
        &#34;&#34;&#34;
        gets the sensor type as a string

        :return: sensor type of the sensor as a string
        &#34;&#34;&#34;
        return self._type.name

    def sample_rate_hz(self) -&gt; float:
        &#34;&#34;&#34;
        :return: sample rate in Hz
        &#34;&#34;&#34;
        return self._sample_rate_hz

    def sample_interval_s(self) -&gt; float:
        &#34;&#34;&#34;
        :return: mean sample interval in seconds
        &#34;&#34;&#34;
        return self._sample_interval_s

    def sample_interval_std_s(self) -&gt; float:
        &#34;&#34;&#34;
        :return: sample interval standard deviation in seconds
        &#34;&#34;&#34;
        return self._sample_interval_std_s

    def is_sample_rate_fixed(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: true if sample rate of sensor is constant
        &#34;&#34;&#34;
        return self._is_sample_rate_fixed

    def is_timestamps_altered(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: true if timestamps have been changed from original data values
        &#34;&#34;&#34;
        return self._timestamps_altered

    def used_offset_model(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: true if an offset model was used to perform timestamp corrections
        &#34;&#34;&#34;
        return self._use_offset_model

    def sort_by_data_timestamps(self, ptable: pa.Table, ascending: bool = True):
        &#34;&#34;&#34;
        sorts the data based on timestamps

        :param ptable: pyarrow table to sort
        :param ascending: if True, timestamps are sorted in ascending order, else sort by descending order
        &#34;&#34;&#34;
        if ascending:
            order = &#34;ascending&#34;
        else:
            order = &#34;descending&#34;
        data = pc.take(ptable, pc.sort_indices(ptable, sort_keys=[(&#34;timestamps&#34;, order)]))
        self.write_pyarrow_table(data)

    def organize_and_update_stats(self, ptable: pa.Table) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        sorts the data by timestamps, then if the sample rate is not fixed, recalculates the sample rate, interval,
            and interval std dev.  If there is only one value, sets the sample rate, interval, and interval std dev
            to np.nan.  Updates the RedvoxSensor object with the new values

        :param ptable: pyarrow table to update
        :return: updated version of self
        &#34;&#34;&#34;
        self.sort_by_data_timestamps(ptable)
        if not self._is_sample_rate_fixed:
            if self.num_samples() &gt; 1:
                timestamp_diffs = np.diff(self.data_timestamps())
                self._sample_interval_s = dtu.microseconds_to_seconds(
                    float(np.mean(timestamp_diffs))
                )
                self._sample_interval_std_s = dtu.microseconds_to_seconds(
                    float(np.std(timestamp_diffs))
                )
                self._sample_rate_hz = (
                    np.nan
                    if self.is_sample_interval_invalid()
                    else 1 / self._sample_interval_s
                )
            else:
                self._sample_interval_s = np.nan
                self._sample_interval_std_s = np.nan
                self._sample_rate_hz = np.nan
        return self

    def append_sensor(self, new_sensor: &#34;SensorData&#34;, recalculate_stats: bool = False) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        append the new data to the sensor, update the sensor&#39;s stats on demand if it doesn&#39;t have a fixed
            sample rate, then return the updated RedvoxSensor object

        :param new_sensor: sensor containing data to add to the calling sensor
        :param recalculate_stats: if True and the sensor does not have a fixed sample rate, sort the timestamps,
                                    recalculate the sample rate, interval, and interval std dev, default False
        :return: the updated RedvoxSensor object
        &#34;&#34;&#34;
        _arrow: pa.Table = pa.concat_tables([self.pyarrow_table(), new_sensor.pyarrow_table()])
        if recalculate_stats and not self._is_sample_rate_fixed:
            self.organize_and_update_stats(_arrow)
        else:
            self.write_pyarrow_table(_arrow)
        return self

    def append_data(
            self, new_data: List[np.array], recalculate_stats: bool = False
    ) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        append the new data to the dataframe, update the sensor&#39;s stats on demand if it doesn&#39;t have a fixed
            sample rate, then return the updated RedvoxSensor object

        :param new_data: list of arrays containing data to add to the sensor&#39;s dataframe
        :param recalculate_stats: if True and the sensor does not have a fixed sample rate, sort the timestamps,
                                    recalculate the sample rate, interval, and interval std dev, default False
        :return: the updated RedvoxSensor object
        &#34;&#34;&#34;
        _arrow = pa.concat_tables([self.pyarrow_table(),
                                   pa.Table.from_arrays(arrays=[pa.array(s) for s in new_data],
                                                        names=self.data_channels())])
        if recalculate_stats and not self._is_sample_rate_fixed:
            self.organize_and_update_stats(_arrow)
        else:
            self.write_pyarrow_table(_arrow)
        return self

    def is_sample_interval_invalid(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: True if sample interval is np.nan or equal to 0.0
        &#34;&#34;&#34;
        return np.isnan(self._sample_interval_s) or self._sample_interval_s == 0.0

    def data_timestamps(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: the timestamps as a numpy array or [np.nan] if none exist
        &#34;&#34;&#34;
        if &#34;timestamps&#34; in self.pyarrow_table().schema.names:
            return self.pyarrow_table()[&#34;timestamps&#34;].to_numpy()
        else:
            return np.array([np.nan])

    def unaltered_data_timestamps(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: the unaltered timestamps as a numpy array
        &#34;&#34;&#34;
        if &#34;unaltered_timestamps&#34; in self.pyarrow_table().schema.names:
            return self.pyarrow_table()[&#34;unaltered_timestamps&#34;].to_numpy()
        else:
            return np.array([np.nan])

    def first_data_timestamp(self) -&gt; float:
        &#34;&#34;&#34;
        :return: timestamp of the first data point or np.nan if no timestamps
        &#34;&#34;&#34;
        return self.data_timestamps()[0]

    def last_data_timestamp(self) -&gt; float:
        &#34;&#34;&#34;
        :return: timestamp of the last data point or np.nan if no timestamps
        &#34;&#34;&#34;
        return self.data_timestamps()[-1]

    def num_samples(self) -&gt; int:
        &#34;&#34;&#34;
        :return: the number of rows (samples) in the dataframe
        &#34;&#34;&#34;
        if self.pyarrow_table():
            return self.pyarrow_table().num_rows
        return 0

    def samples(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        gets the non-timestamp samples of dataframe

        :return: the data values of the dataframe as a numpy ndarray
        &#34;&#34;&#34;
        return self.data_df().iloc[:, 2:].T.to_numpy()

    def data_channels(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: a list of the names of the columns (data channels) of the dataframe
        &#34;&#34;&#34;
        if self.pyarrow_table():
            return self.pyarrow_table().schema.names
        return []

    def get_data_channel(self, channel_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        gets the data channel specified, raises an error and lists valid fields if channel_name is not in the dataframe

        :param channel_name: the name of the channel to get data for
        :return: the data values of the channel as a numpy array or list of strings for enumerated channels
        &#34;&#34;&#34;
        if not self.pyarrow_table():
            self._errors.append(f&#34;WARNING: There are no channels to access in this Sensor!&#34;)
            return []
        _arrow = self.pyarrow_table()
        if channel_name not in _arrow.schema.names:
            self._errors.append(f&#34;WARNING: {channel_name} does not exist; try one of {_arrow.schema.names}&#34;)
            return []
        if channel_name in NON_NUMERIC_COLUMNS:
            return np.array([COLUMN_TO_ENUM_FN[channel_name](c.as_py()) for c in _arrow[channel_name]])
        return _arrow[channel_name].to_numpy()

    def _get_non_numeric_data_channel(self, channel_name: str) -&gt; List[str]:
        &#34;&#34;&#34;
        get_data_channel but specifically enumerated channels

        :param channel_name: the name of the channel to get data for
        :return: the data values of the channel as a list of strings
        &#34;&#34;&#34;
        if not self.pyarrow_table():
            self._errors.append(f&#34;WARNING: There are no channels to access in this Sensor!&#34;)
        else:
            _arrow = self.pyarrow_table()
            if channel_name in NON_NUMERIC_COLUMNS:
                return [COLUMN_TO_ENUM_FN[channel_name](c.as_py()) for c in _arrow[channel_name]]
        self._errors.append(f&#34;WARNING: {channel_name} does not exist&#34;)
        return []

    def get_valid_data_channel_values(self, channel_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        gets all non-nan values from the channel specified

        :param channel_name: the name of the channel to get data for
        :return: non-nan values of the channel as a numpy array
        &#34;&#34;&#34;
        channel_data = self.get_data_channel(channel_name)
        return channel_data[~np.isnan(channel_data)]

    def _get_valid_non_numeric_data_channel_values(self, channel_name: str) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        return non-nan&#39;d values; technically this evaluates an actual numeric channel first

        :param channel_name:
        :return:
        &#34;&#34;&#34;
        pass

    def print_errors(self):
        &#34;&#34;&#34;
        print all errors to screen
        &#34;&#34;&#34;
        self._errors.print()

    def extend_errors(self, errors: RedVoxExceptions):
        &#34;&#34;&#34;
        add errors to the Sensor&#39;s errors

        :param errors: errors to add
        &#34;&#34;&#34;
        self._errors.extend_error(errors)

    def update_data_timestamps(self, offset_model: om.OffsetModel):
        &#34;&#34;&#34;
        updates the timestamps of the data points

        :param offset_model: model used to update the timestamps
        &#34;&#34;&#34;
        slope = dtu.seconds_to_microseconds(self._sample_interval_s) * (1 + offset_model.slope) \
            if self._use_offset_model else dtu.seconds_to_microseconds(self._sample_interval_s)
        if self._type == SensorType.AUDIO:
            # use the model to update the first timestamp or add the best offset (model&#39;s intercept value)
            timestamps = pa.array(
                calc_evenly_sampled_timestamps(
                    offset_model.update_time(self.first_data_timestamp(), self._use_offset_model),
                    self.num_samples(),
                    slope))
        else:
            timestamps = pa.array(offset_model.update_timestamps(self.data_timestamps(),
                                                                 self._use_offset_model))
        # old_name = self.full_path()
        self.write_pyarrow_table(self.pyarrow_table().set_column(0, &#34;timestamps&#34;, timestamps))
        # self.set_file_name()
        # os.rename(old_name, self.full_path())
        time_diffs = np.floor(np.diff(self.data_timestamps()))
        if len(time_diffs) &gt; 1:
            self._sample_interval_s = dtu.microseconds_to_seconds(slope)
            if self._sample_interval_s &gt; 0:
                self._sample_rate_hz = 1 / self._sample_interval_s
                self._sample_interval_std_s = dtu.microseconds_to_seconds(float(np.std(time_diffs)))
        self._timestamps_altered = True

    def interpolate(self, interpolate_timestamp: float, first_point: int, second_point: int = 0,
                    copy: bool = True) -&gt; pa.Table:
        &#34;&#34;&#34;
        interpolates two points at the intercept value.  the two points must be consecutive in the data.
        data channels that can&#39;t be interpolated are set to np.nan.

        :param interpolate_timestamp: timestamp to interpolate other values
        :param first_point: index of first point
        :param second_point: delta to second point, default 0 (same as first point)
        :param copy: if True, copies the values of the first point, otherwise uses the interpolated value.
                        Default True
        :return: pyarrow Table of interpolated points
        &#34;&#34;&#34;
        start_point = self.pyarrow_table().slice(first_point, 1).to_pydict()
        if not copy and second_point:
            i_p = {}
            end_point = self.pyarrow_table().slice(first_point + second_point, 1).to_pydict()
            first_closer = \
                np.abs(start_point[0] - interpolate_timestamp) \
                &lt;= np.abs(end_point[0] - interpolate_timestamp)
            for col in self.pyarrow_table().schema.names:
                # process each column independently into new table object
                if col not in NON_INTERPOLATED_COLUMNS + NON_NUMERIC_COLUMNS:
                    numeric_diff = end_point[col] - start_point[col]
                    numeric_diff = \
                        (numeric_diff / numeric_diff[&#34;timestamps&#34;]) * \
                        (interpolate_timestamp - start_point[col]) + start_point[col]
                    i_p[col] = numeric_diff
                elif col in NON_NUMERIC_COLUMNS:
                    if first_closer:
                        i_p[col] = start_point[col]
                    else:
                        i_p[col] = end_point[col]
        else:
            i_p = start_point
        i_p[&#34;timestamps&#34;] = [interpolate_timestamp]
        return pa.Table.from_pydict(i_p)

    def as_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: sensor as dict
        &#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;type&#34;: self._type.name,
            &#34;num_samples&#34;: self.num_samples(),
            &#34;sample_rate_hz&#34;: self._sample_rate_hz,
            &#34;sample_interval_s&#34;: self._sample_interval_s,
            &#34;sample_interval_std_s&#34;: self._sample_interval_std_s,
            &#34;is_sample_rate_fixed&#34;: self._is_sample_rate_fixed,
            &#34;timestamps_altered&#34;: self._timestamps_altered,
            &#34;use_offset_model&#34;: self._use_offset_model,
            &#34;gaps&#34;: self._gaps,
            &#34;base_dir&#34;: os.path.basename(self._fs_writer.save_dir()),
            &#34;errors&#34;: self._errors.as_dict()
        }

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;
        :return: sensor as json string
        &#34;&#34;&#34;
        return io.to_json(self)

    def to_json_file(self, file_name: Optional[str] = None) -&gt; Path:
        &#34;&#34;&#34;
        saves the sensor as json and data in the same directory.

        :param file_name: the optional base file name.  Do not include a file extension.
                            If None, a default file name is created using this format:
                            [sensor_type]_[first_timestamp].json
        :return: path to json file
        &#34;&#34;&#34;
        self.write_pyarrow_table(self.pyarrow_table())
        return io.to_json_file(self, file_name)

    @staticmethod
    def from_json_file(file_dir: str, file_name: Optional[str] = None) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        convert contents of json file to Sensor

        :param file_dir: full path to containing directory for the file
        :param file_name: optional name of file and extension to load data from; if not specified, finds the first one
        :return: RedvoxSensor object
        &#34;&#34;&#34;
        if file_name is None:
            file_name = io.get_json_file(file_dir)
            if file_name is None:
                result = SensorData(&#34;Empty&#34;)
                result.append_error(&#34;JSON file to load Sensor from not found.&#34;)
                return result
        json_data = io.json_file_to_dict(os.path.join(file_dir, file_name))
        if &#34;name&#34; in json_data.keys():
            result = SensorData.from_dir(json_data[&#34;name&#34;], file_dir, SensorType[json_data[&#34;type&#34;]],
                                         json_data[&#34;sample_rate_hz&#34;], json_data[&#34;sample_interval_s&#34;],
                                         json_data[&#34;sample_interval_std_s&#34;], json_data[&#34;is_sample_rate_fixed&#34;],
                                         json_data[&#34;timestamps_altered&#34;], False, json_data[&#34;use_offset_model&#34;])
            result.set_errors(RedVoxExceptions.from_dict(json_data[&#34;errors&#34;]))
            result.set_save_to_disk(True)
            result.set_file_name()
            result.set_gaps(json_data[&#34;gaps&#34;])
        else:
            result = SensorData(&#34;Empty&#34;)
            result.append_error(f&#34;Loading from {file_name} failed; missing Sensor name.&#34;)
        return result

    def class_from_type(self) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        Updates the class to be a specific type of sensor based on self._type

        :return: Self
        &#34;&#34;&#34;
        if self._type in SensorType:
            sensor_class_from_type = {
                SensorType.AUDIO: AudioSensor,
                SensorType.COMPRESSED_AUDIO: CompressedAudioSensor,
                SensorType.IMAGE: ImageSensor,
                SensorType.LOCATION: LocationSensor,
                SensorType.BEST_LOCATION: BestLocationSensor,
                SensorType.STATION_HEALTH: StationHealthSensor,
                SensorType.LIGHT: LightSensor,
                SensorType.PRESSURE: PressureSensor,
                SensorType.PROXIMITY: ProximitySensor,
                SensorType.INFRARED: ProximitySensor,
                SensorType.RELATIVE_HUMIDITY: RelativeHumiditySensor,
                SensorType.AMBIENT_TEMPERATURE: AmbientTemperatureSensor,
                SensorType.ACCELEROMETER: AccelerometerSensor,
                SensorType.GYROSCOPE: GyroscopeSensor,
                SensorType.MAGNETOMETER: MagnetometerSensor,
                SensorType.ORIENTATION: OrientationSensor,
                SensorType.GRAVITY: GravitySensor,
                SensorType.LINEAR_ACCELERATION: LinearAccelerationSensor,
                SensorType.ROTATION_VECTOR: RotationVectorSensor,
                SensorType.UNKNOWN_SENSOR: SensorData
            }
            self.__class__ = sensor_class_from_type[self._type]
        return self

    def set_errors(self, errors: RedVoxExceptions):
        &#34;&#34;&#34;
        sets the errors of the Sensor

        :param errors: errors to set
        &#34;&#34;&#34;
        self._errors = errors

    def append_error(self, error: str):
        &#34;&#34;&#34;
        add an error to the Sensor

        :param error: error to add
        &#34;&#34;&#34;
        self._errors.append(error)

    def set_gaps(self, gaps: List[Tuple]):
        &#34;&#34;&#34;
        sets the gaps of the Sensor

        :param gaps: gaps to set
        &#34;&#34;&#34;
        self._gaps = gaps


class AudioSensor(SensorData):
    &#34;&#34;&#34;
    Audio specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False,
                 use_temp_dir: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.AUDIO, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors, use_temp_dir)

    @staticmethod
    def from_metadata(sensor_name: str,
                      data: AudioWithGaps,
                      sample_rate_hz: float = np.nan,
                      sample_interval_s: float = np.nan,
                      sample_interval_std_s: float = np.nan,
                      is_sample_rate_fixed: bool = False,
                      are_timestamps_altered: bool = False,
                      calculate_stats: bool = False,
                      use_offset_model_for_correction: bool = False,
                      save_data: bool = False,
                      base_dir: str = &#34;.&#34;,
                      use_temp_dir: bool = False) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        init but using metadata

        :param sensor_name: name of the sensor
        :param data: the metadata used to create the sensor
        :param sample_rate_hz: sample rate in hz of the data, default np.nan
        :param sample_interval_s: sample interval in seconds of the data, default np.nan
        :param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
        :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
        :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                        original values, default False
        :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                                default False
        :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                                use the best known offset.  default False
        :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
        :param base_dir: directory to save pyarrow table, default &#34;.&#34; (current dir).  internally uses a temporary
                            dir if not saving data
        :param use_temp_dir: if True, save the data using a temporary directory.  default False
        :return: RedvoxSensor object
        &#34;&#34;&#34;
        return SensorData(sensor_name, data.create_timestamps(),
                          SensorType.AUDIO, sample_rate_hz, sample_interval_s, sample_interval_std_s,
                          is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                          use_offset_model_for_correction, save_data, base_dir, use_temp_dir=use_temp_dir)

    def get_microphone_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: audio data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;microphone&#39;)

    def get_valid_microphone_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan audio data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;microphone&#39;)


class CompressedAudioSensor(SensorData):
    &#34;&#34;&#34;
    Compressed audio specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.COMPRESSED_AUDIO, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_compressed_audio_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: compressed audio data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;compressed_audio&#39;)

    def get_valid_compressed_audio_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan compressed audio data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;compressed_audio&#39;)

    def get_audio_codec_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: audio codec as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;audio_codec&#39;)

    def _get_valid_audio_codec_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan audio codec as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;audio_codec&#39;)


class ImageSensor(SensorData):
    &#34;&#34;&#34;
    Image specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.IMAGE, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_image_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: image data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;image&#39;)

    def get_valid_image_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan image data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;image&#39;)

    def get_image_codec_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: image codec as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;image_codec&#39;)

    def get_valid_image_codec_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan image codec as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;image_codec&#39;)


class PressureSensor(SensorData):
    &#34;&#34;&#34;
    Pressure specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.PRESSURE, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_pressure_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: pressure data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;pressure&#39;)

    def get_valid_pressure_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan pressure data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;pressure&#39;)


class LightSensor(SensorData):
    &#34;&#34;&#34;
    Light specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.LIGHT, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_light_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: light data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;light&#39;)

    def get_valid_light_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan light data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;light&#39;)


class ProximitySensor(SensorData):
    &#34;&#34;&#34;
    Proximity specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.PROXIMITY, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_proximity_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: proximity data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;proximity&#39;)

    def get_valid_proximity_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan proximity data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;proximity&#39;)


class AmbientTemperatureSensor(SensorData):
    &#34;&#34;&#34;
    Ambient temperature specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.AMBIENT_TEMPERATURE, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_ambient_temperature_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: ambient temperature data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;ambient_temperature&#39;)

    def get_valid_ambient_temperature_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan ambient temperature data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;ambient_temperature&#39;)


class RelativeHumiditySensor(SensorData):
    &#34;&#34;&#34;
    Relative humidity specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.RELATIVE_HUMIDITY, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_relative_humidity_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: relative humidity data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;relative_humidity&#39;)

    def get_valid_relative_humidity_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan relative humidity data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;relative_humidity&#39;)


class AccelerometerSensor(SensorData):
    &#34;&#34;&#34;
    Accelerometer specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.ACCELEROMETER, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_accelerometer_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: accelerometer x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;accelerometer_x&#39;)

    def get_valid_accelerometer_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan accelerometer x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;accelerometer_x&#39;)

    def get_accelerometer_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: accelerometer y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;accelerometer_y&#39;)

    def get_valid_accelerometer_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan accelerometer y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;accelerometer_y&#39;)

    def get_accelerometer_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: accelerometer z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;accelerometer_z&#39;)

    def get_valid_accelerometer_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan accelerometer z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;accelerometer_z&#39;)


class MagnetometerSensor(SensorData):
    &#34;&#34;&#34;
    Magnetometer specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.MAGNETOMETER, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_magnetometer_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: magnetometer x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;magnetometer_x&#39;)

    def get_valid_magnetometer_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan magnetometer x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;magnetometer_x&#39;)

    def get_magnetometer_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: magnetometer y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;magnetometer_y&#39;)

    def get_valid_magnetometer_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan magnetometer y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;magnetometer_y&#39;)

    def get_magnetometer_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: magnetometer z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;magnetometer_z&#39;)

    def get_valid_magnetometer_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan magnetometer z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;magnetometer_z&#39;)


class LinearAccelerationSensor(SensorData):
    &#34;&#34;&#34;
    Linear acceleration specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.LINEAR_ACCELERATION, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_linear_acceleration_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: linear acceleration x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;linear_acceleration_x&#39;)

    def get_valid_linear_acceleration_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan linear acceleration x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;linear_acceleration_x&#39;)

    def get_linear_acceleration_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: linear acceleration y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;linear_acceleration_y&#39;)

    def get_valid_linear_acceleration_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan linear acceleration y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;linear_acceleration_y&#39;)

    def get_linear_acceleration_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: linear acceleration z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;linear_acceleration_z&#39;)

    def get_valid_linear_acceleration_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan linear acceleration z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;linear_acceleration_z&#39;)


class OrientationSensor(SensorData):
    &#34;&#34;&#34;
    Orientation specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.ORIENTATION, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_orientation_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: orientation x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;orientation_x&#39;)

    def get_valid_orientation_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan orientation x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;orientation_x&#39;)

    def get_orientation_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: orientation y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;orientation_y&#39;)

    def get_valid_orientation_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan orientation y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;orientation_y&#39;)

    def get_orientation_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: orientation z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;orientation_z&#39;)

    def get_valid_orientation_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan orientation z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;orientation_z&#39;)


class RotationVectorSensor(SensorData):
    &#34;&#34;&#34;
    Rotation vector specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.ROTATION_VECTOR, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_rotation_vector_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: rotation vector x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;rotation_vector_x&#39;)

    def get_valid_rotation_vector_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan rotation vector x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;rotation_vector_x&#39;)

    def get_rotation_vector_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: rotation vector y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;rotation_vector_y&#39;)

    def get_valid_rotation_vector_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan rotation vector y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;rotation_vector_y&#39;)

    def get_rotation_vector_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: rotation vector z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;rotation_vector_z&#39;)

    def get_valid_rotation_vector_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan rotation vector z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;rotation_vector_z&#39;)


class GyroscopeSensor(SensorData):
    &#34;&#34;&#34;
    Gyroscope specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.GYROSCOPE, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_gyroscope_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gyroscope x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gyroscope_x&#39;)

    def get_valid_gyroscope_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gyroscope x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gyroscope_x&#39;)

    def get_gyroscope_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gyroscope y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gyroscope_y&#39;)

    def get_valid_gyroscope_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gyroscope y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gyroscope_y&#39;)

    def get_gyroscope_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gyroscope z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gyroscope_z&#39;)

    def get_valid_gyroscope_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gyroscope z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gyroscope_z&#39;)


class GravitySensor(SensorData):
    &#34;&#34;&#34;
    Gravity specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.GRAVITY, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_gravity_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gravity x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gravity_x&#39;)

    def get_valid_gravity_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gravity x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gravity_x&#39;)

    def get_gravity_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gravity y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gravity_y&#39;)

    def get_valid_gravity_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gravity y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gravity_y&#39;)

    def get_gravity_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gravity z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gravity_z&#39;)

    def get_valid_gravity_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gravity z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gravity_z&#39;)


class LocationSensor(SensorData):
    &#34;&#34;&#34;
    Location specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.LOCATION, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_gps_timestamps_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gps timestamps as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gps_timestamps&#39;)

    def get_valid_gps_timestamps_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gps timestamps as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gps_timestamps&#39;)

    def get_latitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: latitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;latitude&#39;)

    def get_valid_latitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan latitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;latitude&#39;)

    def get_longitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: longitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;longitude&#39;)

    def get_valid_longitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan longitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;longitude&#39;)

    def get_altitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: altitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;altitude&#39;)

    def get_valid_altitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan altitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;altitude&#39;)

    def get_speed_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: speed data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;speed&#39;)

    def get_valid_speed_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan speed data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;speed&#39;)

    def get_bearing_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: bearing data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;bearing&#39;)

    def get_valid_bearing_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan bearing data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;bearing&#39;)

    def get_horizontal_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: horizontal accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;horizontal_accuracy&#39;)

    def get_valid_horizontal_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan horizontal accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;horizontal_accuracy&#39;)

    def get_vertical_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: vertical accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;vertical_accuracy&#39;)

    def get_valid_vertical_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan vertical accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;vertical_accuracy&#39;)

    def get_speed_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: speed accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;speed_accuracy&#39;)

    def get_valid_speed_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan speed accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;speed_accuracy&#39;)

    def get_bearing_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: bearing accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;bearing_accuracy&#39;)

    def get_valid_bearing_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan bearing accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;bearing_accuracy&#39;)

    def get_location_provider_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: location provider data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;location_provider&#39;)

    def get_valid_location_provider_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan location provider data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;location_provider&#39;)


class BestLocationSensor(SensorData):
    &#34;&#34;&#34;
    Best-location specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.BEST_LOCATION, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_gps_timestamps_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gps timestamps as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gps_timestamps&#39;)

    def get_valid_gps_timestamps_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gps timestamps as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gps_timestamps&#39;)

    def get_latitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: latitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;latitude&#39;)

    def get_valid_latitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan latitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;latitude&#39;)

    def get_longitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: longitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;longitude&#39;)

    def get_valid_longitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan longitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;longitude&#39;)

    def get_altitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: altitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;altitude&#39;)

    def get_valid_altitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan altitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;altitude&#39;)

    def get_speed_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: speed data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;speed&#39;)

    def get_valid_speed_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan speed data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;speed&#39;)

    def get_bearing_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: bearing data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;bearing&#39;)

    def get_valid_bearing_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan bearing data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;bearing&#39;)

    def get_horizontal_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: horizontal accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;horizontal_accuracy&#39;)

    def get_valid_horizontal_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan horizontal accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;horizontal_accuracy&#39;)

    def get_vertical_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: vertical accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;vertical_accuracy&#39;)

    def get_valid_vertical_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan vertical accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;vertical_accuracy&#39;)

    def get_speed_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: speed accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;speed_accuracy&#39;)

    def get_valid_speed_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan speed accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;speed_accuracy&#39;)

    def get_bearing_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: bearing accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;bearing_accuracy&#39;)

    def get_valid_bearing_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan bearing accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;bearing_accuracy&#39;)

    def get_location_provider_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: location provider data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;location_provider&#39;)

    def get_valid_location_provider_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan location provider data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;location_provider&#39;)


class StationHealthSensor(SensorData):
    &#34;&#34;&#34;
    Station Health specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.STATION_HEALTH, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_battery_charge_remaining_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: battery charge remaining data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;battery_charge_remaining&#39;)

    def get_valid_battery_charge_remaining_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan battery charge remaining data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;battery_charge_remaining&#39;)

    def get_battery_current_strength_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: battery current strength data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;battery_current_strength&#39;)

    def get_valid_battery_current_strength_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan battery current strength data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;battery_current_strength&#39;)

    def get_internal_temp_c_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: internal temperature celsius data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;internal_temp_c&#39;)

    def get_valid_internal_temp_c_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan internal temperature celsius data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;internal_temp_c&#39;)

    def get_network_type_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: network type data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;network_type&#39;)

    def get_valid_network_type_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan network type data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;network_type&#39;)

    def get_network_strength_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: network strength data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;network_strength&#39;)

    def get_valid_network_strength_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan network strength data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;network_strength&#39;)

    def get_power_state_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: power state data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;power_state&#39;)

    def get_valid_power_state_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan power state data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;power_state&#39;)

    def get_avail_ram_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: available RAM data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;avail_ram&#39;)

    def get_valid_avail_ram_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan available RAM data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;avail_ram&#39;)

    def get_avail_disk_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: available disk space data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;avail_disk&#39;)

    def get_valid_avail_disk_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan available disk space data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;avail_disk&#39;)

    def get_cell_service_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: cell service data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;cell_service&#39;)

    def get_valid_cell_service_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan cell service data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;cell_service&#39;)

    def get_cpu_utilization_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: CPU utilization data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;cpu_utilization&#39;)

    def get_valid_cpu_utilization_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan CPU utilization data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;cpu_utilization&#39;)

    def get_wifi_wake_lock_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: wifi wake lock data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;wifi_wake_lock&#39;)

    def get_valid_wifi_wake_lock_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan wifi wake lock data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;wifi_wake_lock&#39;)

    def get_screen_state_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: screen state data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;screen_state&#39;)

    def get_valid_screen_state_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan screen state data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;screen_state&#39;)

    def get_screen_brightness_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: screen brightness data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;screen_brightness&#39;)

    def get_valid_screen_brightness_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan screen brightness data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;screen_brightness&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.common.sensor_data.AccelerometerSensor"><code class="flex name class">
<span>class <span class="ident">AccelerometerSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Accelerometer specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccelerometerSensor(SensorData):
    &#34;&#34;&#34;
    Accelerometer specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.ACCELEROMETER, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_accelerometer_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: accelerometer x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;accelerometer_x&#39;)

    def get_valid_accelerometer_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan accelerometer x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;accelerometer_x&#39;)

    def get_accelerometer_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: accelerometer y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;accelerometer_y&#39;)

    def get_valid_accelerometer_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan accelerometer y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;accelerometer_y&#39;)

    def get_accelerometer_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: accelerometer z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;accelerometer_z&#39;)

    def get_valid_accelerometer_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan accelerometer z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;accelerometer_z&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.AccelerometerSensor.get_accelerometer_x_data"><code class="name flex">
<span>def <span class="ident">get_accelerometer_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: accelerometer x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_accelerometer_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: accelerometer x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;accelerometer_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.AccelerometerSensor.get_accelerometer_y_data"><code class="name flex">
<span>def <span class="ident">get_accelerometer_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: accelerometer y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_accelerometer_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: accelerometer y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;accelerometer_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.AccelerometerSensor.get_accelerometer_z_data"><code class="name flex">
<span>def <span class="ident">get_accelerometer_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: accelerometer z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_accelerometer_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: accelerometer z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;accelerometer_z&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.AccelerometerSensor.get_valid_accelerometer_x_data"><code class="name flex">
<span>def <span class="ident">get_valid_accelerometer_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan accelerometer x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_accelerometer_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan accelerometer x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;accelerometer_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.AccelerometerSensor.get_valid_accelerometer_y_data"><code class="name flex">
<span>def <span class="ident">get_valid_accelerometer_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan accelerometer y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_accelerometer_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan accelerometer y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;accelerometer_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.AccelerometerSensor.get_valid_accelerometer_z_data"><code class="name flex">
<span>def <span class="ident">get_valid_accelerometer_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan accelerometer z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_accelerometer_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan accelerometer z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;accelerometer_z&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.AmbientTemperatureSensor"><code class="flex name class">
<span>class <span class="ident">AmbientTemperatureSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Ambient temperature specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AmbientTemperatureSensor(SensorData):
    &#34;&#34;&#34;
    Ambient temperature specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.AMBIENT_TEMPERATURE, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_ambient_temperature_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: ambient temperature data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;ambient_temperature&#39;)

    def get_valid_ambient_temperature_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan ambient temperature data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;ambient_temperature&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.AmbientTemperatureSensor.get_ambient_temperature_data"><code class="name flex">
<span>def <span class="ident">get_ambient_temperature_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: ambient temperature data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ambient_temperature_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: ambient temperature data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;ambient_temperature&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.AmbientTemperatureSensor.get_valid_ambient_temperature_data"><code class="name flex">
<span>def <span class="ident">get_valid_ambient_temperature_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan ambient temperature data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_ambient_temperature_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan ambient temperature data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;ambient_temperature&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.AudioSensor"><code class="flex name class">
<span>class <span class="ident">AudioSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False, use_temp_dir: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Audio specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AudioSensor(SensorData):
    &#34;&#34;&#34;
    Audio specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False,
                 use_temp_dir: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.AUDIO, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors, use_temp_dir)

    @staticmethod
    def from_metadata(sensor_name: str,
                      data: AudioWithGaps,
                      sample_rate_hz: float = np.nan,
                      sample_interval_s: float = np.nan,
                      sample_interval_std_s: float = np.nan,
                      is_sample_rate_fixed: bool = False,
                      are_timestamps_altered: bool = False,
                      calculate_stats: bool = False,
                      use_offset_model_for_correction: bool = False,
                      save_data: bool = False,
                      base_dir: str = &#34;.&#34;,
                      use_temp_dir: bool = False) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        init but using metadata

        :param sensor_name: name of the sensor
        :param data: the metadata used to create the sensor
        :param sample_rate_hz: sample rate in hz of the data, default np.nan
        :param sample_interval_s: sample interval in seconds of the data, default np.nan
        :param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
        :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
        :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                        original values, default False
        :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                                default False
        :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                                use the best known offset.  default False
        :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
        :param base_dir: directory to save pyarrow table, default &#34;.&#34; (current dir).  internally uses a temporary
                            dir if not saving data
        :param use_temp_dir: if True, save the data using a temporary directory.  default False
        :return: RedvoxSensor object
        &#34;&#34;&#34;
        return SensorData(sensor_name, data.create_timestamps(),
                          SensorType.AUDIO, sample_rate_hz, sample_interval_s, sample_interval_std_s,
                          is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                          use_offset_model_for_correction, save_data, base_dir, use_temp_dir=use_temp_dir)

    def get_microphone_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: audio data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;microphone&#39;)

    def get_valid_microphone_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan audio data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;microphone&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.sensor_data.AudioSensor.from_metadata"><code class="name flex">
<span>def <span class="ident">from_metadata</span></span>(<span>sensor_name: str, data: <a title="redvox.common.gap_and_pad_utils.AudioWithGaps" href="gap_and_pad_utils.html#redvox.common.gap_and_pad_utils.AudioWithGaps">AudioWithGaps</a>, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', use_temp_dir: bool = False) ‑> <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>init but using metadata</p>
<p>:param sensor_name: name of the sensor
:param data: the metadata used to create the sensor
:param sample_rate_hz: sample rate in hz of the data, default np.nan
:param sample_interval_s: sample interval in seconds of the data, default np.nan
:param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param use_temp_dir: if True, save the data using a temporary directory.
default False
:return: RedvoxSensor object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_metadata(sensor_name: str,
                  data: AudioWithGaps,
                  sample_rate_hz: float = np.nan,
                  sample_interval_s: float = np.nan,
                  sample_interval_std_s: float = np.nan,
                  is_sample_rate_fixed: bool = False,
                  are_timestamps_altered: bool = False,
                  calculate_stats: bool = False,
                  use_offset_model_for_correction: bool = False,
                  save_data: bool = False,
                  base_dir: str = &#34;.&#34;,
                  use_temp_dir: bool = False) -&gt; &#34;SensorData&#34;:
    &#34;&#34;&#34;
    init but using metadata

    :param sensor_name: name of the sensor
    :param data: the metadata used to create the sensor
    :param sample_rate_hz: sample rate in hz of the data, default np.nan
    :param sample_interval_s: sample interval in seconds of the data, default np.nan
    :param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
    :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
    :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                    original values, default False
    :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                            default False
    :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                            use the best known offset.  default False
    :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
    :param base_dir: directory to save pyarrow table, default &#34;.&#34; (current dir).  internally uses a temporary
                        dir if not saving data
    :param use_temp_dir: if True, save the data using a temporary directory.  default False
    :return: RedvoxSensor object
    &#34;&#34;&#34;
    return SensorData(sensor_name, data.create_timestamps(),
                      SensorType.AUDIO, sample_rate_hz, sample_interval_s, sample_interval_std_s,
                      is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                      use_offset_model_for_correction, save_data, base_dir, use_temp_dir=use_temp_dir)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.AudioSensor.get_microphone_data"><code class="name flex">
<span>def <span class="ident">get_microphone_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: audio data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_microphone_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: audio data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;microphone&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.AudioSensor.get_valid_microphone_data"><code class="name flex">
<span>def <span class="ident">get_valid_microphone_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan audio data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_microphone_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan audio data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;microphone&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor"><code class="flex name class">
<span>class <span class="ident">BestLocationSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Best-location specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BestLocationSensor(SensorData):
    &#34;&#34;&#34;
    Best-location specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.BEST_LOCATION, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_gps_timestamps_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gps timestamps as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gps_timestamps&#39;)

    def get_valid_gps_timestamps_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gps timestamps as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gps_timestamps&#39;)

    def get_latitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: latitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;latitude&#39;)

    def get_valid_latitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan latitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;latitude&#39;)

    def get_longitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: longitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;longitude&#39;)

    def get_valid_longitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan longitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;longitude&#39;)

    def get_altitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: altitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;altitude&#39;)

    def get_valid_altitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan altitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;altitude&#39;)

    def get_speed_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: speed data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;speed&#39;)

    def get_valid_speed_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan speed data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;speed&#39;)

    def get_bearing_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: bearing data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;bearing&#39;)

    def get_valid_bearing_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan bearing data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;bearing&#39;)

    def get_horizontal_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: horizontal accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;horizontal_accuracy&#39;)

    def get_valid_horizontal_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan horizontal accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;horizontal_accuracy&#39;)

    def get_vertical_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: vertical accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;vertical_accuracy&#39;)

    def get_valid_vertical_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan vertical accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;vertical_accuracy&#39;)

    def get_speed_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: speed accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;speed_accuracy&#39;)

    def get_valid_speed_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan speed accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;speed_accuracy&#39;)

    def get_bearing_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: bearing accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;bearing_accuracy&#39;)

    def get_valid_bearing_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan bearing accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;bearing_accuracy&#39;)

    def get_location_provider_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: location provider data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;location_provider&#39;)

    def get_valid_location_provider_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan location provider data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;location_provider&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_altitude_data"><code class="name flex">
<span>def <span class="ident">get_altitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: altitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_altitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: altitude data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;altitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_bearing_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_bearing_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: bearing accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bearing_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: bearing accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;bearing_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_bearing_data"><code class="name flex">
<span>def <span class="ident">get_bearing_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: bearing data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bearing_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: bearing data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;bearing&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_gps_timestamps_data"><code class="name flex">
<span>def <span class="ident">get_gps_timestamps_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: gps timestamps as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gps_timestamps_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: gps timestamps as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;gps_timestamps&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_horizontal_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_horizontal_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: horizontal accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_horizontal_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: horizontal accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;horizontal_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_latitude_data"><code class="name flex">
<span>def <span class="ident">get_latitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: latitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: latitude data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;latitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_location_provider_data"><code class="name flex">
<span>def <span class="ident">get_location_provider_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: location provider data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_location_provider_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: location provider data as list of strings
    &#34;&#34;&#34;
    return super()._get_non_numeric_data_channel(&#39;location_provider&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_longitude_data"><code class="name flex">
<span>def <span class="ident">get_longitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: longitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_longitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: longitude data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;longitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_speed_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_speed_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: speed accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_speed_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: speed accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;speed_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_speed_data"><code class="name flex">
<span>def <span class="ident">get_speed_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: speed data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_speed_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: speed data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;speed&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_altitude_data"><code class="name flex">
<span>def <span class="ident">get_valid_altitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan altitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_altitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan altitude data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;altitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_bearing_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_valid_bearing_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan bearing accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_bearing_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan bearing accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;bearing_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_bearing_data"><code class="name flex">
<span>def <span class="ident">get_valid_bearing_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan bearing data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_bearing_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan bearing data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;bearing&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_gps_timestamps_data"><code class="name flex">
<span>def <span class="ident">get_valid_gps_timestamps_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan gps timestamps as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_gps_timestamps_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan gps timestamps as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;gps_timestamps&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_horizontal_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_valid_horizontal_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan horizontal accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_horizontal_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan horizontal accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;horizontal_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_latitude_data"><code class="name flex">
<span>def <span class="ident">get_valid_latitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan latitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_latitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan latitude data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;latitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_location_provider_data"><code class="name flex">
<span>def <span class="ident">get_valid_location_provider_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>NOT IMPLEMENTED
:return: non-nan location provider data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_location_provider_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    NOT IMPLEMENTED
    :return: non-nan location provider data as list of strings
    &#34;&#34;&#34;
    pass
    # return super().get_valid_data_channel_values(&#39;location_provider&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_longitude_data"><code class="name flex">
<span>def <span class="ident">get_valid_longitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan longitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_longitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan longitude data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;longitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_speed_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_valid_speed_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan speed accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_speed_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan speed accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;speed_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_speed_data"><code class="name flex">
<span>def <span class="ident">get_valid_speed_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan speed data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_speed_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan speed data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;speed&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_valid_vertical_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_valid_vertical_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan vertical accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_vertical_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan vertical accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;vertical_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.BestLocationSensor.get_vertical_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_vertical_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: vertical accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertical_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: vertical accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;vertical_accuracy&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.CompressedAudioSensor"><code class="flex name class">
<span>class <span class="ident">CompressedAudioSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compressed audio specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompressedAudioSensor(SensorData):
    &#34;&#34;&#34;
    Compressed audio specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.COMPRESSED_AUDIO, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_compressed_audio_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: compressed audio data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;compressed_audio&#39;)

    def get_valid_compressed_audio_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan compressed audio data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;compressed_audio&#39;)

    def get_audio_codec_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: audio codec as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;audio_codec&#39;)

    def _get_valid_audio_codec_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan audio codec as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;audio_codec&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.CompressedAudioSensor.get_audio_codec_data"><code class="name flex">
<span>def <span class="ident">get_audio_codec_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: audio codec as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_audio_codec_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: audio codec as list of strings
    &#34;&#34;&#34;
    return super()._get_non_numeric_data_channel(&#39;audio_codec&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.CompressedAudioSensor.get_compressed_audio_data"><code class="name flex">
<span>def <span class="ident">get_compressed_audio_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: compressed audio data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_compressed_audio_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: compressed audio data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;compressed_audio&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.CompressedAudioSensor.get_valid_compressed_audio_data"><code class="name flex">
<span>def <span class="ident">get_valid_compressed_audio_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan compressed audio data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_compressed_audio_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan compressed audio data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;compressed_audio&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.GravitySensor"><code class="flex name class">
<span>class <span class="ident">GravitySensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gravity specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GravitySensor(SensorData):
    &#34;&#34;&#34;
    Gravity specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.GRAVITY, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_gravity_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gravity x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gravity_x&#39;)

    def get_valid_gravity_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gravity x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gravity_x&#39;)

    def get_gravity_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gravity y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gravity_y&#39;)

    def get_valid_gravity_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gravity y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gravity_y&#39;)

    def get_gravity_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gravity z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gravity_z&#39;)

    def get_valid_gravity_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gravity z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gravity_z&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.GravitySensor.get_gravity_x_data"><code class="name flex">
<span>def <span class="ident">get_gravity_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: gravity x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gravity_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: gravity x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;gravity_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GravitySensor.get_gravity_y_data"><code class="name flex">
<span>def <span class="ident">get_gravity_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: gravity y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gravity_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: gravity y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;gravity_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GravitySensor.get_gravity_z_data"><code class="name flex">
<span>def <span class="ident">get_gravity_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: gravity z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gravity_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: gravity z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;gravity_z&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GravitySensor.get_valid_gravity_x_data"><code class="name flex">
<span>def <span class="ident">get_valid_gravity_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan gravity x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_gravity_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan gravity x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;gravity_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GravitySensor.get_valid_gravity_y_data"><code class="name flex">
<span>def <span class="ident">get_valid_gravity_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan gravity y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_gravity_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan gravity y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;gravity_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GravitySensor.get_valid_gravity_z_data"><code class="name flex">
<span>def <span class="ident">get_valid_gravity_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan gravity z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_gravity_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan gravity z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;gravity_z&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.GyroscopeSensor"><code class="flex name class">
<span>class <span class="ident">GyroscopeSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gyroscope specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GyroscopeSensor(SensorData):
    &#34;&#34;&#34;
    Gyroscope specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.GYROSCOPE, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_gyroscope_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gyroscope x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gyroscope_x&#39;)

    def get_valid_gyroscope_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gyroscope x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gyroscope_x&#39;)

    def get_gyroscope_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gyroscope y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gyroscope_y&#39;)

    def get_valid_gyroscope_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gyroscope y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gyroscope_y&#39;)

    def get_gyroscope_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gyroscope z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gyroscope_z&#39;)

    def get_valid_gyroscope_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gyroscope z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gyroscope_z&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.GyroscopeSensor.get_gyroscope_x_data"><code class="name flex">
<span>def <span class="ident">get_gyroscope_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: gyroscope x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gyroscope_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: gyroscope x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;gyroscope_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GyroscopeSensor.get_gyroscope_y_data"><code class="name flex">
<span>def <span class="ident">get_gyroscope_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: gyroscope y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gyroscope_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: gyroscope y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;gyroscope_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GyroscopeSensor.get_gyroscope_z_data"><code class="name flex">
<span>def <span class="ident">get_gyroscope_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: gyroscope z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gyroscope_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: gyroscope z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;gyroscope_z&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GyroscopeSensor.get_valid_gyroscope_x_data"><code class="name flex">
<span>def <span class="ident">get_valid_gyroscope_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan gyroscope x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_gyroscope_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan gyroscope x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;gyroscope_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GyroscopeSensor.get_valid_gyroscope_y_data"><code class="name flex">
<span>def <span class="ident">get_valid_gyroscope_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan gyroscope y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_gyroscope_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan gyroscope y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;gyroscope_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.GyroscopeSensor.get_valid_gyroscope_z_data"><code class="name flex">
<span>def <span class="ident">get_valid_gyroscope_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan gyroscope z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_gyroscope_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan gyroscope z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;gyroscope_z&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.ImageSensor"><code class="flex name class">
<span>class <span class="ident">ImageSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Image specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageSensor(SensorData):
    &#34;&#34;&#34;
    Image specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.IMAGE, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_image_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: image data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;image&#39;)

    def get_valid_image_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan image data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;image&#39;)

    def get_image_codec_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: image codec as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;image_codec&#39;)

    def get_valid_image_codec_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan image codec as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;image_codec&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.ImageSensor.get_image_codec_data"><code class="name flex">
<span>def <span class="ident">get_image_codec_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: image codec as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image_codec_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: image codec as list of strings
    &#34;&#34;&#34;
    return super()._get_non_numeric_data_channel(&#39;image_codec&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.ImageSensor.get_image_data"><code class="name flex">
<span>def <span class="ident">get_image_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: image data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: image data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;image&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.ImageSensor.get_valid_image_codec_data"><code class="name flex">
<span>def <span class="ident">get_valid_image_codec_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>NOT IMPLEMENTED
:return: non-nan image codec as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_image_codec_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    NOT IMPLEMENTED
    :return: non-nan image codec as list of strings
    &#34;&#34;&#34;
    pass
    # return super().get_valid_data_channel_values(&#39;image_codec&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.ImageSensor.get_valid_image_data"><code class="name flex">
<span>def <span class="ident">get_valid_image_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan image data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_image_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan image data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;image&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.LightSensor"><code class="flex name class">
<span>class <span class="ident">LightSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Light specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LightSensor(SensorData):
    &#34;&#34;&#34;
    Light specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.LIGHT, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_light_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: light data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;light&#39;)

    def get_valid_light_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan light data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;light&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.LightSensor.get_light_data"><code class="name flex">
<span>def <span class="ident">get_light_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: light data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_light_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: light data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;light&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LightSensor.get_valid_light_data"><code class="name flex">
<span>def <span class="ident">get_valid_light_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan light data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_light_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan light data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;light&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.LinearAccelerationSensor"><code class="flex name class">
<span>class <span class="ident">LinearAccelerationSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Linear acceleration specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearAccelerationSensor(SensorData):
    &#34;&#34;&#34;
    Linear acceleration specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.LINEAR_ACCELERATION, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_linear_acceleration_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: linear acceleration x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;linear_acceleration_x&#39;)

    def get_valid_linear_acceleration_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan linear acceleration x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;linear_acceleration_x&#39;)

    def get_linear_acceleration_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: linear acceleration y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;linear_acceleration_y&#39;)

    def get_valid_linear_acceleration_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan linear acceleration y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;linear_acceleration_y&#39;)

    def get_linear_acceleration_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: linear acceleration z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;linear_acceleration_z&#39;)

    def get_valid_linear_acceleration_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan linear acceleration z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;linear_acceleration_z&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.LinearAccelerationSensor.get_linear_acceleration_x_data"><code class="name flex">
<span>def <span class="ident">get_linear_acceleration_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: linear acceleration x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_linear_acceleration_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: linear acceleration x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;linear_acceleration_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LinearAccelerationSensor.get_linear_acceleration_y_data"><code class="name flex">
<span>def <span class="ident">get_linear_acceleration_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: linear acceleration y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_linear_acceleration_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: linear acceleration y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;linear_acceleration_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LinearAccelerationSensor.get_linear_acceleration_z_data"><code class="name flex">
<span>def <span class="ident">get_linear_acceleration_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: linear acceleration z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_linear_acceleration_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: linear acceleration z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;linear_acceleration_z&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LinearAccelerationSensor.get_valid_linear_acceleration_x_data"><code class="name flex">
<span>def <span class="ident">get_valid_linear_acceleration_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan linear acceleration x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_linear_acceleration_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan linear acceleration x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;linear_acceleration_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LinearAccelerationSensor.get_valid_linear_acceleration_y_data"><code class="name flex">
<span>def <span class="ident">get_valid_linear_acceleration_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan linear acceleration y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_linear_acceleration_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan linear acceleration y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;linear_acceleration_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LinearAccelerationSensor.get_valid_linear_acceleration_z_data"><code class="name flex">
<span>def <span class="ident">get_valid_linear_acceleration_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan linear acceleration z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_linear_acceleration_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan linear acceleration z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;linear_acceleration_z&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor"><code class="flex name class">
<span>class <span class="ident">LocationSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Location specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocationSensor(SensorData):
    &#34;&#34;&#34;
    Location specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.LOCATION, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_gps_timestamps_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: gps timestamps as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;gps_timestamps&#39;)

    def get_valid_gps_timestamps_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan gps timestamps as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;gps_timestamps&#39;)

    def get_latitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: latitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;latitude&#39;)

    def get_valid_latitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan latitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;latitude&#39;)

    def get_longitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: longitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;longitude&#39;)

    def get_valid_longitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan longitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;longitude&#39;)

    def get_altitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: altitude data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;altitude&#39;)

    def get_valid_altitude_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan altitude data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;altitude&#39;)

    def get_speed_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: speed data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;speed&#39;)

    def get_valid_speed_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan speed data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;speed&#39;)

    def get_bearing_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: bearing data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;bearing&#39;)

    def get_valid_bearing_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan bearing data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;bearing&#39;)

    def get_horizontal_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: horizontal accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;horizontal_accuracy&#39;)

    def get_valid_horizontal_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan horizontal accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;horizontal_accuracy&#39;)

    def get_vertical_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: vertical accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;vertical_accuracy&#39;)

    def get_valid_vertical_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan vertical accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;vertical_accuracy&#39;)

    def get_speed_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: speed accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;speed_accuracy&#39;)

    def get_valid_speed_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan speed accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;speed_accuracy&#39;)

    def get_bearing_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: bearing accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;bearing_accuracy&#39;)

    def get_valid_bearing_accuracy_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan bearing accuracy data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;bearing_accuracy&#39;)

    def get_location_provider_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: location provider data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;location_provider&#39;)

    def get_valid_location_provider_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan location provider data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;location_provider&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.LocationSensor.get_altitude_data"><code class="name flex">
<span>def <span class="ident">get_altitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: altitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_altitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: altitude data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;altitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_bearing_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_bearing_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: bearing accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bearing_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: bearing accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;bearing_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_bearing_data"><code class="name flex">
<span>def <span class="ident">get_bearing_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: bearing data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bearing_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: bearing data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;bearing&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_gps_timestamps_data"><code class="name flex">
<span>def <span class="ident">get_gps_timestamps_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: gps timestamps as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gps_timestamps_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: gps timestamps as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;gps_timestamps&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_horizontal_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_horizontal_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: horizontal accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_horizontal_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: horizontal accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;horizontal_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_latitude_data"><code class="name flex">
<span>def <span class="ident">get_latitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: latitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: latitude data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;latitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_location_provider_data"><code class="name flex">
<span>def <span class="ident">get_location_provider_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: location provider data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_location_provider_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: location provider data as list of strings
    &#34;&#34;&#34;
    return super()._get_non_numeric_data_channel(&#39;location_provider&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_longitude_data"><code class="name flex">
<span>def <span class="ident">get_longitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: longitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_longitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: longitude data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;longitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_speed_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_speed_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: speed accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_speed_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: speed accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;speed_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_speed_data"><code class="name flex">
<span>def <span class="ident">get_speed_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: speed data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_speed_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: speed data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;speed&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_altitude_data"><code class="name flex">
<span>def <span class="ident">get_valid_altitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan altitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_altitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan altitude data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;altitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_bearing_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_valid_bearing_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan bearing accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_bearing_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan bearing accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;bearing_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_bearing_data"><code class="name flex">
<span>def <span class="ident">get_valid_bearing_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan bearing data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_bearing_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan bearing data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;bearing&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_gps_timestamps_data"><code class="name flex">
<span>def <span class="ident">get_valid_gps_timestamps_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan gps timestamps as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_gps_timestamps_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan gps timestamps as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;gps_timestamps&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_horizontal_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_valid_horizontal_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan horizontal accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_horizontal_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan horizontal accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;horizontal_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_latitude_data"><code class="name flex">
<span>def <span class="ident">get_valid_latitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan latitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_latitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan latitude data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;latitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_location_provider_data"><code class="name flex">
<span>def <span class="ident">get_valid_location_provider_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>NOT IMPLEMENTED
:return: non-nan location provider data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_location_provider_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    NOT IMPLEMENTED
    :return: non-nan location provider data as list of strings
    &#34;&#34;&#34;
    pass
    # return super().get_valid_data_channel_values(&#39;location_provider&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_longitude_data"><code class="name flex">
<span>def <span class="ident">get_valid_longitude_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan longitude data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_longitude_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan longitude data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;longitude&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_speed_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_valid_speed_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan speed accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_speed_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan speed accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;speed_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_speed_data"><code class="name flex">
<span>def <span class="ident">get_valid_speed_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan speed data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_speed_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan speed data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;speed&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_valid_vertical_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_valid_vertical_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan vertical accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_vertical_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan vertical accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;vertical_accuracy&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.LocationSensor.get_vertical_accuracy_data"><code class="name flex">
<span>def <span class="ident">get_vertical_accuracy_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: vertical accuracy data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertical_accuracy_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: vertical accuracy data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;vertical_accuracy&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.MagnetometerSensor"><code class="flex name class">
<span>class <span class="ident">MagnetometerSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Magnetometer specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MagnetometerSensor(SensorData):
    &#34;&#34;&#34;
    Magnetometer specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.MAGNETOMETER, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_magnetometer_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: magnetometer x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;magnetometer_x&#39;)

    def get_valid_magnetometer_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan magnetometer x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;magnetometer_x&#39;)

    def get_magnetometer_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: magnetometer y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;magnetometer_y&#39;)

    def get_valid_magnetometer_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan magnetometer y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;magnetometer_y&#39;)

    def get_magnetometer_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: magnetometer z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;magnetometer_z&#39;)

    def get_valid_magnetometer_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan magnetometer z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;magnetometer_z&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.MagnetometerSensor.get_magnetometer_x_data"><code class="name flex">
<span>def <span class="ident">get_magnetometer_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: magnetometer x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_magnetometer_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: magnetometer x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;magnetometer_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.MagnetometerSensor.get_magnetometer_y_data"><code class="name flex">
<span>def <span class="ident">get_magnetometer_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: magnetometer y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_magnetometer_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: magnetometer y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;magnetometer_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.MagnetometerSensor.get_magnetometer_z_data"><code class="name flex">
<span>def <span class="ident">get_magnetometer_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: magnetometer z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_magnetometer_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: magnetometer z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;magnetometer_z&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.MagnetometerSensor.get_valid_magnetometer_x_data"><code class="name flex">
<span>def <span class="ident">get_valid_magnetometer_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan magnetometer x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_magnetometer_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan magnetometer x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;magnetometer_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.MagnetometerSensor.get_valid_magnetometer_y_data"><code class="name flex">
<span>def <span class="ident">get_valid_magnetometer_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan magnetometer y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_magnetometer_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan magnetometer y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;magnetometer_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.MagnetometerSensor.get_valid_magnetometer_z_data"><code class="name flex">
<span>def <span class="ident">get_valid_magnetometer_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan magnetometer z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_magnetometer_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan magnetometer z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;magnetometer_z&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.OrientationSensor"><code class="flex name class">
<span>class <span class="ident">OrientationSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Orientation specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OrientationSensor(SensorData):
    &#34;&#34;&#34;
    Orientation specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.ORIENTATION, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_orientation_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: orientation x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;orientation_x&#39;)

    def get_valid_orientation_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan orientation x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;orientation_x&#39;)

    def get_orientation_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: orientation y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;orientation_y&#39;)

    def get_valid_orientation_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan orientation y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;orientation_y&#39;)

    def get_orientation_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: orientation z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;orientation_z&#39;)

    def get_valid_orientation_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan orientation z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;orientation_z&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.OrientationSensor.get_orientation_x_data"><code class="name flex">
<span>def <span class="ident">get_orientation_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: orientation x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_orientation_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: orientation x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;orientation_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.OrientationSensor.get_orientation_y_data"><code class="name flex">
<span>def <span class="ident">get_orientation_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: orientation y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_orientation_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: orientation y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;orientation_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.OrientationSensor.get_orientation_z_data"><code class="name flex">
<span>def <span class="ident">get_orientation_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: orientation z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_orientation_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: orientation z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;orientation_z&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.OrientationSensor.get_valid_orientation_x_data"><code class="name flex">
<span>def <span class="ident">get_valid_orientation_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan orientation x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_orientation_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan orientation x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;orientation_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.OrientationSensor.get_valid_orientation_y_data"><code class="name flex">
<span>def <span class="ident">get_valid_orientation_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan orientation y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_orientation_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan orientation y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;orientation_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.OrientationSensor.get_valid_orientation_z_data"><code class="name flex">
<span>def <span class="ident">get_valid_orientation_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan orientation z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_orientation_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan orientation z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;orientation_z&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.PressureSensor"><code class="flex name class">
<span>class <span class="ident">PressureSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Pressure specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PressureSensor(SensorData):
    &#34;&#34;&#34;
    Pressure specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.PRESSURE, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_pressure_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: pressure data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;pressure&#39;)

    def get_valid_pressure_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan pressure data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;pressure&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.PressureSensor.get_pressure_data"><code class="name flex">
<span>def <span class="ident">get_pressure_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: pressure data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pressure_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: pressure data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;pressure&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.PressureSensor.get_valid_pressure_data"><code class="name flex">
<span>def <span class="ident">get_valid_pressure_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan pressure data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_pressure_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan pressure data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;pressure&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.ProximitySensor"><code class="flex name class">
<span>class <span class="ident">ProximitySensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Proximity specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProximitySensor(SensorData):
    &#34;&#34;&#34;
    Proximity specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.PROXIMITY, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_proximity_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: proximity data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;proximity&#39;)

    def get_valid_proximity_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan proximity data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;proximity&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.ProximitySensor.get_proximity_data"><code class="name flex">
<span>def <span class="ident">get_proximity_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: proximity data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proximity_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: proximity data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;proximity&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.ProximitySensor.get_valid_proximity_data"><code class="name flex">
<span>def <span class="ident">get_valid_proximity_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan proximity data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_proximity_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan proximity data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;proximity&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.RelativeHumiditySensor"><code class="flex name class">
<span>class <span class="ident">RelativeHumiditySensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Relative humidity specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelativeHumiditySensor(SensorData):
    &#34;&#34;&#34;
    Relative humidity specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.RELATIVE_HUMIDITY, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_relative_humidity_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: relative humidity data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;relative_humidity&#39;)

    def get_valid_relative_humidity_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan relative humidity data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;relative_humidity&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.RelativeHumiditySensor.get_relative_humidity_data"><code class="name flex">
<span>def <span class="ident">get_relative_humidity_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: relative humidity data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_relative_humidity_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: relative humidity data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;relative_humidity&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.RelativeHumiditySensor.get_valid_relative_humidity_data"><code class="name flex">
<span>def <span class="ident">get_valid_relative_humidity_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan relative humidity data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_relative_humidity_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan relative humidity data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;relative_humidity&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.RotationVectorSensor"><code class="flex name class">
<span>class <span class="ident">RotationVectorSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotation vector specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RotationVectorSensor(SensorData):
    &#34;&#34;&#34;
    Rotation vector specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.ROTATION_VECTOR, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_rotation_vector_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: rotation vector x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;rotation_vector_x&#39;)

    def get_valid_rotation_vector_x_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan rotation vector x channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;rotation_vector_x&#39;)

    def get_rotation_vector_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: rotation vector y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;rotation_vector_y&#39;)

    def get_valid_rotation_vector_y_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan rotation vector y channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;rotation_vector_y&#39;)

    def get_rotation_vector_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: rotation vector z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;rotation_vector_z&#39;)

    def get_valid_rotation_vector_z_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan rotation vector z channel data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;rotation_vector_z&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.RotationVectorSensor.get_rotation_vector_x_data"><code class="name flex">
<span>def <span class="ident">get_rotation_vector_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: rotation vector x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rotation_vector_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: rotation vector x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;rotation_vector_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.RotationVectorSensor.get_rotation_vector_y_data"><code class="name flex">
<span>def <span class="ident">get_rotation_vector_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: rotation vector y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rotation_vector_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: rotation vector y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;rotation_vector_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.RotationVectorSensor.get_rotation_vector_z_data"><code class="name flex">
<span>def <span class="ident">get_rotation_vector_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: rotation vector z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rotation_vector_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: rotation vector z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;rotation_vector_z&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.RotationVectorSensor.get_valid_rotation_vector_x_data"><code class="name flex">
<span>def <span class="ident">get_valid_rotation_vector_x_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan rotation vector x channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_rotation_vector_x_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan rotation vector x channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;rotation_vector_x&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.RotationVectorSensor.get_valid_rotation_vector_y_data"><code class="name flex">
<span>def <span class="ident">get_valid_rotation_vector_y_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan rotation vector y channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_rotation_vector_y_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan rotation vector y channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;rotation_vector_y&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.RotationVectorSensor.get_valid_rotation_vector_z_data"><code class="name flex">
<span>def <span class="ident">get_valid_rotation_vector_z_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan rotation vector z channel data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_rotation_vector_z_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan rotation vector z channel data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;rotation_vector_z&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="redvox.common.sensor_data.SensorData"><code class="flex name class">
<span>class <span class="ident">SensorData</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sensor_type: <a title="redvox.common.sensor_data.SensorType" href="#redvox.common.sensor_data.SensorType">SensorType</a> = SensorType.UNKNOWN_SENSOR, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False, use_temp_dir: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic RedvoxSensor class for API-independent analysis</p>
<h2 id="properties">Properties</h2>
<p>name: string, name of sensor.
REQUIRED</p>
<h2 id="protected">Protected</h2>
<p>_type: SensorType, enumerated type of sensor, default UNKNOWN_SENSOR</p>
<p>_sample_rate_hz: float, sample rate in Hz of the sensor, default np.nan, usually 1/sample_interval_s</p>
<p>_sample_interval_s: float, mean duration in seconds between samples, default np.nan, usually 1/sample_rate</p>
<p>_sample_interval_std_s: float, standard deviation in seconds between samples, default np.nan</p>
<p>_is_sample_rate_fixed: bool, True if sample rate is constant, default False</p>
<p>_timestamps_altered: bool, True if timestamps in the sensor have been altered from their original values
default False</p>
<p>_use_offset_model: bool, if True, use an offset model to correct timestamps, otherwise use the best known
offset.
default False</p>
<p>_errors: RedVoxExceptions, class containing a list of all errors encountered by the sensor.</p>
<p>_gaps: List of Tuples of floats, timestamps of data points on the edge of gaps, default empty list</p>
<p>_fs_writer: FileSystemWriter, handles file system i/o parameters</p>
<p>_data: pyarrow Table, used to store the data when it's not written to the disk.
default None</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorData:
    &#34;&#34;&#34;
    Generic RedvoxSensor class for API-independent analysis

    Properties:
        name: string, name of sensor.  REQUIRED

    Protected:
        _type: SensorType, enumerated type of sensor, default UNKNOWN_SENSOR

        _sample_rate_hz: float, sample rate in Hz of the sensor, default np.nan, usually 1/sample_interval_s

        _sample_interval_s: float, mean duration in seconds between samples, default np.nan, usually 1/sample_rate

        _sample_interval_std_s: float, standard deviation in seconds between samples, default np.nan

        _is_sample_rate_fixed: bool, True if sample rate is constant, default False

        _timestamps_altered: bool, True if timestamps in the sensor have been altered from their original values
        default False

        _use_offset_model: bool, if True, use an offset model to correct timestamps, otherwise use the best known
        offset.  default False

        _errors: RedVoxExceptions, class containing a list of all errors encountered by the sensor.

        _gaps: List of Tuples of floats, timestamps of data points on the edge of gaps, default empty list

        _fs_writer: FileSystemWriter, handles file system i/o parameters

        _data: pyarrow Table, used to store the data when it&#39;s not written to the disk.  default None
    &#34;&#34;&#34;

    def __init__(
            self,
            sensor_name: str,
            sensor_data: Optional[pa.Table] = None,
            sensor_type: SensorType = SensorType.UNKNOWN_SENSOR,
            sample_rate_hz: float = np.nan,
            sample_interval_s: float = np.nan,
            sample_interval_std_s: float = np.nan,
            is_sample_rate_fixed: bool = False,
            are_timestamps_altered: bool = False,
            calculate_stats: bool = False,
            use_offset_model_for_correction: bool = False,
            save_data: bool = False,
            base_dir: str = &#34;.&#34;,
            gaps: Optional[List[Tuple[float, float]]] = None,
            show_errors: bool = False,
            use_temp_dir: bool = False
    ):
        &#34;&#34;&#34;
        initialize the sensor data with params

        :param sensor_name: name of the sensor.  REQUIRED
        :param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
        :param sensor_data: Optional pyarrow table with the timestamps and sensor data;
                            first column is always the timestamps,
                            the other columns are specific metadata and data channels in the sensor
                            default is None
        :param sample_rate_hz: sample rate in hz of the data
        :param sample_interval_s: sample interval in seconds of the data
        :param sample_interval_std_s: std dev of sample interval in seconds of the data
        :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
        :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                        original values, default False
        :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                                default False
        :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                                use the best known offset.  default False
        :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
        :param base_dir: directory to save pyarrow table, default &#34;.&#34; (current dir).  internally uses a temporary
                            dir if not saving data
        :param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.  anything between
                        the pairs of points exists to maintain sample rate and are not considered valid points.
                        Default None
        :param show_errors: if True, show any errors encountered.  Default False
        :param use_temp_dir: if True, use a temp directory to save data.  Default False
        &#34;&#34;&#34;
        self._errors: RedVoxExceptions = RedVoxExceptions(&#34;Sensor&#34;)
        self.name: str = sensor_name
        self._type: SensorType = sensor_type
        self._sample_rate_hz: float = sample_rate_hz
        self._sample_interval_s: float = sample_interval_s
        self._sample_interval_std_s: float = sample_interval_std_s
        self._is_sample_rate_fixed: bool = is_sample_rate_fixed
        self._timestamps_altered: bool = are_timestamps_altered
        self._use_offset_model: bool = use_offset_model_for_correction
        if save_data:
            save_mode = FileSystemSaveMode.DISK
        elif use_temp_dir:
            save_mode = FileSystemSaveMode.TEMP
        else:
            save_mode = FileSystemSaveMode.MEM
        self._fs_writer = Fsw(&#34;&#34;, &#34;parquet&#34;, base_dir, save_mode)
        self._gaps: List[Tuple] = gaps if gaps else []
        set_data_as_sensor_data = True
        if sensor_data is not None:
            if &#34;timestamps&#34; not in sensor_data.schema.names:
                self._errors.append(&#39;must have a column titled &#34;timestamps&#34;&#39;)
            elif sensor_data[&#39;timestamps&#39;].length() &gt; 0:
                set_data_as_sensor_data = False
                if calculate_stats and np.isnan(sample_interval_s) and np.isnan(sample_rate_hz) \
                        and np.isnan(sample_interval_std_s):
                    self.organize_and_update_stats(sensor_data)
                elif sensor_data[&#34;timestamps&#34;].length() &gt; 1:
                    self.sort_by_data_timestamps(sensor_data)
                else:
                    self.write_pyarrow_table(sensor_data)
        if set_data_as_sensor_data:
            self._data = sensor_data
        if show_errors:
            self.print_errors()

    @staticmethod
    def from_dir(
            sensor_name: str,
            data_path: str,
            sensor_type: SensorType = SensorType.UNKNOWN_SENSOR,
            sample_rate_hz: float = np.nan,
            sample_interval_s: float = np.nan,
            sample_interval_std_s: float = np.nan,
            is_sample_rate_fixed: bool = False,
            are_timestamps_altered: bool = False,
            calculate_stats: bool = False,
            use_offset_model_for_correction: bool = False,
            save_data: bool = False,
            use_temp_dir: bool = False) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        init but with a path to directory containing parquet file(s) instead of a table of data

        :param sensor_name: name of the sensor
        :param data_path: path to the directory containing the parquet files
        :param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
        :param sample_rate_hz: sample rate in hz of the data, default np.nan
        :param sample_interval_s: sample interval in seconds of the data, default np.nan
        :param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
        :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
        :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                        original values, default False
        :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                                default False
        :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                                use the best known offset.  default False
        :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
        :param use_temp_dir: if True, save the data using a temporary directory.  default False
        :return: RedvoxSensor object
        &#34;&#34;&#34;
        result = SensorData(sensor_name,
                            ds.dataset(data_path, format=&#34;parquet&#34;, exclude_invalid_files=True).to_table(),
                            sensor_type, sample_rate_hz, sample_interval_s, sample_interval_std_s,
                            is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                            use_offset_model_for_correction, save_data, data_path, use_temp_dir=use_temp_dir)
        return result

    @staticmethod
    def from_dict(
            sensor_name: str,
            sensor_data: Dict,
            sensor_type: SensorType = SensorType.UNKNOWN_SENSOR,
            sample_rate_hz: float = np.nan,
            sample_interval_s: float = np.nan,
            sample_interval_std_s: float = np.nan,
            is_sample_rate_fixed: bool = False,
            are_timestamps_altered: bool = False,
            calculate_stats: bool = False,
            use_offset_model_for_correction: bool = False,
            save_data: bool = False,
            arrow_dir: str = &#34;&#34;,
            use_temp_dir: bool = False
    ) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        init but with a dictionary

        :param sensor_name: name of the sensor
        :param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
        :param sensor_data: dict with the timestamps and sensor data; first column is always the timestamps,
                            the other columns are the data channels in the sensor
        :param sample_rate_hz: sample rate in hz of the data, default np.nan
        :param sample_interval_s: sample interval in seconds of the data, default np.nan
        :param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
        :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
        :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                        original values, default False
        :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                                default False
        :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                                use the best known offset.  default False
        :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
        :param arrow_dir: directory to save pyarrow table, default &#34;&#34; (current dir).  default temporary dir if not
                            saving data
        :param use_temp_dir: If True, use a temporary directory to save the data.  default False
        :return: RedvoxSensor object
        &#34;&#34;&#34;
        return SensorData(sensor_name, pa.Table.from_pydict(sensor_data), sensor_type, sample_rate_hz,
                          sample_interval_s, sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered,
                          calculate_stats, use_offset_model_for_correction, save_data, arrow_dir,
                          use_temp_dir=use_temp_dir)

    def save(self, file_name: Optional[str] = None) -&gt; Optional[Path]:
        &#34;&#34;&#34;
        Saves the RedvoxSensor to disk.  Does nothing if saving is not enabled

        :param file_name: Optional file name to save RedvoxSensor as.  Do not include a file extension.  Default None
                            If None, a default file name is created using this format:
                            [sensor_type]_[first_timestamp].json
        :return: The path to the saved file or None if unable to save.
        &#34;&#34;&#34;
        if self._fs_writer.is_save_disk():
            return self.to_json_file(file_name)
        return None

    def load(self, in_dir: str) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        :param in_dir: structured directory with json metadata file to load
        :return: RedvoxSensor using data from files
        &#34;&#34;&#34;
        file = io.get_json_file(in_dir)
        if file is None:
            st = SensorData(&#34;LoadError&#34;)
            st.append_error(&#34;File to load Sensor not found.&#34;)
            return self
        else:
            return self.from_json_file(in_dir, file)

    def set_save_mode(self, new_save_mode: FileSystemSaveMode):
        &#34;&#34;&#34;
        changes the save mode to new_save_mode

        :param new_save_mode: FileSystemSaveMode to change to
        &#34;&#34;&#34;
        self._fs_writer.set_save_mode(new_save_mode)

    def is_save_to_disk(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: True if sensor will be saved to disk
        &#34;&#34;&#34;
        return self._fs_writer.is_use_disk()

    def set_save_to_disk(self, save: bool):
        &#34;&#34;&#34;
        :param save: If True, save to disk
        &#34;&#34;&#34;
        self._fs_writer.set_use_disk(save)

    def set_file_name(self, new_file: Optional[str] = None):
        &#34;&#34;&#34;
        * set the pyarrow file name or use the default: {sensor_type}_{int(first_timestamp)}
        * Do not give an extension

        :param new_file: optional file name to change to; default None (use default name)
        &#34;&#34;&#34;
        self._fs_writer.file_name = new_file if new_file else f&#34;{self._type.name}_{int(self.first_data_timestamp())}&#34;

    def full_file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: full name of parquet file containing the data
        &#34;&#34;&#34;
        return self._fs_writer.full_name()

    def file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: file name without extension
        &#34;&#34;&#34;
        return self._fs_writer.file_name

    def set_save_dir(self, new_dir: str = &#34;.&#34;):
        &#34;&#34;&#34;
        set the pyarrow directory or use the default: &#34;.&#34; (current directory)

        :param new_dir: the directory to change to; default &#34;.&#34; (use current directory)
        &#34;&#34;&#34;
        self._fs_writer.base_dir = new_dir

    def save_dir(self) -&gt; str:
        &#34;&#34;&#34;
        :return: directory containing parquet files for the sensor
        &#34;&#34;&#34;
        return self._fs_writer.save_dir()

    def full_path(self) -&gt; str:
        &#34;&#34;&#34;
        :return: the full path to the data file
        &#34;&#34;&#34;
        return self._fs_writer.full_path()

    def fs_writer(self) -&gt; Fsw:
        &#34;&#34;&#34;
        :return: FileSystemWriter object
        &#34;&#34;&#34;
        return self._fs_writer

    def set_use_temp_dir(self, use_temp_dir: bool = False):
        &#34;&#34;&#34;
        :param use_temp_dir: if True, use temp dir to save data.  default False
        &#34;&#34;&#34;
        self._fs_writer.set_use_temp(use_temp_dir)

    def pyarrow_ds(self, base_dir: Optional[str] = None) -&gt; ds.Dataset:
        &#34;&#34;&#34;
        :param base_dir: optional directory to use when loading the dataset.  if None, use self.save_dir()
        :return: the dataset stored in base_dir
        &#34;&#34;&#34;
        if base_dir is None:
            base_dir = self.save_dir()
        return ds.dataset(base_dir, format=&#34;parquet&#34;, exclude_invalid_files=True)

    def pyarrow_table(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the table defined by the _data property or the dataset stored in self.save_dir()
        &#34;&#34;&#34;
        if self._data or self._fs_writer.is_use_mem():
            return self._data
        return self.pyarrow_ds().to_table()

    def data_df(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        :return: the pandas dataframe defined by the dataset stored in self.save_dir()
        &#34;&#34;&#34;
        return self.pyarrow_table().to_pandas()

    def write_pyarrow_table(self, table: pa.Table, update_file_name: Optional[bool] = True):
        &#34;&#34;&#34;
        saves the pyarrow table to disk or to memory.

        * if there is no data or there is no column named timestamps in the table, an error will be created
        * if writing to disk, uses a default filename: {sensor_type}_{first_timestamp}.parquet
        * uses the directory defined by self.save_dir().  Creates the directory if it doesn&#39;t exist and removes any
        existing parquet files from the directory if it exists

        :param table: the table to write
        :param update_file_name: if True, updates the file name to match the new data.  Default True
        &#34;&#34;&#34;
        if table.num_rows &lt; 1 or &#34;timestamps&#34; not in table.schema.names:
            self._errors.append(&#34;Attempted to write invalid table.&#34;)
        elif self._fs_writer.is_save_disk():
            self._fs_writer.create_dir()
            if update_file_name:
                self.set_file_name(f&#34;{self.type().name}_{int(table[&#39;timestamps&#39;][0].as_py())}&#34;)
            pq.write_table(table, self.full_path())
            self._data = None
        else:
            self._data = table

    def move_pyarrow_dir(self, new_dir: str) -&gt; Path:
        &#34;&#34;&#34;
        Move the sensor&#39;s pyarrow files to a new directory

        :param new_dir: directory to save files into
        &#34;&#34;&#34;
        old_sensor_save_dir = self.save_dir()
        self.set_save_dir(os.path.join(new_dir, self._type.name))
        for r, d, f in os.walk(old_sensor_save_dir):
            for file in f:
                self._fs_writer.create_dir()
                os.rename(os.path.join(old_sensor_save_dir, file), os.path.join(self.save_dir(), file))
        return Path(self.save_dir())

    def errors(self) -&gt; RedVoxExceptions:
        &#34;&#34;&#34;
        :return: errors of the sensor
        &#34;&#34;&#34;
        return self._errors

    def gaps(self) -&gt; List[Tuple]:
        &#34;&#34;&#34;
        :return: start and end timestamps of gaps in data
        &#34;&#34;&#34;
        return self._gaps

    def type(self) -&gt; SensorType:
        &#34;&#34;&#34;
        :return: type of sensor
        &#34;&#34;&#34;
        return self._type

    def type_as_str(self) -&gt; str:
        &#34;&#34;&#34;
        gets the sensor type as a string

        :return: sensor type of the sensor as a string
        &#34;&#34;&#34;
        return self._type.name

    def sample_rate_hz(self) -&gt; float:
        &#34;&#34;&#34;
        :return: sample rate in Hz
        &#34;&#34;&#34;
        return self._sample_rate_hz

    def sample_interval_s(self) -&gt; float:
        &#34;&#34;&#34;
        :return: mean sample interval in seconds
        &#34;&#34;&#34;
        return self._sample_interval_s

    def sample_interval_std_s(self) -&gt; float:
        &#34;&#34;&#34;
        :return: sample interval standard deviation in seconds
        &#34;&#34;&#34;
        return self._sample_interval_std_s

    def is_sample_rate_fixed(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: true if sample rate of sensor is constant
        &#34;&#34;&#34;
        return self._is_sample_rate_fixed

    def is_timestamps_altered(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: true if timestamps have been changed from original data values
        &#34;&#34;&#34;
        return self._timestamps_altered

    def used_offset_model(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: true if an offset model was used to perform timestamp corrections
        &#34;&#34;&#34;
        return self._use_offset_model

    def sort_by_data_timestamps(self, ptable: pa.Table, ascending: bool = True):
        &#34;&#34;&#34;
        sorts the data based on timestamps

        :param ptable: pyarrow table to sort
        :param ascending: if True, timestamps are sorted in ascending order, else sort by descending order
        &#34;&#34;&#34;
        if ascending:
            order = &#34;ascending&#34;
        else:
            order = &#34;descending&#34;
        data = pc.take(ptable, pc.sort_indices(ptable, sort_keys=[(&#34;timestamps&#34;, order)]))
        self.write_pyarrow_table(data)

    def organize_and_update_stats(self, ptable: pa.Table) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        sorts the data by timestamps, then if the sample rate is not fixed, recalculates the sample rate, interval,
            and interval std dev.  If there is only one value, sets the sample rate, interval, and interval std dev
            to np.nan.  Updates the RedvoxSensor object with the new values

        :param ptable: pyarrow table to update
        :return: updated version of self
        &#34;&#34;&#34;
        self.sort_by_data_timestamps(ptable)
        if not self._is_sample_rate_fixed:
            if self.num_samples() &gt; 1:
                timestamp_diffs = np.diff(self.data_timestamps())
                self._sample_interval_s = dtu.microseconds_to_seconds(
                    float(np.mean(timestamp_diffs))
                )
                self._sample_interval_std_s = dtu.microseconds_to_seconds(
                    float(np.std(timestamp_diffs))
                )
                self._sample_rate_hz = (
                    np.nan
                    if self.is_sample_interval_invalid()
                    else 1 / self._sample_interval_s
                )
            else:
                self._sample_interval_s = np.nan
                self._sample_interval_std_s = np.nan
                self._sample_rate_hz = np.nan
        return self

    def append_sensor(self, new_sensor: &#34;SensorData&#34;, recalculate_stats: bool = False) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        append the new data to the sensor, update the sensor&#39;s stats on demand if it doesn&#39;t have a fixed
            sample rate, then return the updated RedvoxSensor object

        :param new_sensor: sensor containing data to add to the calling sensor
        :param recalculate_stats: if True and the sensor does not have a fixed sample rate, sort the timestamps,
                                    recalculate the sample rate, interval, and interval std dev, default False
        :return: the updated RedvoxSensor object
        &#34;&#34;&#34;
        _arrow: pa.Table = pa.concat_tables([self.pyarrow_table(), new_sensor.pyarrow_table()])
        if recalculate_stats and not self._is_sample_rate_fixed:
            self.organize_and_update_stats(_arrow)
        else:
            self.write_pyarrow_table(_arrow)
        return self

    def append_data(
            self, new_data: List[np.array], recalculate_stats: bool = False
    ) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        append the new data to the dataframe, update the sensor&#39;s stats on demand if it doesn&#39;t have a fixed
            sample rate, then return the updated RedvoxSensor object

        :param new_data: list of arrays containing data to add to the sensor&#39;s dataframe
        :param recalculate_stats: if True and the sensor does not have a fixed sample rate, sort the timestamps,
                                    recalculate the sample rate, interval, and interval std dev, default False
        :return: the updated RedvoxSensor object
        &#34;&#34;&#34;
        _arrow = pa.concat_tables([self.pyarrow_table(),
                                   pa.Table.from_arrays(arrays=[pa.array(s) for s in new_data],
                                                        names=self.data_channels())])
        if recalculate_stats and not self._is_sample_rate_fixed:
            self.organize_and_update_stats(_arrow)
        else:
            self.write_pyarrow_table(_arrow)
        return self

    def is_sample_interval_invalid(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: True if sample interval is np.nan or equal to 0.0
        &#34;&#34;&#34;
        return np.isnan(self._sample_interval_s) or self._sample_interval_s == 0.0

    def data_timestamps(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: the timestamps as a numpy array or [np.nan] if none exist
        &#34;&#34;&#34;
        if &#34;timestamps&#34; in self.pyarrow_table().schema.names:
            return self.pyarrow_table()[&#34;timestamps&#34;].to_numpy()
        else:
            return np.array([np.nan])

    def unaltered_data_timestamps(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: the unaltered timestamps as a numpy array
        &#34;&#34;&#34;
        if &#34;unaltered_timestamps&#34; in self.pyarrow_table().schema.names:
            return self.pyarrow_table()[&#34;unaltered_timestamps&#34;].to_numpy()
        else:
            return np.array([np.nan])

    def first_data_timestamp(self) -&gt; float:
        &#34;&#34;&#34;
        :return: timestamp of the first data point or np.nan if no timestamps
        &#34;&#34;&#34;
        return self.data_timestamps()[0]

    def last_data_timestamp(self) -&gt; float:
        &#34;&#34;&#34;
        :return: timestamp of the last data point or np.nan if no timestamps
        &#34;&#34;&#34;
        return self.data_timestamps()[-1]

    def num_samples(self) -&gt; int:
        &#34;&#34;&#34;
        :return: the number of rows (samples) in the dataframe
        &#34;&#34;&#34;
        if self.pyarrow_table():
            return self.pyarrow_table().num_rows
        return 0

    def samples(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        gets the non-timestamp samples of dataframe

        :return: the data values of the dataframe as a numpy ndarray
        &#34;&#34;&#34;
        return self.data_df().iloc[:, 2:].T.to_numpy()

    def data_channels(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: a list of the names of the columns (data channels) of the dataframe
        &#34;&#34;&#34;
        if self.pyarrow_table():
            return self.pyarrow_table().schema.names
        return []

    def get_data_channel(self, channel_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        gets the data channel specified, raises an error and lists valid fields if channel_name is not in the dataframe

        :param channel_name: the name of the channel to get data for
        :return: the data values of the channel as a numpy array or list of strings for enumerated channels
        &#34;&#34;&#34;
        if not self.pyarrow_table():
            self._errors.append(f&#34;WARNING: There are no channels to access in this Sensor!&#34;)
            return []
        _arrow = self.pyarrow_table()
        if channel_name not in _arrow.schema.names:
            self._errors.append(f&#34;WARNING: {channel_name} does not exist; try one of {_arrow.schema.names}&#34;)
            return []
        if channel_name in NON_NUMERIC_COLUMNS:
            return np.array([COLUMN_TO_ENUM_FN[channel_name](c.as_py()) for c in _arrow[channel_name]])
        return _arrow[channel_name].to_numpy()

    def _get_non_numeric_data_channel(self, channel_name: str) -&gt; List[str]:
        &#34;&#34;&#34;
        get_data_channel but specifically enumerated channels

        :param channel_name: the name of the channel to get data for
        :return: the data values of the channel as a list of strings
        &#34;&#34;&#34;
        if not self.pyarrow_table():
            self._errors.append(f&#34;WARNING: There are no channels to access in this Sensor!&#34;)
        else:
            _arrow = self.pyarrow_table()
            if channel_name in NON_NUMERIC_COLUMNS:
                return [COLUMN_TO_ENUM_FN[channel_name](c.as_py()) for c in _arrow[channel_name]]
        self._errors.append(f&#34;WARNING: {channel_name} does not exist&#34;)
        return []

    def get_valid_data_channel_values(self, channel_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        gets all non-nan values from the channel specified

        :param channel_name: the name of the channel to get data for
        :return: non-nan values of the channel as a numpy array
        &#34;&#34;&#34;
        channel_data = self.get_data_channel(channel_name)
        return channel_data[~np.isnan(channel_data)]

    def _get_valid_non_numeric_data_channel_values(self, channel_name: str) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        return non-nan&#39;d values; technically this evaluates an actual numeric channel first

        :param channel_name:
        :return:
        &#34;&#34;&#34;
        pass

    def print_errors(self):
        &#34;&#34;&#34;
        print all errors to screen
        &#34;&#34;&#34;
        self._errors.print()

    def extend_errors(self, errors: RedVoxExceptions):
        &#34;&#34;&#34;
        add errors to the Sensor&#39;s errors

        :param errors: errors to add
        &#34;&#34;&#34;
        self._errors.extend_error(errors)

    def update_data_timestamps(self, offset_model: om.OffsetModel):
        &#34;&#34;&#34;
        updates the timestamps of the data points

        :param offset_model: model used to update the timestamps
        &#34;&#34;&#34;
        slope = dtu.seconds_to_microseconds(self._sample_interval_s) * (1 + offset_model.slope) \
            if self._use_offset_model else dtu.seconds_to_microseconds(self._sample_interval_s)
        if self._type == SensorType.AUDIO:
            # use the model to update the first timestamp or add the best offset (model&#39;s intercept value)
            timestamps = pa.array(
                calc_evenly_sampled_timestamps(
                    offset_model.update_time(self.first_data_timestamp(), self._use_offset_model),
                    self.num_samples(),
                    slope))
        else:
            timestamps = pa.array(offset_model.update_timestamps(self.data_timestamps(),
                                                                 self._use_offset_model))
        # old_name = self.full_path()
        self.write_pyarrow_table(self.pyarrow_table().set_column(0, &#34;timestamps&#34;, timestamps))
        # self.set_file_name()
        # os.rename(old_name, self.full_path())
        time_diffs = np.floor(np.diff(self.data_timestamps()))
        if len(time_diffs) &gt; 1:
            self._sample_interval_s = dtu.microseconds_to_seconds(slope)
            if self._sample_interval_s &gt; 0:
                self._sample_rate_hz = 1 / self._sample_interval_s
                self._sample_interval_std_s = dtu.microseconds_to_seconds(float(np.std(time_diffs)))
        self._timestamps_altered = True

    def interpolate(self, interpolate_timestamp: float, first_point: int, second_point: int = 0,
                    copy: bool = True) -&gt; pa.Table:
        &#34;&#34;&#34;
        interpolates two points at the intercept value.  the two points must be consecutive in the data.
        data channels that can&#39;t be interpolated are set to np.nan.

        :param interpolate_timestamp: timestamp to interpolate other values
        :param first_point: index of first point
        :param second_point: delta to second point, default 0 (same as first point)
        :param copy: if True, copies the values of the first point, otherwise uses the interpolated value.
                        Default True
        :return: pyarrow Table of interpolated points
        &#34;&#34;&#34;
        start_point = self.pyarrow_table().slice(first_point, 1).to_pydict()
        if not copy and second_point:
            i_p = {}
            end_point = self.pyarrow_table().slice(first_point + second_point, 1).to_pydict()
            first_closer = \
                np.abs(start_point[0] - interpolate_timestamp) \
                &lt;= np.abs(end_point[0] - interpolate_timestamp)
            for col in self.pyarrow_table().schema.names:
                # process each column independently into new table object
                if col not in NON_INTERPOLATED_COLUMNS + NON_NUMERIC_COLUMNS:
                    numeric_diff = end_point[col] - start_point[col]
                    numeric_diff = \
                        (numeric_diff / numeric_diff[&#34;timestamps&#34;]) * \
                        (interpolate_timestamp - start_point[col]) + start_point[col]
                    i_p[col] = numeric_diff
                elif col in NON_NUMERIC_COLUMNS:
                    if first_closer:
                        i_p[col] = start_point[col]
                    else:
                        i_p[col] = end_point[col]
        else:
            i_p = start_point
        i_p[&#34;timestamps&#34;] = [interpolate_timestamp]
        return pa.Table.from_pydict(i_p)

    def as_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: sensor as dict
        &#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;type&#34;: self._type.name,
            &#34;num_samples&#34;: self.num_samples(),
            &#34;sample_rate_hz&#34;: self._sample_rate_hz,
            &#34;sample_interval_s&#34;: self._sample_interval_s,
            &#34;sample_interval_std_s&#34;: self._sample_interval_std_s,
            &#34;is_sample_rate_fixed&#34;: self._is_sample_rate_fixed,
            &#34;timestamps_altered&#34;: self._timestamps_altered,
            &#34;use_offset_model&#34;: self._use_offset_model,
            &#34;gaps&#34;: self._gaps,
            &#34;base_dir&#34;: os.path.basename(self._fs_writer.save_dir()),
            &#34;errors&#34;: self._errors.as_dict()
        }

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;
        :return: sensor as json string
        &#34;&#34;&#34;
        return io.to_json(self)

    def to_json_file(self, file_name: Optional[str] = None) -&gt; Path:
        &#34;&#34;&#34;
        saves the sensor as json and data in the same directory.

        :param file_name: the optional base file name.  Do not include a file extension.
                            If None, a default file name is created using this format:
                            [sensor_type]_[first_timestamp].json
        :return: path to json file
        &#34;&#34;&#34;
        self.write_pyarrow_table(self.pyarrow_table())
        return io.to_json_file(self, file_name)

    @staticmethod
    def from_json_file(file_dir: str, file_name: Optional[str] = None) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        convert contents of json file to Sensor

        :param file_dir: full path to containing directory for the file
        :param file_name: optional name of file and extension to load data from; if not specified, finds the first one
        :return: RedvoxSensor object
        &#34;&#34;&#34;
        if file_name is None:
            file_name = io.get_json_file(file_dir)
            if file_name is None:
                result = SensorData(&#34;Empty&#34;)
                result.append_error(&#34;JSON file to load Sensor from not found.&#34;)
                return result
        json_data = io.json_file_to_dict(os.path.join(file_dir, file_name))
        if &#34;name&#34; in json_data.keys():
            result = SensorData.from_dir(json_data[&#34;name&#34;], file_dir, SensorType[json_data[&#34;type&#34;]],
                                         json_data[&#34;sample_rate_hz&#34;], json_data[&#34;sample_interval_s&#34;],
                                         json_data[&#34;sample_interval_std_s&#34;], json_data[&#34;is_sample_rate_fixed&#34;],
                                         json_data[&#34;timestamps_altered&#34;], False, json_data[&#34;use_offset_model&#34;])
            result.set_errors(RedVoxExceptions.from_dict(json_data[&#34;errors&#34;]))
            result.set_save_to_disk(True)
            result.set_file_name()
            result.set_gaps(json_data[&#34;gaps&#34;])
        else:
            result = SensorData(&#34;Empty&#34;)
            result.append_error(f&#34;Loading from {file_name} failed; missing Sensor name.&#34;)
        return result

    def class_from_type(self) -&gt; &#34;SensorData&#34;:
        &#34;&#34;&#34;
        Updates the class to be a specific type of sensor based on self._type

        :return: Self
        &#34;&#34;&#34;
        if self._type in SensorType:
            sensor_class_from_type = {
                SensorType.AUDIO: AudioSensor,
                SensorType.COMPRESSED_AUDIO: CompressedAudioSensor,
                SensorType.IMAGE: ImageSensor,
                SensorType.LOCATION: LocationSensor,
                SensorType.BEST_LOCATION: BestLocationSensor,
                SensorType.STATION_HEALTH: StationHealthSensor,
                SensorType.LIGHT: LightSensor,
                SensorType.PRESSURE: PressureSensor,
                SensorType.PROXIMITY: ProximitySensor,
                SensorType.INFRARED: ProximitySensor,
                SensorType.RELATIVE_HUMIDITY: RelativeHumiditySensor,
                SensorType.AMBIENT_TEMPERATURE: AmbientTemperatureSensor,
                SensorType.ACCELEROMETER: AccelerometerSensor,
                SensorType.GYROSCOPE: GyroscopeSensor,
                SensorType.MAGNETOMETER: MagnetometerSensor,
                SensorType.ORIENTATION: OrientationSensor,
                SensorType.GRAVITY: GravitySensor,
                SensorType.LINEAR_ACCELERATION: LinearAccelerationSensor,
                SensorType.ROTATION_VECTOR: RotationVectorSensor,
                SensorType.UNKNOWN_SENSOR: SensorData
            }
            self.__class__ = sensor_class_from_type[self._type]
        return self

    def set_errors(self, errors: RedVoxExceptions):
        &#34;&#34;&#34;
        sets the errors of the Sensor

        :param errors: errors to set
        &#34;&#34;&#34;
        self._errors = errors

    def append_error(self, error: str):
        &#34;&#34;&#34;
        add an error to the Sensor

        :param error: error to add
        &#34;&#34;&#34;
        self._errors.append(error)

    def set_gaps(self, gaps: List[Tuple]):
        &#34;&#34;&#34;
        sets the gaps of the Sensor

        :param gaps: gaps to set
        &#34;&#34;&#34;
        self._gaps = gaps</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.AccelerometerSensor" href="#redvox.common.sensor_data.AccelerometerSensor">AccelerometerSensor</a></li>
<li><a title="redvox.common.sensor_data.AmbientTemperatureSensor" href="#redvox.common.sensor_data.AmbientTemperatureSensor">AmbientTemperatureSensor</a></li>
<li><a title="redvox.common.sensor_data.AudioSensor" href="#redvox.common.sensor_data.AudioSensor">AudioSensor</a></li>
<li><a title="redvox.common.sensor_data.BestLocationSensor" href="#redvox.common.sensor_data.BestLocationSensor">BestLocationSensor</a></li>
<li><a title="redvox.common.sensor_data.CompressedAudioSensor" href="#redvox.common.sensor_data.CompressedAudioSensor">CompressedAudioSensor</a></li>
<li><a title="redvox.common.sensor_data.GravitySensor" href="#redvox.common.sensor_data.GravitySensor">GravitySensor</a></li>
<li><a title="redvox.common.sensor_data.GyroscopeSensor" href="#redvox.common.sensor_data.GyroscopeSensor">GyroscopeSensor</a></li>
<li><a title="redvox.common.sensor_data.ImageSensor" href="#redvox.common.sensor_data.ImageSensor">ImageSensor</a></li>
<li><a title="redvox.common.sensor_data.LightSensor" href="#redvox.common.sensor_data.LightSensor">LightSensor</a></li>
<li><a title="redvox.common.sensor_data.LinearAccelerationSensor" href="#redvox.common.sensor_data.LinearAccelerationSensor">LinearAccelerationSensor</a></li>
<li><a title="redvox.common.sensor_data.LocationSensor" href="#redvox.common.sensor_data.LocationSensor">LocationSensor</a></li>
<li><a title="redvox.common.sensor_data.MagnetometerSensor" href="#redvox.common.sensor_data.MagnetometerSensor">MagnetometerSensor</a></li>
<li><a title="redvox.common.sensor_data.OrientationSensor" href="#redvox.common.sensor_data.OrientationSensor">OrientationSensor</a></li>
<li><a title="redvox.common.sensor_data.PressureSensor" href="#redvox.common.sensor_data.PressureSensor">PressureSensor</a></li>
<li><a title="redvox.common.sensor_data.ProximitySensor" href="#redvox.common.sensor_data.ProximitySensor">ProximitySensor</a></li>
<li><a title="redvox.common.sensor_data.RelativeHumiditySensor" href="#redvox.common.sensor_data.RelativeHumiditySensor">RelativeHumiditySensor</a></li>
<li><a title="redvox.common.sensor_data.RotationVectorSensor" href="#redvox.common.sensor_data.RotationVectorSensor">RotationVectorSensor</a></li>
<li><a title="redvox.common.sensor_data.StationHealthSensor" href="#redvox.common.sensor_data.StationHealthSensor">StationHealthSensor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.sensor_data.SensorData.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>sensor_name: str, sensor_data: Dict, sensor_type: <a title="redvox.common.sensor_data.SensorType" href="#redvox.common.sensor_data.SensorType">SensorType</a> = SensorType.UNKNOWN_SENSOR, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, arrow_dir: str = '', use_temp_dir: bool = False) ‑> <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>init but with a dictionary</p>
<p>:param sensor_name: name of the sensor
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: dict with the timestamps and sensor data; first column is always the timestamps,
the other columns are the data channels in the sensor
:param sample_rate_hz: sample rate in hz of the data, default np.nan
:param sample_interval_s: sample interval in seconds of the data, default np.nan
:param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param arrow_dir: directory to save pyarrow table, default "" (current dir).
default temporary dir if not
saving data
:param use_temp_dir: If True, use a temporary directory to save the data.
default False
:return: RedvoxSensor object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(
        sensor_name: str,
        sensor_data: Dict,
        sensor_type: SensorType = SensorType.UNKNOWN_SENSOR,
        sample_rate_hz: float = np.nan,
        sample_interval_s: float = np.nan,
        sample_interval_std_s: float = np.nan,
        is_sample_rate_fixed: bool = False,
        are_timestamps_altered: bool = False,
        calculate_stats: bool = False,
        use_offset_model_for_correction: bool = False,
        save_data: bool = False,
        arrow_dir: str = &#34;&#34;,
        use_temp_dir: bool = False
) -&gt; &#34;SensorData&#34;:
    &#34;&#34;&#34;
    init but with a dictionary

    :param sensor_name: name of the sensor
    :param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
    :param sensor_data: dict with the timestamps and sensor data; first column is always the timestamps,
                        the other columns are the data channels in the sensor
    :param sample_rate_hz: sample rate in hz of the data, default np.nan
    :param sample_interval_s: sample interval in seconds of the data, default np.nan
    :param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
    :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
    :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                    original values, default False
    :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                            default False
    :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                            use the best known offset.  default False
    :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
    :param arrow_dir: directory to save pyarrow table, default &#34;&#34; (current dir).  default temporary dir if not
                        saving data
    :param use_temp_dir: If True, use a temporary directory to save the data.  default False
    :return: RedvoxSensor object
    &#34;&#34;&#34;
    return SensorData(sensor_name, pa.Table.from_pydict(sensor_data), sensor_type, sample_rate_hz,
                      sample_interval_s, sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered,
                      calculate_stats, use_offset_model_for_correction, save_data, arrow_dir,
                      use_temp_dir=use_temp_dir)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.from_dir"><code class="name flex">
<span>def <span class="ident">from_dir</span></span>(<span>sensor_name: str, data_path: str, sensor_type: <a title="redvox.common.sensor_data.SensorType" href="#redvox.common.sensor_data.SensorType">SensorType</a> = SensorType.UNKNOWN_SENSOR, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, use_temp_dir: bool = False) ‑> <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>init but with a path to directory containing parquet file(s) instead of a table of data</p>
<p>:param sensor_name: name of the sensor
:param data_path: path to the directory containing the parquet files
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sample_rate_hz: sample rate in hz of the data, default np.nan
:param sample_interval_s: sample interval in seconds of the data, default np.nan
:param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param use_temp_dir: if True, save the data using a temporary directory.
default False
:return: RedvoxSensor object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dir(
        sensor_name: str,
        data_path: str,
        sensor_type: SensorType = SensorType.UNKNOWN_SENSOR,
        sample_rate_hz: float = np.nan,
        sample_interval_s: float = np.nan,
        sample_interval_std_s: float = np.nan,
        is_sample_rate_fixed: bool = False,
        are_timestamps_altered: bool = False,
        calculate_stats: bool = False,
        use_offset_model_for_correction: bool = False,
        save_data: bool = False,
        use_temp_dir: bool = False) -&gt; &#34;SensorData&#34;:
    &#34;&#34;&#34;
    init but with a path to directory containing parquet file(s) instead of a table of data

    :param sensor_name: name of the sensor
    :param data_path: path to the directory containing the parquet files
    :param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
    :param sample_rate_hz: sample rate in hz of the data, default np.nan
    :param sample_interval_s: sample interval in seconds of the data, default np.nan
    :param sample_interval_std_s: std dev of sample interval in seconds of the data, default np.nan
    :param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
    :param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
                                    original values, default False
    :param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
                            default False
    :param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
                                            use the best known offset.  default False
    :param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.  default False
    :param use_temp_dir: if True, save the data using a temporary directory.  default False
    :return: RedvoxSensor object
    &#34;&#34;&#34;
    result = SensorData(sensor_name,
                        ds.dataset(data_path, format=&#34;parquet&#34;, exclude_invalid_files=True).to_table(),
                        sensor_type, sample_rate_hz, sample_interval_s, sample_interval_std_s,
                        is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                        use_offset_model_for_correction, save_data, data_path, use_temp_dir=use_temp_dir)
    return result</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.from_json_file"><code class="name flex">
<span>def <span class="ident">from_json_file</span></span>(<span>file_dir: str, file_name: Optional[str] = None) ‑> <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>convert contents of json file to Sensor</p>
<p>:param file_dir: full path to containing directory for the file
:param file_name: optional name of file and extension to load data from; if not specified, finds the first one
:return: RedvoxSensor object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json_file(file_dir: str, file_name: Optional[str] = None) -&gt; &#34;SensorData&#34;:
    &#34;&#34;&#34;
    convert contents of json file to Sensor

    :param file_dir: full path to containing directory for the file
    :param file_name: optional name of file and extension to load data from; if not specified, finds the first one
    :return: RedvoxSensor object
    &#34;&#34;&#34;
    if file_name is None:
        file_name = io.get_json_file(file_dir)
        if file_name is None:
            result = SensorData(&#34;Empty&#34;)
            result.append_error(&#34;JSON file to load Sensor from not found.&#34;)
            return result
    json_data = io.json_file_to_dict(os.path.join(file_dir, file_name))
    if &#34;name&#34; in json_data.keys():
        result = SensorData.from_dir(json_data[&#34;name&#34;], file_dir, SensorType[json_data[&#34;type&#34;]],
                                     json_data[&#34;sample_rate_hz&#34;], json_data[&#34;sample_interval_s&#34;],
                                     json_data[&#34;sample_interval_std_s&#34;], json_data[&#34;is_sample_rate_fixed&#34;],
                                     json_data[&#34;timestamps_altered&#34;], False, json_data[&#34;use_offset_model&#34;])
        result.set_errors(RedVoxExceptions.from_dict(json_data[&#34;errors&#34;]))
        result.set_save_to_disk(True)
        result.set_file_name()
        result.set_gaps(json_data[&#34;gaps&#34;])
    else:
        result = SensorData(&#34;Empty&#34;)
        result.append_error(f&#34;Loading from {file_name} failed; missing Sensor name.&#34;)
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.SensorData.append_data"><code class="name flex">
<span>def <span class="ident">append_data</span></span>(<span>self, new_data: List[<built-in function array>], recalculate_stats: bool = False) ‑> <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>append the new data to the dataframe, update the sensor's stats on demand if it doesn't have a fixed
sample rate, then return the updated RedvoxSensor object</p>
<p>:param new_data: list of arrays containing data to add to the sensor's dataframe
:param recalculate_stats: if True and the sensor does not have a fixed sample rate, sort the timestamps,
recalculate the sample rate, interval, and interval std dev, default False
:return: the updated RedvoxSensor object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_data(
        self, new_data: List[np.array], recalculate_stats: bool = False
) -&gt; &#34;SensorData&#34;:
    &#34;&#34;&#34;
    append the new data to the dataframe, update the sensor&#39;s stats on demand if it doesn&#39;t have a fixed
        sample rate, then return the updated RedvoxSensor object

    :param new_data: list of arrays containing data to add to the sensor&#39;s dataframe
    :param recalculate_stats: if True and the sensor does not have a fixed sample rate, sort the timestamps,
                                recalculate the sample rate, interval, and interval std dev, default False
    :return: the updated RedvoxSensor object
    &#34;&#34;&#34;
    _arrow = pa.concat_tables([self.pyarrow_table(),
                               pa.Table.from_arrays(arrays=[pa.array(s) for s in new_data],
                                                    names=self.data_channels())])
    if recalculate_stats and not self._is_sample_rate_fixed:
        self.organize_and_update_stats(_arrow)
    else:
        self.write_pyarrow_table(_arrow)
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.append_error"><code class="name flex">
<span>def <span class="ident">append_error</span></span>(<span>self, error: str)</span>
</code></dt>
<dd>
<div class="desc"><p>add an error to the Sensor</p>
<p>:param error: error to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_error(self, error: str):
    &#34;&#34;&#34;
    add an error to the Sensor

    :param error: error to add
    &#34;&#34;&#34;
    self._errors.append(error)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.append_sensor"><code class="name flex">
<span>def <span class="ident">append_sensor</span></span>(<span>self, new_sensor: <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a>, recalculate_stats: bool = False) ‑> <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>append the new data to the sensor, update the sensor's stats on demand if it doesn't have a fixed
sample rate, then return the updated RedvoxSensor object</p>
<p>:param new_sensor: sensor containing data to add to the calling sensor
:param recalculate_stats: if True and the sensor does not have a fixed sample rate, sort the timestamps,
recalculate the sample rate, interval, and interval std dev, default False
:return: the updated RedvoxSensor object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_sensor(self, new_sensor: &#34;SensorData&#34;, recalculate_stats: bool = False) -&gt; &#34;SensorData&#34;:
    &#34;&#34;&#34;
    append the new data to the sensor, update the sensor&#39;s stats on demand if it doesn&#39;t have a fixed
        sample rate, then return the updated RedvoxSensor object

    :param new_sensor: sensor containing data to add to the calling sensor
    :param recalculate_stats: if True and the sensor does not have a fixed sample rate, sort the timestamps,
                                recalculate the sample rate, interval, and interval std dev, default False
    :return: the updated RedvoxSensor object
    &#34;&#34;&#34;
    _arrow: pa.Table = pa.concat_tables([self.pyarrow_table(), new_sensor.pyarrow_table()])
    if recalculate_stats and not self._is_sample_rate_fixed:
        self.organize_and_update_stats(_arrow)
    else:
        self.write_pyarrow_table(_arrow)
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>:return: sensor as dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    :return: sensor as dict
    &#34;&#34;&#34;
    return {
        &#34;name&#34;: self.name,
        &#34;type&#34;: self._type.name,
        &#34;num_samples&#34;: self.num_samples(),
        &#34;sample_rate_hz&#34;: self._sample_rate_hz,
        &#34;sample_interval_s&#34;: self._sample_interval_s,
        &#34;sample_interval_std_s&#34;: self._sample_interval_std_s,
        &#34;is_sample_rate_fixed&#34;: self._is_sample_rate_fixed,
        &#34;timestamps_altered&#34;: self._timestamps_altered,
        &#34;use_offset_model&#34;: self._use_offset_model,
        &#34;gaps&#34;: self._gaps,
        &#34;base_dir&#34;: os.path.basename(self._fs_writer.save_dir()),
        &#34;errors&#34;: self._errors.as_dict()
    }</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.class_from_type"><code class="name flex">
<span>def <span class="ident">class_from_type</span></span>(<span>self) ‑> <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Updates the class to be a specific type of sensor based on self._type</p>
<p>:return: Self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def class_from_type(self) -&gt; &#34;SensorData&#34;:
    &#34;&#34;&#34;
    Updates the class to be a specific type of sensor based on self._type

    :return: Self
    &#34;&#34;&#34;
    if self._type in SensorType:
        sensor_class_from_type = {
            SensorType.AUDIO: AudioSensor,
            SensorType.COMPRESSED_AUDIO: CompressedAudioSensor,
            SensorType.IMAGE: ImageSensor,
            SensorType.LOCATION: LocationSensor,
            SensorType.BEST_LOCATION: BestLocationSensor,
            SensorType.STATION_HEALTH: StationHealthSensor,
            SensorType.LIGHT: LightSensor,
            SensorType.PRESSURE: PressureSensor,
            SensorType.PROXIMITY: ProximitySensor,
            SensorType.INFRARED: ProximitySensor,
            SensorType.RELATIVE_HUMIDITY: RelativeHumiditySensor,
            SensorType.AMBIENT_TEMPERATURE: AmbientTemperatureSensor,
            SensorType.ACCELEROMETER: AccelerometerSensor,
            SensorType.GYROSCOPE: GyroscopeSensor,
            SensorType.MAGNETOMETER: MagnetometerSensor,
            SensorType.ORIENTATION: OrientationSensor,
            SensorType.GRAVITY: GravitySensor,
            SensorType.LINEAR_ACCELERATION: LinearAccelerationSensor,
            SensorType.ROTATION_VECTOR: RotationVectorSensor,
            SensorType.UNKNOWN_SENSOR: SensorData
        }
        self.__class__ = sensor_class_from_type[self._type]
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.data_channels"><code class="name flex">
<span>def <span class="ident">data_channels</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: a list of the names of the columns (data channels) of the dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_channels(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: a list of the names of the columns (data channels) of the dataframe
    &#34;&#34;&#34;
    if self.pyarrow_table():
        return self.pyarrow_table().schema.names
    return []</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.data_df"><code class="name flex">
<span>def <span class="ident">data_df</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the pandas dataframe defined by the dataset stored in self.save_dir()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_df(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    :return: the pandas dataframe defined by the dataset stored in self.save_dir()
    &#34;&#34;&#34;
    return self.pyarrow_table().to_pandas()</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.data_timestamps"><code class="name flex">
<span>def <span class="ident">data_timestamps</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: the timestamps as a numpy array or [np.nan] if none exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_timestamps(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: the timestamps as a numpy array or [np.nan] if none exist
    &#34;&#34;&#34;
    if &#34;timestamps&#34; in self.pyarrow_table().schema.names:
        return self.pyarrow_table()[&#34;timestamps&#34;].to_numpy()
    else:
        return np.array([np.nan])</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.errors"><code class="name flex">
<span>def <span class="ident">errors</span></span>(<span>self) ‑> <a title="redvox.common.errors.RedVoxExceptions" href="errors.html#redvox.common.errors.RedVoxExceptions">RedVoxExceptions</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: errors of the sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def errors(self) -&gt; RedVoxExceptions:
    &#34;&#34;&#34;
    :return: errors of the sensor
    &#34;&#34;&#34;
    return self._errors</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.extend_errors"><code class="name flex">
<span>def <span class="ident">extend_errors</span></span>(<span>self, errors: <a title="redvox.common.errors.RedVoxExceptions" href="errors.html#redvox.common.errors.RedVoxExceptions">RedVoxExceptions</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>add errors to the Sensor's errors</p>
<p>:param errors: errors to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_errors(self, errors: RedVoxExceptions):
    &#34;&#34;&#34;
    add errors to the Sensor&#39;s errors

    :param errors: errors to add
    &#34;&#34;&#34;
    self._errors.extend_error(errors)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.file_name"><code class="name flex">
<span>def <span class="ident">file_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: file name without extension</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_name(self) -&gt; str:
    &#34;&#34;&#34;
    :return: file name without extension
    &#34;&#34;&#34;
    return self._fs_writer.file_name</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.first_data_timestamp"><code class="name flex">
<span>def <span class="ident">first_data_timestamp</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: timestamp of the first data point or np.nan if no timestamps</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_data_timestamp(self) -&gt; float:
    &#34;&#34;&#34;
    :return: timestamp of the first data point or np.nan if no timestamps
    &#34;&#34;&#34;
    return self.data_timestamps()[0]</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.fs_writer"><code class="name flex">
<span>def <span class="ident">fs_writer</span></span>(<span>self) ‑> <a title="redvox.common.io.FileSystemWriter" href="io.html#redvox.common.io.FileSystemWriter">FileSystemWriter</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: FileSystemWriter object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fs_writer(self) -&gt; Fsw:
    &#34;&#34;&#34;
    :return: FileSystemWriter object
    &#34;&#34;&#34;
    return self._fs_writer</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.full_file_name"><code class="name flex">
<span>def <span class="ident">full_file_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: full name of parquet file containing the data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full_file_name(self) -&gt; str:
    &#34;&#34;&#34;
    :return: full name of parquet file containing the data
    &#34;&#34;&#34;
    return self._fs_writer.full_name()</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.full_path"><code class="name flex">
<span>def <span class="ident">full_path</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the full path to the data file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full_path(self) -&gt; str:
    &#34;&#34;&#34;
    :return: the full path to the data file
    &#34;&#34;&#34;
    return self._fs_writer.full_path()</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.gaps"><code class="name flex">
<span>def <span class="ident">gaps</span></span>(<span>self) ‑> List[Tuple]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: start and end timestamps of gaps in data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaps(self) -&gt; List[Tuple]:
    &#34;&#34;&#34;
    :return: start and end timestamps of gaps in data
    &#34;&#34;&#34;
    return self._gaps</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.get_data_channel"><code class="name flex">
<span>def <span class="ident">get_data_channel</span></span>(<span>self, channel_name: str) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>gets the data channel specified, raises an error and lists valid fields if channel_name is not in the dataframe</p>
<p>:param channel_name: the name of the channel to get data for
:return: the data values of the channel as a numpy array or list of strings for enumerated channels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_channel(self, channel_name: str) -&gt; np.array:
    &#34;&#34;&#34;
    gets the data channel specified, raises an error and lists valid fields if channel_name is not in the dataframe

    :param channel_name: the name of the channel to get data for
    :return: the data values of the channel as a numpy array or list of strings for enumerated channels
    &#34;&#34;&#34;
    if not self.pyarrow_table():
        self._errors.append(f&#34;WARNING: There are no channels to access in this Sensor!&#34;)
        return []
    _arrow = self.pyarrow_table()
    if channel_name not in _arrow.schema.names:
        self._errors.append(f&#34;WARNING: {channel_name} does not exist; try one of {_arrow.schema.names}&#34;)
        return []
    if channel_name in NON_NUMERIC_COLUMNS:
        return np.array([COLUMN_TO_ENUM_FN[channel_name](c.as_py()) for c in _arrow[channel_name]])
    return _arrow[channel_name].to_numpy()</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.get_valid_data_channel_values"><code class="name flex">
<span>def <span class="ident">get_valid_data_channel_values</span></span>(<span>self, channel_name: str) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>gets all non-nan values from the channel specified</p>
<p>:param channel_name: the name of the channel to get data for
:return: non-nan values of the channel as a numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_data_channel_values(self, channel_name: str) -&gt; np.array:
    &#34;&#34;&#34;
    gets all non-nan values from the channel specified

    :param channel_name: the name of the channel to get data for
    :return: non-nan values of the channel as a numpy array
    &#34;&#34;&#34;
    channel_data = self.get_data_channel(channel_name)
    return channel_data[~np.isnan(channel_data)]</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, interpolate_timestamp: float, first_point: int, second_point: int = 0, copy: bool = True) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>interpolates two points at the intercept value.
the two points must be consecutive in the data.
data channels that can't be interpolated are set to np.nan.</p>
<p>:param interpolate_timestamp: timestamp to interpolate other values
:param first_point: index of first point
:param second_point: delta to second point, default 0 (same as first point)
:param copy: if True, copies the values of the first point, otherwise uses the interpolated value.
Default True
:return: pyarrow Table of interpolated points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(self, interpolate_timestamp: float, first_point: int, second_point: int = 0,
                copy: bool = True) -&gt; pa.Table:
    &#34;&#34;&#34;
    interpolates two points at the intercept value.  the two points must be consecutive in the data.
    data channels that can&#39;t be interpolated are set to np.nan.

    :param interpolate_timestamp: timestamp to interpolate other values
    :param first_point: index of first point
    :param second_point: delta to second point, default 0 (same as first point)
    :param copy: if True, copies the values of the first point, otherwise uses the interpolated value.
                    Default True
    :return: pyarrow Table of interpolated points
    &#34;&#34;&#34;
    start_point = self.pyarrow_table().slice(first_point, 1).to_pydict()
    if not copy and second_point:
        i_p = {}
        end_point = self.pyarrow_table().slice(first_point + second_point, 1).to_pydict()
        first_closer = \
            np.abs(start_point[0] - interpolate_timestamp) \
            &lt;= np.abs(end_point[0] - interpolate_timestamp)
        for col in self.pyarrow_table().schema.names:
            # process each column independently into new table object
            if col not in NON_INTERPOLATED_COLUMNS + NON_NUMERIC_COLUMNS:
                numeric_diff = end_point[col] - start_point[col]
                numeric_diff = \
                    (numeric_diff / numeric_diff[&#34;timestamps&#34;]) * \
                    (interpolate_timestamp - start_point[col]) + start_point[col]
                i_p[col] = numeric_diff
            elif col in NON_NUMERIC_COLUMNS:
                if first_closer:
                    i_p[col] = start_point[col]
                else:
                    i_p[col] = end_point[col]
    else:
        i_p = start_point
    i_p[&#34;timestamps&#34;] = [interpolate_timestamp]
    return pa.Table.from_pydict(i_p)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.is_sample_interval_invalid"><code class="name flex">
<span>def <span class="ident">is_sample_interval_invalid</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True if sample interval is np.nan or equal to 0.0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_sample_interval_invalid(self) -&gt; bool:
    &#34;&#34;&#34;
    :return: True if sample interval is np.nan or equal to 0.0
    &#34;&#34;&#34;
    return np.isnan(self._sample_interval_s) or self._sample_interval_s == 0.0</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.is_sample_rate_fixed"><code class="name flex">
<span>def <span class="ident">is_sample_rate_fixed</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>:return: true if sample rate of sensor is constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_sample_rate_fixed(self) -&gt; bool:
    &#34;&#34;&#34;
    :return: true if sample rate of sensor is constant
    &#34;&#34;&#34;
    return self._is_sample_rate_fixed</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.is_save_to_disk"><code class="name flex">
<span>def <span class="ident">is_save_to_disk</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True if sensor will be saved to disk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_save_to_disk(self) -&gt; bool:
    &#34;&#34;&#34;
    :return: True if sensor will be saved to disk
    &#34;&#34;&#34;
    return self._fs_writer.is_use_disk()</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.is_timestamps_altered"><code class="name flex">
<span>def <span class="ident">is_timestamps_altered</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>:return: true if timestamps have been changed from original data values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_timestamps_altered(self) -&gt; bool:
    &#34;&#34;&#34;
    :return: true if timestamps have been changed from original data values
    &#34;&#34;&#34;
    return self._timestamps_altered</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.last_data_timestamp"><code class="name flex">
<span>def <span class="ident">last_data_timestamp</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: timestamp of the last data point or np.nan if no timestamps</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_data_timestamp(self) -&gt; float:
    &#34;&#34;&#34;
    :return: timestamp of the last data point or np.nan if no timestamps
    &#34;&#34;&#34;
    return self.data_timestamps()[-1]</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, in_dir: str) ‑> <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param in_dir: structured directory with json metadata file to load
:return: RedvoxSensor using data from files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, in_dir: str) -&gt; &#34;SensorData&#34;:
    &#34;&#34;&#34;
    :param in_dir: structured directory with json metadata file to load
    :return: RedvoxSensor using data from files
    &#34;&#34;&#34;
    file = io.get_json_file(in_dir)
    if file is None:
        st = SensorData(&#34;LoadError&#34;)
        st.append_error(&#34;File to load Sensor not found.&#34;)
        return self
    else:
        return self.from_json_file(in_dir, file)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.move_pyarrow_dir"><code class="name flex">
<span>def <span class="ident">move_pyarrow_dir</span></span>(<span>self, new_dir: str) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Move the sensor's pyarrow files to a new directory</p>
<p>:param new_dir: directory to save files into</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_pyarrow_dir(self, new_dir: str) -&gt; Path:
    &#34;&#34;&#34;
    Move the sensor&#39;s pyarrow files to a new directory

    :param new_dir: directory to save files into
    &#34;&#34;&#34;
    old_sensor_save_dir = self.save_dir()
    self.set_save_dir(os.path.join(new_dir, self._type.name))
    for r, d, f in os.walk(old_sensor_save_dir):
        for file in f:
            self._fs_writer.create_dir()
            os.rename(os.path.join(old_sensor_save_dir, file), os.path.join(self.save_dir(), file))
    return Path(self.save_dir())</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.num_samples"><code class="name flex">
<span>def <span class="ident">num_samples</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the number of rows (samples) in the dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_samples(self) -&gt; int:
    &#34;&#34;&#34;
    :return: the number of rows (samples) in the dataframe
    &#34;&#34;&#34;
    if self.pyarrow_table():
        return self.pyarrow_table().num_rows
    return 0</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.organize_and_update_stats"><code class="name flex">
<span>def <span class="ident">organize_and_update_stats</span></span>(<span>self, ptable: pyarrow.lib.Table) ‑> <a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>sorts the data by timestamps, then if the sample rate is not fixed, recalculates the sample rate, interval,
and interval std dev.
If there is only one value, sets the sample rate, interval, and interval std dev
to np.nan.
Updates the RedvoxSensor object with the new values</p>
<p>:param ptable: pyarrow table to update
:return: updated version of self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def organize_and_update_stats(self, ptable: pa.Table) -&gt; &#34;SensorData&#34;:
    &#34;&#34;&#34;
    sorts the data by timestamps, then if the sample rate is not fixed, recalculates the sample rate, interval,
        and interval std dev.  If there is only one value, sets the sample rate, interval, and interval std dev
        to np.nan.  Updates the RedvoxSensor object with the new values

    :param ptable: pyarrow table to update
    :return: updated version of self
    &#34;&#34;&#34;
    self.sort_by_data_timestamps(ptable)
    if not self._is_sample_rate_fixed:
        if self.num_samples() &gt; 1:
            timestamp_diffs = np.diff(self.data_timestamps())
            self._sample_interval_s = dtu.microseconds_to_seconds(
                float(np.mean(timestamp_diffs))
            )
            self._sample_interval_std_s = dtu.microseconds_to_seconds(
                float(np.std(timestamp_diffs))
            )
            self._sample_rate_hz = (
                np.nan
                if self.is_sample_interval_invalid()
                else 1 / self._sample_interval_s
            )
        else:
            self._sample_interval_s = np.nan
            self._sample_interval_std_s = np.nan
            self._sample_rate_hz = np.nan
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.print_errors"><code class="name flex">
<span>def <span class="ident">print_errors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>print all errors to screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_errors(self):
    &#34;&#34;&#34;
    print all errors to screen
    &#34;&#34;&#34;
    self._errors.print()</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.pyarrow_ds"><code class="name flex">
<span>def <span class="ident">pyarrow_ds</span></span>(<span>self, base_dir: Optional[str] = None) ‑> pyarrow._dataset.Dataset</span>
</code></dt>
<dd>
<div class="desc"><p>:param base_dir: optional directory to use when loading the dataset.
if None, use self.save_dir()
:return: the dataset stored in base_dir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyarrow_ds(self, base_dir: Optional[str] = None) -&gt; ds.Dataset:
    &#34;&#34;&#34;
    :param base_dir: optional directory to use when loading the dataset.  if None, use self.save_dir()
    :return: the dataset stored in base_dir
    &#34;&#34;&#34;
    if base_dir is None:
        base_dir = self.save_dir()
    return ds.dataset(base_dir, format=&#34;parquet&#34;, exclude_invalid_files=True)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.pyarrow_table"><code class="name flex">
<span>def <span class="ident">pyarrow_table</span></span>(<span>self) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the table defined by the _data property or the dataset stored in self.save_dir()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyarrow_table(self) -&gt; pa.Table:
    &#34;&#34;&#34;
    :return: the table defined by the _data property or the dataset stored in self.save_dir()
    &#34;&#34;&#34;
    if self._data or self._fs_writer.is_use_mem():
        return self._data
    return self.pyarrow_ds().to_table()</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.sample_interval_s"><code class="name flex">
<span>def <span class="ident">sample_interval_s</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: mean sample interval in seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_interval_s(self) -&gt; float:
    &#34;&#34;&#34;
    :return: mean sample interval in seconds
    &#34;&#34;&#34;
    return self._sample_interval_s</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.sample_interval_std_s"><code class="name flex">
<span>def <span class="ident">sample_interval_std_s</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: sample interval standard deviation in seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_interval_std_s(self) -&gt; float:
    &#34;&#34;&#34;
    :return: sample interval standard deviation in seconds
    &#34;&#34;&#34;
    return self._sample_interval_std_s</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.sample_rate_hz"><code class="name flex">
<span>def <span class="ident">sample_rate_hz</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>:return: sample rate in Hz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_rate_hz(self) -&gt; float:
    &#34;&#34;&#34;
    :return: sample rate in Hz
    &#34;&#34;&#34;
    return self._sample_rate_hz</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.samples"><code class="name flex">
<span>def <span class="ident">samples</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>gets the non-timestamp samples of dataframe</p>
<p>:return: the data values of the dataframe as a numpy ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def samples(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    gets the non-timestamp samples of dataframe

    :return: the data values of the dataframe as a numpy ndarray
    &#34;&#34;&#34;
    return self.data_df().iloc[:, 2:].T.to_numpy()</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_name: Optional[str] = None) ‑> Optional[pathlib.Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the RedvoxSensor to disk.
Does nothing if saving is not enabled</p>
<p>:param file_name: Optional file name to save RedvoxSensor as.
Do not include a file extension.
Default None
If None, a default file name is created using this format:
[sensor_type]_[first_timestamp].json
:return: The path to the saved file or None if unable to save.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file_name: Optional[str] = None) -&gt; Optional[Path]:
    &#34;&#34;&#34;
    Saves the RedvoxSensor to disk.  Does nothing if saving is not enabled

    :param file_name: Optional file name to save RedvoxSensor as.  Do not include a file extension.  Default None
                        If None, a default file name is created using this format:
                        [sensor_type]_[first_timestamp].json
    :return: The path to the saved file or None if unable to save.
    &#34;&#34;&#34;
    if self._fs_writer.is_save_disk():
        return self.to_json_file(file_name)
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.save_dir"><code class="name flex">
<span>def <span class="ident">save_dir</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: directory containing parquet files for the sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_dir(self) -&gt; str:
    &#34;&#34;&#34;
    :return: directory containing parquet files for the sensor
    &#34;&#34;&#34;
    return self._fs_writer.save_dir()</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.set_errors"><code class="name flex">
<span>def <span class="ident">set_errors</span></span>(<span>self, errors: <a title="redvox.common.errors.RedVoxExceptions" href="errors.html#redvox.common.errors.RedVoxExceptions">RedVoxExceptions</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>sets the errors of the Sensor</p>
<p>:param errors: errors to set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_errors(self, errors: RedVoxExceptions):
    &#34;&#34;&#34;
    sets the errors of the Sensor

    :param errors: errors to set
    &#34;&#34;&#34;
    self._errors = errors</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.set_file_name"><code class="name flex">
<span>def <span class="ident">set_file_name</span></span>(<span>self, new_file: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>set the pyarrow file name or use the default: {sensor_type}_{int(first_timestamp)}</li>
<li>Do not give an extension</li>
</ul>
<p>:param new_file: optional file name to change to; default None (use default name)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_file_name(self, new_file: Optional[str] = None):
    &#34;&#34;&#34;
    * set the pyarrow file name or use the default: {sensor_type}_{int(first_timestamp)}
    * Do not give an extension

    :param new_file: optional file name to change to; default None (use default name)
    &#34;&#34;&#34;
    self._fs_writer.file_name = new_file if new_file else f&#34;{self._type.name}_{int(self.first_data_timestamp())}&#34;</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.set_gaps"><code class="name flex">
<span>def <span class="ident">set_gaps</span></span>(<span>self, gaps: List[Tuple])</span>
</code></dt>
<dd>
<div class="desc"><p>sets the gaps of the Sensor</p>
<p>:param gaps: gaps to set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_gaps(self, gaps: List[Tuple]):
    &#34;&#34;&#34;
    sets the gaps of the Sensor

    :param gaps: gaps to set
    &#34;&#34;&#34;
    self._gaps = gaps</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.set_save_dir"><code class="name flex">
<span>def <span class="ident">set_save_dir</span></span>(<span>self, new_dir: str = '.')</span>
</code></dt>
<dd>
<div class="desc"><p>set the pyarrow directory or use the default: "." (current directory)</p>
<p>:param new_dir: the directory to change to; default "." (use current directory)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_save_dir(self, new_dir: str = &#34;.&#34;):
    &#34;&#34;&#34;
    set the pyarrow directory or use the default: &#34;.&#34; (current directory)

    :param new_dir: the directory to change to; default &#34;.&#34; (use current directory)
    &#34;&#34;&#34;
    self._fs_writer.base_dir = new_dir</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.set_save_mode"><code class="name flex">
<span>def <span class="ident">set_save_mode</span></span>(<span>self, new_save_mode: <a title="redvox.common.io.FileSystemSaveMode" href="io.html#redvox.common.io.FileSystemSaveMode">FileSystemSaveMode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>changes the save mode to new_save_mode</p>
<p>:param new_save_mode: FileSystemSaveMode to change to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_save_mode(self, new_save_mode: FileSystemSaveMode):
    &#34;&#34;&#34;
    changes the save mode to new_save_mode

    :param new_save_mode: FileSystemSaveMode to change to
    &#34;&#34;&#34;
    self._fs_writer.set_save_mode(new_save_mode)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.set_save_to_disk"><code class="name flex">
<span>def <span class="ident">set_save_to_disk</span></span>(<span>self, save: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>:param save: If True, save to disk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_save_to_disk(self, save: bool):
    &#34;&#34;&#34;
    :param save: If True, save to disk
    &#34;&#34;&#34;
    self._fs_writer.set_use_disk(save)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.set_use_temp_dir"><code class="name flex">
<span>def <span class="ident">set_use_temp_dir</span></span>(<span>self, use_temp_dir: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>:param use_temp_dir: if True, use temp dir to save data.
default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_use_temp_dir(self, use_temp_dir: bool = False):
    &#34;&#34;&#34;
    :param use_temp_dir: if True, use temp dir to save data.  default False
    &#34;&#34;&#34;
    self._fs_writer.set_use_temp(use_temp_dir)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.sort_by_data_timestamps"><code class="name flex">
<span>def <span class="ident">sort_by_data_timestamps</span></span>(<span>self, ptable: pyarrow.lib.Table, ascending: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>sorts the data based on timestamps</p>
<p>:param ptable: pyarrow table to sort
:param ascending: if True, timestamps are sorted in ascending order, else sort by descending order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_by_data_timestamps(self, ptable: pa.Table, ascending: bool = True):
    &#34;&#34;&#34;
    sorts the data based on timestamps

    :param ptable: pyarrow table to sort
    :param ascending: if True, timestamps are sorted in ascending order, else sort by descending order
    &#34;&#34;&#34;
    if ascending:
        order = &#34;ascending&#34;
    else:
        order = &#34;descending&#34;
    data = pc.take(ptable, pc.sort_indices(ptable, sort_keys=[(&#34;timestamps&#34;, order)]))
    self.write_pyarrow_table(data)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: sensor as json string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; str:
    &#34;&#34;&#34;
    :return: sensor as json string
    &#34;&#34;&#34;
    return io.to_json(self)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.to_json_file"><code class="name flex">
<span>def <span class="ident">to_json_file</span></span>(<span>self, file_name: Optional[str] = None) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>saves the sensor as json and data in the same directory.</p>
<p>:param file_name: the optional base file name.
Do not include a file extension.
If None, a default file name is created using this format:
[sensor_type]_[first_timestamp].json
:return: path to json file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json_file(self, file_name: Optional[str] = None) -&gt; Path:
    &#34;&#34;&#34;
    saves the sensor as json and data in the same directory.

    :param file_name: the optional base file name.  Do not include a file extension.
                        If None, a default file name is created using this format:
                        [sensor_type]_[first_timestamp].json
    :return: path to json file
    &#34;&#34;&#34;
    self.write_pyarrow_table(self.pyarrow_table())
    return io.to_json_file(self, file_name)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self) ‑> <a title="redvox.common.sensor_data.SensorType" href="#redvox.common.sensor_data.SensorType">SensorType</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: type of sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type(self) -&gt; SensorType:
    &#34;&#34;&#34;
    :return: type of sensor
    &#34;&#34;&#34;
    return self._type</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.type_as_str"><code class="name flex">
<span>def <span class="ident">type_as_str</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>gets the sensor type as a string</p>
<p>:return: sensor type of the sensor as a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_as_str(self) -&gt; str:
    &#34;&#34;&#34;
    gets the sensor type as a string

    :return: sensor type of the sensor as a string
    &#34;&#34;&#34;
    return self._type.name</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.unaltered_data_timestamps"><code class="name flex">
<span>def <span class="ident">unaltered_data_timestamps</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: the unaltered timestamps as a numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unaltered_data_timestamps(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: the unaltered timestamps as a numpy array
    &#34;&#34;&#34;
    if &#34;unaltered_timestamps&#34; in self.pyarrow_table().schema.names:
        return self.pyarrow_table()[&#34;unaltered_timestamps&#34;].to_numpy()
    else:
        return np.array([np.nan])</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.update_data_timestamps"><code class="name flex">
<span>def <span class="ident">update_data_timestamps</span></span>(<span>self, offset_model: <a title="redvox.common.offset_model.OffsetModel" href="offset_model.html#redvox.common.offset_model.OffsetModel">OffsetModel</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>updates the timestamps of the data points</p>
<p>:param offset_model: model used to update the timestamps</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_data_timestamps(self, offset_model: om.OffsetModel):
    &#34;&#34;&#34;
    updates the timestamps of the data points

    :param offset_model: model used to update the timestamps
    &#34;&#34;&#34;
    slope = dtu.seconds_to_microseconds(self._sample_interval_s) * (1 + offset_model.slope) \
        if self._use_offset_model else dtu.seconds_to_microseconds(self._sample_interval_s)
    if self._type == SensorType.AUDIO:
        # use the model to update the first timestamp or add the best offset (model&#39;s intercept value)
        timestamps = pa.array(
            calc_evenly_sampled_timestamps(
                offset_model.update_time(self.first_data_timestamp(), self._use_offset_model),
                self.num_samples(),
                slope))
    else:
        timestamps = pa.array(offset_model.update_timestamps(self.data_timestamps(),
                                                             self._use_offset_model))
    # old_name = self.full_path()
    self.write_pyarrow_table(self.pyarrow_table().set_column(0, &#34;timestamps&#34;, timestamps))
    # self.set_file_name()
    # os.rename(old_name, self.full_path())
    time_diffs = np.floor(np.diff(self.data_timestamps()))
    if len(time_diffs) &gt; 1:
        self._sample_interval_s = dtu.microseconds_to_seconds(slope)
        if self._sample_interval_s &gt; 0:
            self._sample_rate_hz = 1 / self._sample_interval_s
            self._sample_interval_std_s = dtu.microseconds_to_seconds(float(np.std(time_diffs)))
    self._timestamps_altered = True</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.used_offset_model"><code class="name flex">
<span>def <span class="ident">used_offset_model</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>:return: true if an offset model was used to perform timestamp corrections</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def used_offset_model(self) -&gt; bool:
    &#34;&#34;&#34;
    :return: true if an offset model was used to perform timestamp corrections
    &#34;&#34;&#34;
    return self._use_offset_model</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.SensorData.write_pyarrow_table"><code class="name flex">
<span>def <span class="ident">write_pyarrow_table</span></span>(<span>self, table: pyarrow.lib.Table, update_file_name: Optional[bool] = True)</span>
</code></dt>
<dd>
<div class="desc"><p>saves the pyarrow table to disk or to memory.</p>
<ul>
<li>if there is no data or there is no column named timestamps in the table, an error will be created</li>
<li>if writing to disk, uses a default filename: {sensor_type}_{first_timestamp}.parquet</li>
<li>uses the directory defined by self.save_dir().
Creates the directory if it doesn't exist and removes any
existing parquet files from the directory if it exists</li>
</ul>
<p>:param table: the table to write
:param update_file_name: if True, updates the file name to match the new data.
Default True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_pyarrow_table(self, table: pa.Table, update_file_name: Optional[bool] = True):
    &#34;&#34;&#34;
    saves the pyarrow table to disk or to memory.

    * if there is no data or there is no column named timestamps in the table, an error will be created
    * if writing to disk, uses a default filename: {sensor_type}_{first_timestamp}.parquet
    * uses the directory defined by self.save_dir().  Creates the directory if it doesn&#39;t exist and removes any
    existing parquet files from the directory if it exists

    :param table: the table to write
    :param update_file_name: if True, updates the file name to match the new data.  Default True
    &#34;&#34;&#34;
    if table.num_rows &lt; 1 or &#34;timestamps&#34; not in table.schema.names:
        self._errors.append(&#34;Attempted to write invalid table.&#34;)
    elif self._fs_writer.is_save_disk():
        self._fs_writer.create_dir()
        if update_file_name:
            self.set_file_name(f&#34;{self.type().name}_{int(table[&#39;timestamps&#39;][0].as_py())}&#34;)
        pq.write_table(table, self.full_path())
        self._data = None
    else:
        self._data = table</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.sensor_data.SensorType"><code class="flex name class">
<span>class <span class="ident">SensorType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of possible types of sensors to read data from</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorType(enum.Enum):
    &#34;&#34;&#34;
    Enumeration of possible types of sensors to read data from
    &#34;&#34;&#34;

    UNKNOWN_SENSOR = 0  # unknown sensor
    ACCELEROMETER = 1  # meters/second^2
    AMBIENT_TEMPERATURE = 2  # degrees Celsius
    AUDIO = 3  # normalized counts
    COMPRESSED_AUDIO = 4  # bytes (codec specific)
    GRAVITY = 5  # meters/second^2
    GYROSCOPE = 6  # radians/second
    IMAGE = 7  # bytes (codec specific)
    LIGHT = 8  # lux
    LINEAR_ACCELERATION = 9  # meters/second^2
    LOCATION = 10  # See standard
    MAGNETOMETER = 11  # microtesla
    ORIENTATION = 12  # radians
    PRESSURE = 13  # kilopascal
    PROXIMITY = 14  # on, off, cm
    RELATIVE_HUMIDITY = 15  # percentage
    ROTATION_VECTOR = 16  # Unitless
    INFRARED = 17  # this is proximity
    STATION_HEALTH = 18
    # Health sensors: battery charge and current level, phone internal temperature, network source and strength,
    # available RAM of the system, cell service status, amount of hard disk space left, power charging state
    # wifi lock state, cpu utilization, screen state, and screen brightness
    BEST_LOCATION = 19  # See standard

    @staticmethod
    def type_from_str(type_str: str) -&gt; &#34;SensorType&#34;:
        &#34;&#34;&#34;
        converts a string to a sensor type

        :param type_str: string to convert
        :return: a sensor type, UNKNOWN_SENSOR is the default for invalid inputs
        &#34;&#34;&#34;
        if (
                type_str.lower() == &#34;audio&#34;
                or type_str.lower() == &#34;mic&#34;
                or type_str.lower() == &#34;microphone&#34;
        ):
            return SensorType.AUDIO
        elif type_str.lower() == &#34;accelerometer&#34; or type_str.lower() == &#34;accel&#34;:
            return SensorType.ACCELEROMETER
        elif type_str.lower() == &#34;ambient_temperature&#34;:
            return SensorType.AMBIENT_TEMPERATURE
        elif type_str.lower() == &#34;compressed_audio&#34;:
            return SensorType.COMPRESSED_AUDIO
        elif type_str.lower() == &#34;gravity&#34;:
            return SensorType.GRAVITY
        elif type_str.lower() == &#34;gyroscope&#34; or type_str.lower() == &#34;gyro&#34;:
            return SensorType.GYROSCOPE
        elif type_str.lower() == &#34;image&#34;:
            return SensorType.IMAGE
        elif type_str.lower() == &#34;light&#34;:
            return SensorType.LIGHT
        elif (
                type_str.lower() == &#34;linear_acceleration&#34;
                or type_str.lower() == &#34;linear_accel&#34;
        ):
            return SensorType.LINEAR_ACCELERATION
        elif type_str.lower() == &#34;location&#34; or type_str.lower() == &#34;loc&#34;:
            return SensorType.LOCATION
        elif type_str.lower() == &#34;best_location&#34; or type_str.lower() == &#34;best_loc&#34;:
            return SensorType.BEST_LOCATION
        elif type_str.lower() == &#34;magnetometer&#34; or type_str.lower() == &#34;mag&#34;:
            return SensorType.MAGNETOMETER
        elif type_str.lower() == &#34;orientation&#34;:
            return SensorType.ORIENTATION
        elif (
                type_str.lower() == &#34;pressure&#34;
                or type_str.lower() == &#34;bar&#34;
                or type_str.lower() == &#34;barometer&#34;
        ):
            return SensorType.PRESSURE
        elif type_str.lower() == &#34;proximity&#34; or type_str.lower() == &#34;infrared&#34;:
            return SensorType.PROXIMITY
        elif type_str.lower() == &#34;relative_humidity&#34;:
            return SensorType.RELATIVE_HUMIDITY
        elif type_str.lower() == &#34;rotation_vector&#34;:
            return SensorType.ROTATION_VECTOR
        else:
            return SensorType.UNKNOWN_SENSOR</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.sensor_data.SensorType.ACCELEROMETER"><code class="name">var <span class="ident">ACCELEROMETER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.AMBIENT_TEMPERATURE"><code class="name">var <span class="ident">AMBIENT_TEMPERATURE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.AUDIO"><code class="name">var <span class="ident">AUDIO</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.BEST_LOCATION"><code class="name">var <span class="ident">BEST_LOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.COMPRESSED_AUDIO"><code class="name">var <span class="ident">COMPRESSED_AUDIO</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.GRAVITY"><code class="name">var <span class="ident">GRAVITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.GYROSCOPE"><code class="name">var <span class="ident">GYROSCOPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.IMAGE"><code class="name">var <span class="ident">IMAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.INFRARED"><code class="name">var <span class="ident">INFRARED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.LIGHT"><code class="name">var <span class="ident">LIGHT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.LINEAR_ACCELERATION"><code class="name">var <span class="ident">LINEAR_ACCELERATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.LOCATION"><code class="name">var <span class="ident">LOCATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.MAGNETOMETER"><code class="name">var <span class="ident">MAGNETOMETER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.ORIENTATION"><code class="name">var <span class="ident">ORIENTATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.PRESSURE"><code class="name">var <span class="ident">PRESSURE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.PROXIMITY"><code class="name">var <span class="ident">PROXIMITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.RELATIVE_HUMIDITY"><code class="name">var <span class="ident">RELATIVE_HUMIDITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.ROTATION_VECTOR"><code class="name">var <span class="ident">ROTATION_VECTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.STATION_HEALTH"><code class="name">var <span class="ident">STATION_HEALTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.sensor_data.SensorType.UNKNOWN_SENSOR"><code class="name">var <span class="ident">UNKNOWN_SENSOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.sensor_data.SensorType.type_from_str"><code class="name flex">
<span>def <span class="ident">type_from_str</span></span>(<span>type_str: str) ‑> <a title="redvox.common.sensor_data.SensorType" href="#redvox.common.sensor_data.SensorType">SensorType</a></span>
</code></dt>
<dd>
<div class="desc"><p>converts a string to a sensor type</p>
<p>:param type_str: string to convert
:return: a sensor type, UNKNOWN_SENSOR is the default for invalid inputs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def type_from_str(type_str: str) -&gt; &#34;SensorType&#34;:
    &#34;&#34;&#34;
    converts a string to a sensor type

    :param type_str: string to convert
    :return: a sensor type, UNKNOWN_SENSOR is the default for invalid inputs
    &#34;&#34;&#34;
    if (
            type_str.lower() == &#34;audio&#34;
            or type_str.lower() == &#34;mic&#34;
            or type_str.lower() == &#34;microphone&#34;
    ):
        return SensorType.AUDIO
    elif type_str.lower() == &#34;accelerometer&#34; or type_str.lower() == &#34;accel&#34;:
        return SensorType.ACCELEROMETER
    elif type_str.lower() == &#34;ambient_temperature&#34;:
        return SensorType.AMBIENT_TEMPERATURE
    elif type_str.lower() == &#34;compressed_audio&#34;:
        return SensorType.COMPRESSED_AUDIO
    elif type_str.lower() == &#34;gravity&#34;:
        return SensorType.GRAVITY
    elif type_str.lower() == &#34;gyroscope&#34; or type_str.lower() == &#34;gyro&#34;:
        return SensorType.GYROSCOPE
    elif type_str.lower() == &#34;image&#34;:
        return SensorType.IMAGE
    elif type_str.lower() == &#34;light&#34;:
        return SensorType.LIGHT
    elif (
            type_str.lower() == &#34;linear_acceleration&#34;
            or type_str.lower() == &#34;linear_accel&#34;
    ):
        return SensorType.LINEAR_ACCELERATION
    elif type_str.lower() == &#34;location&#34; or type_str.lower() == &#34;loc&#34;:
        return SensorType.LOCATION
    elif type_str.lower() == &#34;best_location&#34; or type_str.lower() == &#34;best_loc&#34;:
        return SensorType.BEST_LOCATION
    elif type_str.lower() == &#34;magnetometer&#34; or type_str.lower() == &#34;mag&#34;:
        return SensorType.MAGNETOMETER
    elif type_str.lower() == &#34;orientation&#34;:
        return SensorType.ORIENTATION
    elif (
            type_str.lower() == &#34;pressure&#34;
            or type_str.lower() == &#34;bar&#34;
            or type_str.lower() == &#34;barometer&#34;
    ):
        return SensorType.PRESSURE
    elif type_str.lower() == &#34;proximity&#34; or type_str.lower() == &#34;infrared&#34;:
        return SensorType.PROXIMITY
    elif type_str.lower() == &#34;relative_humidity&#34;:
        return SensorType.RELATIVE_HUMIDITY
    elif type_str.lower() == &#34;rotation_vector&#34;:
        return SensorType.ROTATION_VECTOR
    else:
        return SensorType.UNKNOWN_SENSOR</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor"><code class="flex name class">
<span>class <span class="ident">StationHealthSensor</span></span>
<span>(</span><span>sensor_name: str, sensor_data: Optional[pyarrow.lib.Table] = None, sample_rate_hz: float = nan, sample_interval_s: float = nan, sample_interval_std_s: float = nan, is_sample_rate_fixed: bool = False, are_timestamps_altered: bool = False, calculate_stats: bool = False, use_offset_model_for_correction: bool = False, save_data: bool = False, base_dir: str = '.', gaps: Optional[List[Tuple[float, float]]] = None, show_errors: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Station Health specific functions</p>
<p>initialize the sensor data with params</p>
<p>:param sensor_name: name of the sensor.
REQUIRED
:param sensor_type: enumerated type of the sensor, default SensorType.UNKNOWN_SENSOR
:param sensor_data: Optional pyarrow table with the timestamps and sensor data;
first column is always the timestamps,
the other columns are specific metadata and data channels in the sensor
default is None
:param sample_rate_hz: sample rate in hz of the data
:param sample_interval_s: sample interval in seconds of the data
:param sample_interval_std_s: std dev of sample interval in seconds of the data
:param is_sample_rate_fixed: if True, sample rate is constant for all data, default False
:param are_timestamps_altered: if True, timestamps in the sensor have been altered from their
original values, default False
:param calculate_stats: if True, calculate sample_rate, sample_interval_s, and sample_interval_std_s
default False
:param use_offset_model_for_correction: if True, use an offset model to correct timestamps, otherwise
use the best known offset.
default False
:param save_data: if True, save the data of the sensor to disk, otherwise use a temporary dir.
default False
:param base_dir: directory to save pyarrow table, default "." (current dir).
internally uses a temporary
dir if not saving data
:param gaps: Optional list of timestamp pairs of data points on the edge of gaps in the data.
anything between
the pairs of points exists to maintain sample rate and are not considered valid points.
Default None
:param show_errors: if True, show any errors encountered.
Default False
:param use_temp_dir: if True, use a temp directory to save data.
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StationHealthSensor(SensorData):
    &#34;&#34;&#34;
    Station Health specific functions
    &#34;&#34;&#34;
    def __init__(self, sensor_name: str,
                 sensor_data: Optional[pa.Table] = None,
                 sample_rate_hz: float = np.nan,
                 sample_interval_s: float = np.nan,
                 sample_interval_std_s: float = np.nan,
                 is_sample_rate_fixed: bool = False,
                 are_timestamps_altered: bool = False,
                 calculate_stats: bool = False,
                 use_offset_model_for_correction: bool = False,
                 save_data: bool = False,
                 base_dir: str = &#34;.&#34;,
                 gaps: Optional[List[Tuple[float, float]]] = None,
                 show_errors: bool = False):
        super().__init__(sensor_name, sensor_data, SensorType.STATION_HEALTH, sample_rate_hz, sample_interval_s,
                         sample_interval_std_s, is_sample_rate_fixed, are_timestamps_altered, calculate_stats,
                         use_offset_model_for_correction, save_data, base_dir, gaps, show_errors)

    def get_battery_charge_remaining_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: battery charge remaining data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;battery_charge_remaining&#39;)

    def get_valid_battery_charge_remaining_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan battery charge remaining data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;battery_charge_remaining&#39;)

    def get_battery_current_strength_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: battery current strength data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;battery_current_strength&#39;)

    def get_valid_battery_current_strength_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan battery current strength data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;battery_current_strength&#39;)

    def get_internal_temp_c_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: internal temperature celsius data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;internal_temp_c&#39;)

    def get_valid_internal_temp_c_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan internal temperature celsius data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;internal_temp_c&#39;)

    def get_network_type_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: network type data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;network_type&#39;)

    def get_valid_network_type_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan network type data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;network_type&#39;)

    def get_network_strength_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: network strength data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;network_strength&#39;)

    def get_valid_network_strength_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan network strength data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;network_strength&#39;)

    def get_power_state_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: power state data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;power_state&#39;)

    def get_valid_power_state_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan power state data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;power_state&#39;)

    def get_avail_ram_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: available RAM data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;avail_ram&#39;)

    def get_valid_avail_ram_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan available RAM data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;avail_ram&#39;)

    def get_avail_disk_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: available disk space data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;avail_disk&#39;)

    def get_valid_avail_disk_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan available disk space data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;avail_disk&#39;)

    def get_cell_service_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: cell service data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;cell_service&#39;)

    def get_valid_cell_service_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan cell service data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;cell_service&#39;)

    def get_cpu_utilization_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: CPU utilization data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;cpu_utilization&#39;)

    def get_valid_cpu_utilization_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan CPU utilization data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;cpu_utilization&#39;)

    def get_wifi_wake_lock_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: wifi wake lock data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;wifi_wake_lock&#39;)

    def get_valid_wifi_wake_lock_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan wifi wake lock data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;wifi_wake_lock&#39;)

    def get_screen_state_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: screen state data as list of strings
        &#34;&#34;&#34;
        return super()._get_non_numeric_data_channel(&#39;screen_state&#39;)

    def get_valid_screen_state_data(self) -&gt; List[str]:
        &#34;&#34;&#34;
        NOT IMPLEMENTED
        :return: non-nan screen state data as list of strings
        &#34;&#34;&#34;
        pass
        # return super().get_valid_data_channel_values(&#39;screen_state&#39;)

    def get_screen_brightness_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: screen brightness data as numpy array
        &#34;&#34;&#34;
        return super().get_data_channel(&#39;screen_brightness&#39;)

    def get_valid_screen_brightness_data(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: non-nan screen brightness data as numpy array
        &#34;&#34;&#34;
        return super().get_valid_data_channel_values(&#39;screen_brightness&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_avail_disk_data"><code class="name flex">
<span>def <span class="ident">get_avail_disk_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: available disk space data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_avail_disk_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: available disk space data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;avail_disk&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_avail_ram_data"><code class="name flex">
<span>def <span class="ident">get_avail_ram_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: available RAM data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_avail_ram_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: available RAM data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;avail_ram&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_battery_charge_remaining_data"><code class="name flex">
<span>def <span class="ident">get_battery_charge_remaining_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: battery charge remaining data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_charge_remaining_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: battery charge remaining data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;battery_charge_remaining&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_battery_current_strength_data"><code class="name flex">
<span>def <span class="ident">get_battery_current_strength_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: battery current strength data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_current_strength_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: battery current strength data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;battery_current_strength&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_cell_service_data"><code class="name flex">
<span>def <span class="ident">get_cell_service_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: cell service data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cell_service_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: cell service data as list of strings
    &#34;&#34;&#34;
    return super()._get_non_numeric_data_channel(&#39;cell_service&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_cpu_utilization_data"><code class="name flex">
<span>def <span class="ident">get_cpu_utilization_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: CPU utilization data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cpu_utilization_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: CPU utilization data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;cpu_utilization&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_internal_temp_c_data"><code class="name flex">
<span>def <span class="ident">get_internal_temp_c_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: internal temperature celsius data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_internal_temp_c_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: internal temperature celsius data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;internal_temp_c&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_network_strength_data"><code class="name flex">
<span>def <span class="ident">get_network_strength_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: network strength data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_network_strength_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: network strength data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;network_strength&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_network_type_data"><code class="name flex">
<span>def <span class="ident">get_network_type_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: network type data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_network_type_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: network type data as list of strings
    &#34;&#34;&#34;
    return super()._get_non_numeric_data_channel(&#39;network_type&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_power_state_data"><code class="name flex">
<span>def <span class="ident">get_power_state_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: power state data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_power_state_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: power state data as list of strings
    &#34;&#34;&#34;
    return super()._get_non_numeric_data_channel(&#39;power_state&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_screen_brightness_data"><code class="name flex">
<span>def <span class="ident">get_screen_brightness_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: screen brightness data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_screen_brightness_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: screen brightness data as numpy array
    &#34;&#34;&#34;
    return super().get_data_channel(&#39;screen_brightness&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_screen_state_data"><code class="name flex">
<span>def <span class="ident">get_screen_state_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: screen state data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_screen_state_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: screen state data as list of strings
    &#34;&#34;&#34;
    return super()._get_non_numeric_data_channel(&#39;screen_state&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_avail_disk_data"><code class="name flex">
<span>def <span class="ident">get_valid_avail_disk_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan available disk space data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_avail_disk_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan available disk space data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;avail_disk&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_avail_ram_data"><code class="name flex">
<span>def <span class="ident">get_valid_avail_ram_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan available RAM data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_avail_ram_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan available RAM data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;avail_ram&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_battery_charge_remaining_data"><code class="name flex">
<span>def <span class="ident">get_valid_battery_charge_remaining_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan battery charge remaining data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_battery_charge_remaining_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan battery charge remaining data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;battery_charge_remaining&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_battery_current_strength_data"><code class="name flex">
<span>def <span class="ident">get_valid_battery_current_strength_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan battery current strength data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_battery_current_strength_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan battery current strength data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;battery_current_strength&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_cell_service_data"><code class="name flex">
<span>def <span class="ident">get_valid_cell_service_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>NOT IMPLEMENTED
:return: non-nan cell service data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_cell_service_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    NOT IMPLEMENTED
    :return: non-nan cell service data as list of strings
    &#34;&#34;&#34;
    pass
    # return super().get_valid_data_channel_values(&#39;cell_service&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_cpu_utilization_data"><code class="name flex">
<span>def <span class="ident">get_valid_cpu_utilization_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan CPU utilization data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_cpu_utilization_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan CPU utilization data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;cpu_utilization&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_internal_temp_c_data"><code class="name flex">
<span>def <span class="ident">get_valid_internal_temp_c_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan internal temperature celsius data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_internal_temp_c_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan internal temperature celsius data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;internal_temp_c&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_network_strength_data"><code class="name flex">
<span>def <span class="ident">get_valid_network_strength_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan network strength data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_network_strength_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan network strength data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;network_strength&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_network_type_data"><code class="name flex">
<span>def <span class="ident">get_valid_network_type_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>NOT IMPLEMENTED
:return: non-nan network type data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_network_type_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    NOT IMPLEMENTED
    :return: non-nan network type data as list of strings
    &#34;&#34;&#34;
    pass
    # return super().get_valid_data_channel_values(&#39;network_type&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_power_state_data"><code class="name flex">
<span>def <span class="ident">get_valid_power_state_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>NOT IMPLEMENTED
:return: non-nan power state data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_power_state_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    NOT IMPLEMENTED
    :return: non-nan power state data as list of strings
    &#34;&#34;&#34;
    pass
    # return super().get_valid_data_channel_values(&#39;power_state&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_screen_brightness_data"><code class="name flex">
<span>def <span class="ident">get_valid_screen_brightness_data</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: non-nan screen brightness data as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_screen_brightness_data(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: non-nan screen brightness data as numpy array
    &#34;&#34;&#34;
    return super().get_valid_data_channel_values(&#39;screen_brightness&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_screen_state_data"><code class="name flex">
<span>def <span class="ident">get_valid_screen_state_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>NOT IMPLEMENTED
:return: non-nan screen state data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_screen_state_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    NOT IMPLEMENTED
    :return: non-nan screen state data as list of strings
    &#34;&#34;&#34;
    pass
    # return super().get_valid_data_channel_values(&#39;screen_state&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_valid_wifi_wake_lock_data"><code class="name flex">
<span>def <span class="ident">get_valid_wifi_wake_lock_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>NOT IMPLEMENTED
:return: non-nan wifi wake lock data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_valid_wifi_wake_lock_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    NOT IMPLEMENTED
    :return: non-nan wifi wake lock data as list of strings
    &#34;&#34;&#34;
    pass
    # return super().get_valid_data_channel_values(&#39;wifi_wake_lock&#39;)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_data.StationHealthSensor.get_wifi_wake_lock_data"><code class="name flex">
<span>def <span class="ident">get_wifi_wake_lock_data</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: wifi wake lock data as list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wifi_wake_lock_data(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: wifi wake lock data as list of strings
    &#34;&#34;&#34;
    return super()._get_non_numeric_data_channel(&#39;wifi_wake_lock&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></b></code>:
<ul class="hlist">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.common.sensor_data.AccelerometerSensor" href="#redvox.common.sensor_data.AccelerometerSensor">AccelerometerSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.AccelerometerSensor.get_accelerometer_x_data" href="#redvox.common.sensor_data.AccelerometerSensor.get_accelerometer_x_data">get_accelerometer_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.AccelerometerSensor.get_accelerometer_y_data" href="#redvox.common.sensor_data.AccelerometerSensor.get_accelerometer_y_data">get_accelerometer_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.AccelerometerSensor.get_accelerometer_z_data" href="#redvox.common.sensor_data.AccelerometerSensor.get_accelerometer_z_data">get_accelerometer_z_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.AccelerometerSensor.get_valid_accelerometer_x_data" href="#redvox.common.sensor_data.AccelerometerSensor.get_valid_accelerometer_x_data">get_valid_accelerometer_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.AccelerometerSensor.get_valid_accelerometer_y_data" href="#redvox.common.sensor_data.AccelerometerSensor.get_valid_accelerometer_y_data">get_valid_accelerometer_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.AccelerometerSensor.get_valid_accelerometer_z_data" href="#redvox.common.sensor_data.AccelerometerSensor.get_valid_accelerometer_z_data">get_valid_accelerometer_z_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.AmbientTemperatureSensor" href="#redvox.common.sensor_data.AmbientTemperatureSensor">AmbientTemperatureSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.AmbientTemperatureSensor.get_ambient_temperature_data" href="#redvox.common.sensor_data.AmbientTemperatureSensor.get_ambient_temperature_data">get_ambient_temperature_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.AmbientTemperatureSensor.get_valid_ambient_temperature_data" href="#redvox.common.sensor_data.AmbientTemperatureSensor.get_valid_ambient_temperature_data">get_valid_ambient_temperature_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.AudioSensor" href="#redvox.common.sensor_data.AudioSensor">AudioSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.AudioSensor.from_metadata" href="#redvox.common.sensor_data.AudioSensor.from_metadata">from_metadata</a></code></li>
<li><code><a title="redvox.common.sensor_data.AudioSensor.get_microphone_data" href="#redvox.common.sensor_data.AudioSensor.get_microphone_data">get_microphone_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.AudioSensor.get_valid_microphone_data" href="#redvox.common.sensor_data.AudioSensor.get_valid_microphone_data">get_valid_microphone_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.BestLocationSensor" href="#redvox.common.sensor_data.BestLocationSensor">BestLocationSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_altitude_data" href="#redvox.common.sensor_data.BestLocationSensor.get_altitude_data">get_altitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_bearing_accuracy_data" href="#redvox.common.sensor_data.BestLocationSensor.get_bearing_accuracy_data">get_bearing_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_bearing_data" href="#redvox.common.sensor_data.BestLocationSensor.get_bearing_data">get_bearing_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_gps_timestamps_data" href="#redvox.common.sensor_data.BestLocationSensor.get_gps_timestamps_data">get_gps_timestamps_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_horizontal_accuracy_data" href="#redvox.common.sensor_data.BestLocationSensor.get_horizontal_accuracy_data">get_horizontal_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_latitude_data" href="#redvox.common.sensor_data.BestLocationSensor.get_latitude_data">get_latitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_location_provider_data" href="#redvox.common.sensor_data.BestLocationSensor.get_location_provider_data">get_location_provider_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_longitude_data" href="#redvox.common.sensor_data.BestLocationSensor.get_longitude_data">get_longitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_speed_accuracy_data" href="#redvox.common.sensor_data.BestLocationSensor.get_speed_accuracy_data">get_speed_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_speed_data" href="#redvox.common.sensor_data.BestLocationSensor.get_speed_data">get_speed_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_altitude_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_altitude_data">get_valid_altitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_bearing_accuracy_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_bearing_accuracy_data">get_valid_bearing_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_bearing_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_bearing_data">get_valid_bearing_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_gps_timestamps_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_gps_timestamps_data">get_valid_gps_timestamps_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_horizontal_accuracy_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_horizontal_accuracy_data">get_valid_horizontal_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_latitude_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_latitude_data">get_valid_latitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_location_provider_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_location_provider_data">get_valid_location_provider_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_longitude_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_longitude_data">get_valid_longitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_speed_accuracy_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_speed_accuracy_data">get_valid_speed_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_speed_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_speed_data">get_valid_speed_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_valid_vertical_accuracy_data" href="#redvox.common.sensor_data.BestLocationSensor.get_valid_vertical_accuracy_data">get_valid_vertical_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.BestLocationSensor.get_vertical_accuracy_data" href="#redvox.common.sensor_data.BestLocationSensor.get_vertical_accuracy_data">get_vertical_accuracy_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.CompressedAudioSensor" href="#redvox.common.sensor_data.CompressedAudioSensor">CompressedAudioSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.CompressedAudioSensor.get_audio_codec_data" href="#redvox.common.sensor_data.CompressedAudioSensor.get_audio_codec_data">get_audio_codec_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.CompressedAudioSensor.get_compressed_audio_data" href="#redvox.common.sensor_data.CompressedAudioSensor.get_compressed_audio_data">get_compressed_audio_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.CompressedAudioSensor.get_valid_compressed_audio_data" href="#redvox.common.sensor_data.CompressedAudioSensor.get_valid_compressed_audio_data">get_valid_compressed_audio_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.GravitySensor" href="#redvox.common.sensor_data.GravitySensor">GravitySensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.GravitySensor.get_gravity_x_data" href="#redvox.common.sensor_data.GravitySensor.get_gravity_x_data">get_gravity_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GravitySensor.get_gravity_y_data" href="#redvox.common.sensor_data.GravitySensor.get_gravity_y_data">get_gravity_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GravitySensor.get_gravity_z_data" href="#redvox.common.sensor_data.GravitySensor.get_gravity_z_data">get_gravity_z_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GravitySensor.get_valid_gravity_x_data" href="#redvox.common.sensor_data.GravitySensor.get_valid_gravity_x_data">get_valid_gravity_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GravitySensor.get_valid_gravity_y_data" href="#redvox.common.sensor_data.GravitySensor.get_valid_gravity_y_data">get_valid_gravity_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GravitySensor.get_valid_gravity_z_data" href="#redvox.common.sensor_data.GravitySensor.get_valid_gravity_z_data">get_valid_gravity_z_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.GyroscopeSensor" href="#redvox.common.sensor_data.GyroscopeSensor">GyroscopeSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.GyroscopeSensor.get_gyroscope_x_data" href="#redvox.common.sensor_data.GyroscopeSensor.get_gyroscope_x_data">get_gyroscope_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GyroscopeSensor.get_gyroscope_y_data" href="#redvox.common.sensor_data.GyroscopeSensor.get_gyroscope_y_data">get_gyroscope_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GyroscopeSensor.get_gyroscope_z_data" href="#redvox.common.sensor_data.GyroscopeSensor.get_gyroscope_z_data">get_gyroscope_z_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GyroscopeSensor.get_valid_gyroscope_x_data" href="#redvox.common.sensor_data.GyroscopeSensor.get_valid_gyroscope_x_data">get_valid_gyroscope_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GyroscopeSensor.get_valid_gyroscope_y_data" href="#redvox.common.sensor_data.GyroscopeSensor.get_valid_gyroscope_y_data">get_valid_gyroscope_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.GyroscopeSensor.get_valid_gyroscope_z_data" href="#redvox.common.sensor_data.GyroscopeSensor.get_valid_gyroscope_z_data">get_valid_gyroscope_z_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.ImageSensor" href="#redvox.common.sensor_data.ImageSensor">ImageSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.ImageSensor.get_image_codec_data" href="#redvox.common.sensor_data.ImageSensor.get_image_codec_data">get_image_codec_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.ImageSensor.get_image_data" href="#redvox.common.sensor_data.ImageSensor.get_image_data">get_image_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.ImageSensor.get_valid_image_codec_data" href="#redvox.common.sensor_data.ImageSensor.get_valid_image_codec_data">get_valid_image_codec_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.ImageSensor.get_valid_image_data" href="#redvox.common.sensor_data.ImageSensor.get_valid_image_data">get_valid_image_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.LightSensor" href="#redvox.common.sensor_data.LightSensor">LightSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.LightSensor.get_light_data" href="#redvox.common.sensor_data.LightSensor.get_light_data">get_light_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LightSensor.get_valid_light_data" href="#redvox.common.sensor_data.LightSensor.get_valid_light_data">get_valid_light_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.LinearAccelerationSensor" href="#redvox.common.sensor_data.LinearAccelerationSensor">LinearAccelerationSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.LinearAccelerationSensor.get_linear_acceleration_x_data" href="#redvox.common.sensor_data.LinearAccelerationSensor.get_linear_acceleration_x_data">get_linear_acceleration_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LinearAccelerationSensor.get_linear_acceleration_y_data" href="#redvox.common.sensor_data.LinearAccelerationSensor.get_linear_acceleration_y_data">get_linear_acceleration_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LinearAccelerationSensor.get_linear_acceleration_z_data" href="#redvox.common.sensor_data.LinearAccelerationSensor.get_linear_acceleration_z_data">get_linear_acceleration_z_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LinearAccelerationSensor.get_valid_linear_acceleration_x_data" href="#redvox.common.sensor_data.LinearAccelerationSensor.get_valid_linear_acceleration_x_data">get_valid_linear_acceleration_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LinearAccelerationSensor.get_valid_linear_acceleration_y_data" href="#redvox.common.sensor_data.LinearAccelerationSensor.get_valid_linear_acceleration_y_data">get_valid_linear_acceleration_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LinearAccelerationSensor.get_valid_linear_acceleration_z_data" href="#redvox.common.sensor_data.LinearAccelerationSensor.get_valid_linear_acceleration_z_data">get_valid_linear_acceleration_z_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.LocationSensor" href="#redvox.common.sensor_data.LocationSensor">LocationSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_altitude_data" href="#redvox.common.sensor_data.LocationSensor.get_altitude_data">get_altitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_bearing_accuracy_data" href="#redvox.common.sensor_data.LocationSensor.get_bearing_accuracy_data">get_bearing_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_bearing_data" href="#redvox.common.sensor_data.LocationSensor.get_bearing_data">get_bearing_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_gps_timestamps_data" href="#redvox.common.sensor_data.LocationSensor.get_gps_timestamps_data">get_gps_timestamps_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_horizontal_accuracy_data" href="#redvox.common.sensor_data.LocationSensor.get_horizontal_accuracy_data">get_horizontal_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_latitude_data" href="#redvox.common.sensor_data.LocationSensor.get_latitude_data">get_latitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_location_provider_data" href="#redvox.common.sensor_data.LocationSensor.get_location_provider_data">get_location_provider_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_longitude_data" href="#redvox.common.sensor_data.LocationSensor.get_longitude_data">get_longitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_speed_accuracy_data" href="#redvox.common.sensor_data.LocationSensor.get_speed_accuracy_data">get_speed_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_speed_data" href="#redvox.common.sensor_data.LocationSensor.get_speed_data">get_speed_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_altitude_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_altitude_data">get_valid_altitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_bearing_accuracy_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_bearing_accuracy_data">get_valid_bearing_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_bearing_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_bearing_data">get_valid_bearing_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_gps_timestamps_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_gps_timestamps_data">get_valid_gps_timestamps_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_horizontal_accuracy_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_horizontal_accuracy_data">get_valid_horizontal_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_latitude_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_latitude_data">get_valid_latitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_location_provider_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_location_provider_data">get_valid_location_provider_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_longitude_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_longitude_data">get_valid_longitude_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_speed_accuracy_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_speed_accuracy_data">get_valid_speed_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_speed_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_speed_data">get_valid_speed_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_valid_vertical_accuracy_data" href="#redvox.common.sensor_data.LocationSensor.get_valid_vertical_accuracy_data">get_valid_vertical_accuracy_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.LocationSensor.get_vertical_accuracy_data" href="#redvox.common.sensor_data.LocationSensor.get_vertical_accuracy_data">get_vertical_accuracy_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.MagnetometerSensor" href="#redvox.common.sensor_data.MagnetometerSensor">MagnetometerSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.MagnetometerSensor.get_magnetometer_x_data" href="#redvox.common.sensor_data.MagnetometerSensor.get_magnetometer_x_data">get_magnetometer_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.MagnetometerSensor.get_magnetometer_y_data" href="#redvox.common.sensor_data.MagnetometerSensor.get_magnetometer_y_data">get_magnetometer_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.MagnetometerSensor.get_magnetometer_z_data" href="#redvox.common.sensor_data.MagnetometerSensor.get_magnetometer_z_data">get_magnetometer_z_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.MagnetometerSensor.get_valid_magnetometer_x_data" href="#redvox.common.sensor_data.MagnetometerSensor.get_valid_magnetometer_x_data">get_valid_magnetometer_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.MagnetometerSensor.get_valid_magnetometer_y_data" href="#redvox.common.sensor_data.MagnetometerSensor.get_valid_magnetometer_y_data">get_valid_magnetometer_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.MagnetometerSensor.get_valid_magnetometer_z_data" href="#redvox.common.sensor_data.MagnetometerSensor.get_valid_magnetometer_z_data">get_valid_magnetometer_z_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.OrientationSensor" href="#redvox.common.sensor_data.OrientationSensor">OrientationSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.OrientationSensor.get_orientation_x_data" href="#redvox.common.sensor_data.OrientationSensor.get_orientation_x_data">get_orientation_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.OrientationSensor.get_orientation_y_data" href="#redvox.common.sensor_data.OrientationSensor.get_orientation_y_data">get_orientation_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.OrientationSensor.get_orientation_z_data" href="#redvox.common.sensor_data.OrientationSensor.get_orientation_z_data">get_orientation_z_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.OrientationSensor.get_valid_orientation_x_data" href="#redvox.common.sensor_data.OrientationSensor.get_valid_orientation_x_data">get_valid_orientation_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.OrientationSensor.get_valid_orientation_y_data" href="#redvox.common.sensor_data.OrientationSensor.get_valid_orientation_y_data">get_valid_orientation_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.OrientationSensor.get_valid_orientation_z_data" href="#redvox.common.sensor_data.OrientationSensor.get_valid_orientation_z_data">get_valid_orientation_z_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.PressureSensor" href="#redvox.common.sensor_data.PressureSensor">PressureSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.PressureSensor.get_pressure_data" href="#redvox.common.sensor_data.PressureSensor.get_pressure_data">get_pressure_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.PressureSensor.get_valid_pressure_data" href="#redvox.common.sensor_data.PressureSensor.get_valid_pressure_data">get_valid_pressure_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.ProximitySensor" href="#redvox.common.sensor_data.ProximitySensor">ProximitySensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.ProximitySensor.get_proximity_data" href="#redvox.common.sensor_data.ProximitySensor.get_proximity_data">get_proximity_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.ProximitySensor.get_valid_proximity_data" href="#redvox.common.sensor_data.ProximitySensor.get_valid_proximity_data">get_valid_proximity_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.RelativeHumiditySensor" href="#redvox.common.sensor_data.RelativeHumiditySensor">RelativeHumiditySensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.RelativeHumiditySensor.get_relative_humidity_data" href="#redvox.common.sensor_data.RelativeHumiditySensor.get_relative_humidity_data">get_relative_humidity_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.RelativeHumiditySensor.get_valid_relative_humidity_data" href="#redvox.common.sensor_data.RelativeHumiditySensor.get_valid_relative_humidity_data">get_valid_relative_humidity_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.RotationVectorSensor" href="#redvox.common.sensor_data.RotationVectorSensor">RotationVectorSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.RotationVectorSensor.get_rotation_vector_x_data" href="#redvox.common.sensor_data.RotationVectorSensor.get_rotation_vector_x_data">get_rotation_vector_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.RotationVectorSensor.get_rotation_vector_y_data" href="#redvox.common.sensor_data.RotationVectorSensor.get_rotation_vector_y_data">get_rotation_vector_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.RotationVectorSensor.get_rotation_vector_z_data" href="#redvox.common.sensor_data.RotationVectorSensor.get_rotation_vector_z_data">get_rotation_vector_z_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.RotationVectorSensor.get_valid_rotation_vector_x_data" href="#redvox.common.sensor_data.RotationVectorSensor.get_valid_rotation_vector_x_data">get_valid_rotation_vector_x_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.RotationVectorSensor.get_valid_rotation_vector_y_data" href="#redvox.common.sensor_data.RotationVectorSensor.get_valid_rotation_vector_y_data">get_valid_rotation_vector_y_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.RotationVectorSensor.get_valid_rotation_vector_z_data" href="#redvox.common.sensor_data.RotationVectorSensor.get_valid_rotation_vector_z_data">get_valid_rotation_vector_z_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.SensorData" href="#redvox.common.sensor_data.SensorData">SensorData</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.SensorData.append_data" href="#redvox.common.sensor_data.SensorData.append_data">append_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_error" href="#redvox.common.sensor_data.SensorData.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.append_sensor" href="#redvox.common.sensor_data.SensorData.append_sensor">append_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.as_dict" href="#redvox.common.sensor_data.SensorData.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.class_from_type" href="#redvox.common.sensor_data.SensorData.class_from_type">class_from_type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_channels" href="#redvox.common.sensor_data.SensorData.data_channels">data_channels</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_df" href="#redvox.common.sensor_data.SensorData.data_df">data_df</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.data_timestamps" href="#redvox.common.sensor_data.SensorData.data_timestamps">data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.errors" href="#redvox.common.sensor_data.SensorData.errors">errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.extend_errors" href="#redvox.common.sensor_data.SensorData.extend_errors">extend_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.file_name" href="#redvox.common.sensor_data.SensorData.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.first_data_timestamp" href="#redvox.common.sensor_data.SensorData.first_data_timestamp">first_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dict" href="#redvox.common.sensor_data.SensorData.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_dir" href="#redvox.common.sensor_data.SensorData.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.from_json_file" href="#redvox.common.sensor_data.SensorData.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.fs_writer" href="#redvox.common.sensor_data.SensorData.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_file_name" href="#redvox.common.sensor_data.SensorData.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.full_path" href="#redvox.common.sensor_data.SensorData.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.gaps" href="#redvox.common.sensor_data.SensorData.gaps">gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_data_channel" href="#redvox.common.sensor_data.SensorData.get_data_channel">get_data_channel</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.get_valid_data_channel_values" href="#redvox.common.sensor_data.SensorData.get_valid_data_channel_values">get_valid_data_channel_values</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.interpolate" href="#redvox.common.sensor_data.SensorData.interpolate">interpolate</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_interval_invalid" href="#redvox.common.sensor_data.SensorData.is_sample_interval_invalid">is_sample_interval_invalid</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_sample_rate_fixed" href="#redvox.common.sensor_data.SensorData.is_sample_rate_fixed">is_sample_rate_fixed</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_save_to_disk" href="#redvox.common.sensor_data.SensorData.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.is_timestamps_altered" href="#redvox.common.sensor_data.SensorData.is_timestamps_altered">is_timestamps_altered</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.last_data_timestamp" href="#redvox.common.sensor_data.SensorData.last_data_timestamp">last_data_timestamp</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.load" href="#redvox.common.sensor_data.SensorData.load">load</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.move_pyarrow_dir" href="#redvox.common.sensor_data.SensorData.move_pyarrow_dir">move_pyarrow_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.num_samples" href="#redvox.common.sensor_data.SensorData.num_samples">num_samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.organize_and_update_stats" href="#redvox.common.sensor_data.SensorData.organize_and_update_stats">organize_and_update_stats</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.print_errors" href="#redvox.common.sensor_data.SensorData.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_ds" href="#redvox.common.sensor_data.SensorData.pyarrow_ds">pyarrow_ds</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.pyarrow_table" href="#redvox.common.sensor_data.SensorData.pyarrow_table">pyarrow_table</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_s" href="#redvox.common.sensor_data.SensorData.sample_interval_s">sample_interval_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_interval_std_s" href="#redvox.common.sensor_data.SensorData.sample_interval_std_s">sample_interval_std_s</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sample_rate_hz" href="#redvox.common.sensor_data.SensorData.sample_rate_hz">sample_rate_hz</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.samples" href="#redvox.common.sensor_data.SensorData.samples">samples</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save" href="#redvox.common.sensor_data.SensorData.save">save</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.save_dir" href="#redvox.common.sensor_data.SensorData.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_errors" href="#redvox.common.sensor_data.SensorData.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_file_name" href="#redvox.common.sensor_data.SensorData.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_gaps" href="#redvox.common.sensor_data.SensorData.set_gaps">set_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_dir" href="#redvox.common.sensor_data.SensorData.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_mode" href="#redvox.common.sensor_data.SensorData.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_save_to_disk" href="#redvox.common.sensor_data.SensorData.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.set_use_temp_dir" href="#redvox.common.sensor_data.SensorData.set_use_temp_dir">set_use_temp_dir</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.sort_by_data_timestamps" href="#redvox.common.sensor_data.SensorData.sort_by_data_timestamps">sort_by_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json" href="#redvox.common.sensor_data.SensorData.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.to_json_file" href="#redvox.common.sensor_data.SensorData.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type" href="#redvox.common.sensor_data.SensorData.type">type</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.type_as_str" href="#redvox.common.sensor_data.SensorData.type_as_str">type_as_str</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.unaltered_data_timestamps" href="#redvox.common.sensor_data.SensorData.unaltered_data_timestamps">unaltered_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.update_data_timestamps" href="#redvox.common.sensor_data.SensorData.update_data_timestamps">update_data_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.used_offset_model" href="#redvox.common.sensor_data.SensorData.used_offset_model">used_offset_model</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorData.write_pyarrow_table" href="#redvox.common.sensor_data.SensorData.write_pyarrow_table">write_pyarrow_table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.SensorType" href="#redvox.common.sensor_data.SensorType">SensorType</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.common.sensor_data.SensorType.ACCELEROMETER" href="#redvox.common.sensor_data.SensorType.ACCELEROMETER">ACCELEROMETER</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.AMBIENT_TEMPERATURE" href="#redvox.common.sensor_data.SensorType.AMBIENT_TEMPERATURE">AMBIENT_TEMPERATURE</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.AUDIO" href="#redvox.common.sensor_data.SensorType.AUDIO">AUDIO</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.BEST_LOCATION" href="#redvox.common.sensor_data.SensorType.BEST_LOCATION">BEST_LOCATION</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.COMPRESSED_AUDIO" href="#redvox.common.sensor_data.SensorType.COMPRESSED_AUDIO">COMPRESSED_AUDIO</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.GRAVITY" href="#redvox.common.sensor_data.SensorType.GRAVITY">GRAVITY</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.GYROSCOPE" href="#redvox.common.sensor_data.SensorType.GYROSCOPE">GYROSCOPE</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.IMAGE" href="#redvox.common.sensor_data.SensorType.IMAGE">IMAGE</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.INFRARED" href="#redvox.common.sensor_data.SensorType.INFRARED">INFRARED</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.LIGHT" href="#redvox.common.sensor_data.SensorType.LIGHT">LIGHT</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.LINEAR_ACCELERATION" href="#redvox.common.sensor_data.SensorType.LINEAR_ACCELERATION">LINEAR_ACCELERATION</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.LOCATION" href="#redvox.common.sensor_data.SensorType.LOCATION">LOCATION</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.MAGNETOMETER" href="#redvox.common.sensor_data.SensorType.MAGNETOMETER">MAGNETOMETER</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.ORIENTATION" href="#redvox.common.sensor_data.SensorType.ORIENTATION">ORIENTATION</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.PRESSURE" href="#redvox.common.sensor_data.SensorType.PRESSURE">PRESSURE</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.PROXIMITY" href="#redvox.common.sensor_data.SensorType.PROXIMITY">PROXIMITY</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.RELATIVE_HUMIDITY" href="#redvox.common.sensor_data.SensorType.RELATIVE_HUMIDITY">RELATIVE_HUMIDITY</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.ROTATION_VECTOR" href="#redvox.common.sensor_data.SensorType.ROTATION_VECTOR">ROTATION_VECTOR</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.STATION_HEALTH" href="#redvox.common.sensor_data.SensorType.STATION_HEALTH">STATION_HEALTH</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.UNKNOWN_SENSOR" href="#redvox.common.sensor_data.SensorType.UNKNOWN_SENSOR">UNKNOWN_SENSOR</a></code></li>
<li><code><a title="redvox.common.sensor_data.SensorType.type_from_str" href="#redvox.common.sensor_data.SensorType.type_from_str">type_from_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.sensor_data.StationHealthSensor" href="#redvox.common.sensor_data.StationHealthSensor">StationHealthSensor</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_avail_disk_data" href="#redvox.common.sensor_data.StationHealthSensor.get_avail_disk_data">get_avail_disk_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_avail_ram_data" href="#redvox.common.sensor_data.StationHealthSensor.get_avail_ram_data">get_avail_ram_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_battery_charge_remaining_data" href="#redvox.common.sensor_data.StationHealthSensor.get_battery_charge_remaining_data">get_battery_charge_remaining_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_battery_current_strength_data" href="#redvox.common.sensor_data.StationHealthSensor.get_battery_current_strength_data">get_battery_current_strength_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_cell_service_data" href="#redvox.common.sensor_data.StationHealthSensor.get_cell_service_data">get_cell_service_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_cpu_utilization_data" href="#redvox.common.sensor_data.StationHealthSensor.get_cpu_utilization_data">get_cpu_utilization_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_internal_temp_c_data" href="#redvox.common.sensor_data.StationHealthSensor.get_internal_temp_c_data">get_internal_temp_c_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_network_strength_data" href="#redvox.common.sensor_data.StationHealthSensor.get_network_strength_data">get_network_strength_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_network_type_data" href="#redvox.common.sensor_data.StationHealthSensor.get_network_type_data">get_network_type_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_power_state_data" href="#redvox.common.sensor_data.StationHealthSensor.get_power_state_data">get_power_state_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_screen_brightness_data" href="#redvox.common.sensor_data.StationHealthSensor.get_screen_brightness_data">get_screen_brightness_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_screen_state_data" href="#redvox.common.sensor_data.StationHealthSensor.get_screen_state_data">get_screen_state_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_avail_disk_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_avail_disk_data">get_valid_avail_disk_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_avail_ram_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_avail_ram_data">get_valid_avail_ram_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_battery_charge_remaining_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_battery_charge_remaining_data">get_valid_battery_charge_remaining_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_battery_current_strength_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_battery_current_strength_data">get_valid_battery_current_strength_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_cell_service_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_cell_service_data">get_valid_cell_service_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_cpu_utilization_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_cpu_utilization_data">get_valid_cpu_utilization_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_internal_temp_c_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_internal_temp_c_data">get_valid_internal_temp_c_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_network_strength_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_network_strength_data">get_valid_network_strength_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_network_type_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_network_type_data">get_valid_network_type_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_power_state_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_power_state_data">get_valid_power_state_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_screen_brightness_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_screen_brightness_data">get_valid_screen_brightness_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_screen_state_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_screen_state_data">get_valid_screen_state_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_valid_wifi_wake_lock_data" href="#redvox.common.sensor_data.StationHealthSensor.get_valid_wifi_wake_lock_data">get_valid_wifi_wake_lock_data</a></code></li>
<li><code><a title="redvox.common.sensor_data.StationHealthSensor.get_wifi_wake_lock_data" href="#redvox.common.sensor_data.StationHealthSensor.get_wifi_wake_lock_data">get_wifi_wake_lock_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>