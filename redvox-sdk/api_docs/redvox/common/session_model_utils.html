<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redvox.common.session_model_utils API documentation</title>
<meta name="description" content="This module contains classes and functions that support SessionModel." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.session_model_utils</code></h1>
</header>
<section id="section-intro">
<p>This module contains classes and functions that support SessionModel.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains classes and functions that support SessionModel.
&#34;&#34;&#34;
from typing import List, Optional, Tuple, Dict
from dataclasses import dataclass
from dataclasses_json import dataclass_json
from bisect import insort
import enum

import numpy as np

from redvox.common.offset_model import OffsetModel
from redvox.common.timesync import TimeSync
from redvox.common.stats_helper import WelfordStatsContainer


class SensorModel:
    &#34;&#34;&#34;
    A simple representation of a Sensor.  Sample rate data is in Hz

    Properties:
        name: str, name of the Sensor

        description: str, description of the Sensor

        sample_rate_stats: WelfordStatsContainer used to calculate the mean, std deviation, variance, etc. of the
        sensor&#39;s sample rate
    &#34;&#34;&#34;
    def __init__(self, name: str, desc: str, mean_sample_rate: float):
        &#34;&#34;&#34;
        initialize SensorModel

        :param name: name of the sensor
        :param desc: description of the sensor
        :param mean_sample_rate: mean sample rate of the sensor in Hz
        &#34;&#34;&#34;
        self.name: str = name
        self.description: str = desc
        self.sample_rate_stats: WelfordStatsContainer = WelfordStatsContainer()
        self.sample_rate_stats.update(mean_sample_rate)

    def __repr__(self):
        return f&#34;name: {self.name}, &#34; \
               f&#34;description: {self.description}, &#34; \
               f&#34;sample_rate_stats: {self.sample_rate_stats}&#34;

    def to_dict(self) -&gt; Dict:
        &#34;&#34;&#34;
        :return: sensor model as dictionary
        &#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;description&#34;: self.description,
            &#34;sample_rate_stats&#34;: self.sample_rate_stats.to_dict()
        }

    @staticmethod
    def from_dict(source: dict) -&gt; &#34;SensorModel&#34;:
        &#34;&#34;&#34;
        :param source: dictionary to read
        :return: SensorModel from dictionary
        &#34;&#34;&#34;
        result = SensorModel(source[&#34;name&#34;], source[&#34;description&#34;], 0)
        result.sample_rate_stats = WelfordStatsContainer.from_dict(source[&#34;sample_rate_stats&#34;])
        return result

    def update(self, new_mean_sr: float):
        &#34;&#34;&#34;
        adds a new mean sample rate to the SensorModel

        :param new_mean_sr: new mean sample rate to add
        &#34;&#34;&#34;
        self.sample_rate_stats.update(new_mean_sr)

    def finalized(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the sample rate stats
        &#34;&#34;&#34;
        return self.sample_rate_stats.finalized()


class FirstLastBuffer:
    &#34;&#34;&#34;
    Holds data in two fixed size queues.  You can put more than the maximum capacity of elements into a
    queue, but it will remove elements until it reaches the capacity.

    Properties:
        capacity: int, maximum size of the queue

        data: List of Tuples; Tuples consist of timestamp in microseconds since epoch UTC
        and the actual data being stored

        debug: bool, if True, will output additional messages when errors occur.  Default False
    &#34;&#34;&#34;
    def __init__(self, capacity: int, debug: bool = False):
        &#34;&#34;&#34;
        Initialize the queue.
        Remember to only put the same type of data points into the queue.

        :param capacity: size of the queue
        :param debug: if True, output additional messages when errors occur, default False
        &#34;&#34;&#34;
        self.capacity: int = capacity
        self.first_data: List[Tuple] = [] * (capacity + 1)
        self.last_data: List[Tuple] = [] * (capacity + 1)
        self.debug: bool = debug

    def __repr__(self):
        return f&#34;capacity: {self.capacity}, &#34; \
               f&#34;first_data: {self.first_data}, &#34; \
               f&#34;last_data: {self.last_data}&#34;

    def __str__(self):
        return f&#34;capacity: {self.capacity}, &#34; \
               f&#34;\nfirst_data: [\n{self.first_data_as_string()}], &#34; \
               f&#34;\nlast_data: [\n{self.last_data_as_string()}]\n&#34;

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: FirstLastBuffer as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;capacity&#34;: self.capacity,
            &#34;first_data&#34;: self.first_data,
            &#34;last_data&#34;: self.last_data
        }

    @staticmethod
    def from_dict(data: dict) -&gt; &#34;FirstLastBuffer&#34;:
        &#34;&#34;&#34;
        :param data: dictionary to read from
        :return: FirstLastBuffer defined by the dictionary
        &#34;&#34;&#34;
        result = FirstLastBuffer(data[&#34;capacity&#34;])
        result.first_data = data[&#34;first_data&#34;]
        result.last_data = data[&#34;last_data&#34;]
        return result

    def first_data_as_string(self) -&gt; str:
        &#34;&#34;&#34;
        :return: string representation of the first_data queue
        &#34;&#34;&#34;
        return self._data_as_string(self.first_data)

    def last_data_as_string(self) -&gt; str:
        &#34;&#34;&#34;
        :return: string representation of the last_data queue
        &#34;&#34;&#34;
        return self._data_as_string(self.last_data)

    @staticmethod
    def _data_as_string(data_list: List[Tuple]) -&gt; str:
        &#34;&#34;&#34;
        :param data_list: the list of tuples to return as a string
        :return: list as a string
        &#34;&#34;&#34;
        result = &#34;&#34;
        for t, v in data_list:
            result += f&#34;{t}: {str(v)}\n&#34;
        return result

    @staticmethod
    def __ordered_insert(buffer: List, value: Tuple):
        &#34;&#34;&#34;
        inserts the value into the buffer using the timestamp as the key

        :param value: value to add.  Must include a timestamp and the same data type as the other buffer elements
        &#34;&#34;&#34;
        if len(buffer) &lt; 1:
            buffer.append(value)
        else:
            insort(buffer, value)

    def add(self, timestamp: float, value):
        &#34;&#34;&#34;
        add a value into one or more queues.
        If a queue is not full, the value is added automatically
        If the first_data queue is full, the value is only added if it comes before the last element.
        If the last_data queue is full, the value is only added if it comes after the first element.

        :param timestamp: timestamp in microseconds since epoch UTC to add.
        :param value: value to add.  Must be the same type of data as the other elements in the queue.
        &#34;&#34;&#34;
        if len(self.first_data) &lt; self.capacity or timestamp &lt; self.first_data[-1][0]:
            self.__ordered_insert(self.first_data, (timestamp, value))
            while len(self.first_data) &gt; self.capacity:
                self.first_data.pop()
        if len(self.last_data) &lt; self.capacity or timestamp &gt; self.last_data[0][0]:
            self.__ordered_insert(self.last_data, (timestamp, value))
            while len(self.last_data) &gt; self.capacity:
                self.last_data.pop(0)


class TimeSyncModel:
    &#34;&#34;&#34;
    TimeSync data used to build models
    All times and timestamps are in microseconds since epoch UTC

    Properties:
        first_timesync_timestamp: float, the first timestamp of the TimeSync data.  Default infinity

        last_timesync_timestamp: float, the last timestamp of the TimeSync data.  Default 0.0

        mean_latency: float, the mean latency of the TimeSync data.  Default 0.0

        mean_offset: float, the mean offset of the TimeSync data.  Default 0.0

        num_exchanges: int, number of exchanges in the TimeSync data.  Default 0

        first_last_timesync_data: FirstLastBuffer of TimeSync data, a fixed size list of timesync exchanges used to
                                    calculate the offset model.
    &#34;&#34;&#34;
    def __init__(self,
                 capacity: int,
                 first_timesync_timestamp: float = float(&#34;inf&#34;),
                 last_timesync_timestamp: float = 0.0,
                 mean_latency: float = 0.0,
                 mean_offset: float = 0.0,
                 num_exchanges: int = 0
                 ):
        &#34;&#34;&#34;
        Initialize the TimeSyncModel

        :param capacity: the number of data points to keep in each of the first and last data buffers
        :param first_timesync_timestamp: the first timestamp of the TimeSync data.  Default infinity
        :param last_timesync_timestamp: the last timestamp of the TimeSync data.  Default 0.0
        :param mean_latency: the mean latency of the TimeSync data.  Default 0.0
        :param mean_offset: the mean offset of the TimeSync data.  Default 0.0
        :param num_exchanges: the number of exchanges in the TimeSync data.  Default 0
        &#34;&#34;&#34;
        self.first_timesync_timestamp = first_timesync_timestamp
        self.last_timesync_timestamp = last_timesync_timestamp
        self.mean_latency = mean_latency
        self.mean_offset = mean_offset
        self.num_exchanges = num_exchanges
        self.first_last_timesync_data: FirstLastBuffer = FirstLastBuffer(capacity)

    def __repr__(self):
        return f&#34;first_timesync_timestamp: {self.first_timesync_timestamp}, &#34; \
               f&#34;last_timesync_timestamp: {self.last_timesync_timestamp}, &#34; \
               f&#34;mean_latency: {self.mean_latency}, &#34; \
               f&#34;mean_offset: {self.mean_offset}, &#34; \
               f&#34;num_exchanges: {self.num_exchanges}, &#34; \
               f&#34;first_last_timesync_data: {self.first_last_timesync_data.to_dict()}&#34;

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: TimeSyncModel as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;first_timesync_timestamp&#34;: self.first_timesync_timestamp,
            &#34;last_timesync_timestamp&#34;: self.last_timesync_timestamp,
            &#34;mean_latency&#34;: self.mean_latency,
            &#34;mean_offset&#34;: self.mean_offset,
            &#34;num_exchanges&#34;: self.num_exchanges,
            &#34;first_last_timesync_data&#34;: self.first_last_timesync_data.to_dict()
        }

    @staticmethod
    def from_dict(source: dict) -&gt; &#34;TimeSyncModel&#34;:
        &#34;&#34;&#34;
        :param source: dictionary to read from
        :return: TimeSyncModel from dictionary
        &#34;&#34;&#34;
        flb = FirstLastBuffer.from_dict(source[&#34;first_last_timesync_data&#34;])
        result = TimeSyncModel(0, source[&#34;first_timesync_timestamp&#34;],
                               source[&#34;last_timesync_timestamp&#34;], source[&#34;mean_latency&#34;], source[&#34;mean_offset&#34;],
                               source[&#34;num_exchanges&#34;])
        result.first_last_timesync_data = flb
        return result

    def update_model(self, ts: TimeSync):
        &#34;&#34;&#34;
        Use a TimeSync object to update the TimeSyncModel

        :param ts: TimeSync object to update the model with
        &#34;&#34;&#34;
        if ts.num_tri_messages() &gt; 0:
            self.num_exchanges += ts.num_tri_messages()
            self.mean_latency = \
                (self.mean_latency * self.num_exchanges + ts.best_latency()) / (self.num_exchanges + 1)
            self.mean_offset = \
                (self.mean_offset * self.num_exchanges + ts.best_offset()) / (self.num_exchanges + 1)
            _ts_latencies = ts.latencies().flatten()
            _ts_offsets = ts.offsets().flatten()
            _ts_timestamps = ts.get_device_exchanges_timestamps()
            if ts.data_start_timestamp() &lt; self.first_timesync_timestamp:
                self.first_timesync_timestamp = ts.data_start_timestamp()
            if ts.data_end_timestamp() &gt; self.last_timesync_timestamp:
                self.last_timesync_timestamp = ts.data_end_timestamp()
            # add data to the buffers
            for i in range(len(_ts_timestamps)):
                self.first_last_timesync_data.add(_ts_timestamps[i], (_ts_latencies[i], _ts_offsets[i]))

    def create_offset_model(self) -&gt; OffsetModel:
        &#34;&#34;&#34;
        :return: OffsetModel using the data in the TimeSyncModel
        &#34;&#34;&#34;
        latencies = []
        offsets = []
        timestamps = []
        for n in self.first_last_timesync_data.first_data:
            latencies.append(n[1][0])
            offsets.append(n[1][0])
            timestamps.append(n[0])
        for n in self.first_last_timesync_data.last_data:
            latencies.append(n[1][0])
            offsets.append(n[1][0])
            timestamps.append(n[0])
        return OffsetModel(np.array(latencies), np.array(offsets), np.array(timestamps),
                           self.first_timesync_timestamp, self.last_timesync_timestamp,
                           min_samples_per_bin=1)


class LocationModel:
    &#34;&#34;&#34;
    Location data used to build models
    All times and timestamps are in microseconds since epoch UTC

    Properties:
        latitudes: WelfordStatsContainer for latitude values

        longitudes: WelfordStatsContainer for longitude values

        altitudes: WelfordStatsContainer for altitude values

        first_last_location_data: FirstLastBuffer of Location data, a fixed size list of location data points.
    &#34;&#34;&#34;
    def __init__(self, capacity: int):
        &#34;&#34;&#34;
        initialize a LocationModel

        :param capacity: int, number of data points to store in the first and last buffers.
        &#34;&#34;&#34;
        self.latitudes = WelfordStatsContainer()
        self.longitudes = WelfordStatsContainer()
        self.altitudes = WelfordStatsContainer()
        self.first_last_location_data = FirstLastBuffer(capacity)

    def __repr__(self):
        return f&#34;latitudes: {self.latitudes}, &#34; \
               f&#34;longitudes: {self.longitudes}, &#34; \
               f&#34;altitudes: {self.altitudes}, &#34; \
               f&#34;first_last_location_data: {self.first_last_location_data}&#34;

    def __str__(self):
        return f&#34;latitudes: {self.latitudes}, &#34; \
               f&#34;longitudes: {self.longitudes}, &#34; \
               f&#34;altitudes: {self.altitudes}, &#34; \
               f&#34;location data: {self.first_last_location_data}&#34;

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: LocationModel as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;latitudes&#34;: self.latitudes.to_dict(),
            &#34;longitudes&#34;: self.longitudes.to_dict(),
            &#34;altitudes&#34;: self.altitudes.to_dict(),
            &#34;first_last_location_data&#34;: self.first_last_location_data.to_dict(),
        }

    @staticmethod
    def from_dict(source: dict) -&gt; &#34;LocationModel&#34;:
        &#34;&#34;&#34;
        :param source: dictionary to read from
        :return: LocationModel
        &#34;&#34;&#34;
        flb = FirstLastBuffer.from_dict(source[&#34;first_last_location_data&#34;])
        result = LocationModel(0)
        result.latitudes = WelfordStatsContainer.from_dict(source[&#34;latitudes&#34;])
        result.longitudes = WelfordStatsContainer.from_dict(source[&#34;longitudes&#34;])
        result.altitudes = WelfordStatsContainer.from_dict(source[&#34;altitudes&#34;])
        result.first_last_location_data = flb
        return result

    def update_location(self, lat: float, lon: float, alt: float, timestamp: float):
        &#34;&#34;&#34;
        Add a location to the LocationStats

        :param lat: float, latitude in degrees
        :param lon: float, longitude in degrees
        :param alt: float, altitude in meters
        :param timestamp: float, timestamp of location in microseconds since epoch UTC
        &#34;&#34;&#34;
        self.latitudes.update(lat)
        self.longitudes.update(lon)
        self.altitudes.update(alt)
        self.first_last_location_data.add(timestamp, (lat, lon, alt))

    def finalized_latitude(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the latitude
        &#34;&#34;&#34;
        return self.latitudes.finalized()

    def finalized_longitude(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the longitude
        &#34;&#34;&#34;
        return self.longitudes.finalized()

    def finalized_altitude(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the altitude
        &#34;&#34;&#34;
        return self.altitudes.finalized()


class MetricsSessionModel:
    &#34;&#34;&#34;
    Metrics stored by the SessionModel
    &#34;&#34;&#34;
    def __init__(self, capacity: int):
        &#34;&#34;&#34;
        initialize the metrics stored by the session model

        :param capacity: int, number of data points to store
        &#34;&#34;&#34;
        self.capacity: int = capacity
        self.location: Dict[str, LocationModel] = {}
        self.battery: WelfordStatsContainer = WelfordStatsContainer()
        self.temperature: WelfordStatsContainer = WelfordStatsContainer()

    def __repr__(self):
        return f&#34;location: {self.location}, &#34; \
               f&#34;battery: {self.battery}, &#34; \
               f&#34;temperature: {self.temperature}&#34;

    def __str__(self):
        return f&#34;location: {self.location}, &#34; \
               f&#34;battery percent: {self.battery}, &#34; \
               f&#34;temperature (C): {self.temperature}&#34;

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: MetricsSessionModel as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;capacity&#34;: self.capacity,
            &#34;location&#34;: {n: m.to_dict() for n, m in self.location.items()},
            &#34;battery&#34;: self.battery.to_dict(),
            &#34;temperature&#34;: self.temperature.to_dict()
        }

    @staticmethod
    def from_dict(source: dict) -&gt; &#34;MetricsSessionModel&#34;:
        &#34;&#34;&#34;
        :param source: dictionary to read from
        :return: MetricsSessionModel from dictionary
        &#34;&#34;&#34;
        result = MetricsSessionModel(source[&#34;capacity&#34;])
        result.location = {n: LocationModel.from_dict(m) for n, m in source[&#34;location&#34;].items()}
        result.battery = WelfordStatsContainer.from_dict(source[&#34;battery&#34;])
        result.temperature = WelfordStatsContainer.from_dict(source[&#34;temperature&#34;])
        return result

    def add_location(self, source: str, lat: float, lon: float, alt: float, timestamp: float):
        &#34;&#34;&#34;
        add a location from the named source to the session model

        :param source: str, name of the location data source
        :param lat: float, latitude in degrees
        :param lon: float, longitude in degrees
        :param alt: float, altitude in meters
        :param timestamp: float, timestamp of location in microseconds since epoch UTC
        &#34;&#34;&#34;
        if source not in self.location.keys():
            self.location[source] = LocationModel(self.capacity)
        self.location[source].update_location(lat, lon, alt, timestamp)

    def add_battery(self, data: float):
        &#34;&#34;&#34;
        add battery data to the session model

        :param data: float, battery percentage to add
        &#34;&#34;&#34;
        self.battery.update(data)

    def add_temperature(self, data: float):
        &#34;&#34;&#34;
        add temperature data to the session model

        :param data: float, temperature in Celsius to add
        &#34;&#34;&#34;
        self.temperature.update(data)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.common.session_model_utils.FirstLastBuffer"><code class="flex name class">
<span>class <span class="ident">FirstLastBuffer</span></span>
<span>(</span><span>capacity: int, debug: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds data in two fixed size queues.
You can put more than the maximum capacity of elements into a
queue, but it will remove elements until it reaches the capacity.</p>
<h2 id="properties">Properties</h2>
<p>capacity: int, maximum size of the queue</p>
<p>data: List of Tuples; Tuples consist of timestamp in microseconds since epoch UTC
and the actual data being stored</p>
<p>debug: bool, if True, will output additional messages when errors occur.
Default False</p>
<p>Initialize the queue.
Remember to only put the same type of data points into the queue.</p>
<p>:param capacity: size of the queue
:param debug: if True, output additional messages when errors occur, default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FirstLastBuffer:
    &#34;&#34;&#34;
    Holds data in two fixed size queues.  You can put more than the maximum capacity of elements into a
    queue, but it will remove elements until it reaches the capacity.

    Properties:
        capacity: int, maximum size of the queue

        data: List of Tuples; Tuples consist of timestamp in microseconds since epoch UTC
        and the actual data being stored

        debug: bool, if True, will output additional messages when errors occur.  Default False
    &#34;&#34;&#34;
    def __init__(self, capacity: int, debug: bool = False):
        &#34;&#34;&#34;
        Initialize the queue.
        Remember to only put the same type of data points into the queue.

        :param capacity: size of the queue
        :param debug: if True, output additional messages when errors occur, default False
        &#34;&#34;&#34;
        self.capacity: int = capacity
        self.first_data: List[Tuple] = [] * (capacity + 1)
        self.last_data: List[Tuple] = [] * (capacity + 1)
        self.debug: bool = debug

    def __repr__(self):
        return f&#34;capacity: {self.capacity}, &#34; \
               f&#34;first_data: {self.first_data}, &#34; \
               f&#34;last_data: {self.last_data}&#34;

    def __str__(self):
        return f&#34;capacity: {self.capacity}, &#34; \
               f&#34;\nfirst_data: [\n{self.first_data_as_string()}], &#34; \
               f&#34;\nlast_data: [\n{self.last_data_as_string()}]\n&#34;

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: FirstLastBuffer as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;capacity&#34;: self.capacity,
            &#34;first_data&#34;: self.first_data,
            &#34;last_data&#34;: self.last_data
        }

    @staticmethod
    def from_dict(data: dict) -&gt; &#34;FirstLastBuffer&#34;:
        &#34;&#34;&#34;
        :param data: dictionary to read from
        :return: FirstLastBuffer defined by the dictionary
        &#34;&#34;&#34;
        result = FirstLastBuffer(data[&#34;capacity&#34;])
        result.first_data = data[&#34;first_data&#34;]
        result.last_data = data[&#34;last_data&#34;]
        return result

    def first_data_as_string(self) -&gt; str:
        &#34;&#34;&#34;
        :return: string representation of the first_data queue
        &#34;&#34;&#34;
        return self._data_as_string(self.first_data)

    def last_data_as_string(self) -&gt; str:
        &#34;&#34;&#34;
        :return: string representation of the last_data queue
        &#34;&#34;&#34;
        return self._data_as_string(self.last_data)

    @staticmethod
    def _data_as_string(data_list: List[Tuple]) -&gt; str:
        &#34;&#34;&#34;
        :param data_list: the list of tuples to return as a string
        :return: list as a string
        &#34;&#34;&#34;
        result = &#34;&#34;
        for t, v in data_list:
            result += f&#34;{t}: {str(v)}\n&#34;
        return result

    @staticmethod
    def __ordered_insert(buffer: List, value: Tuple):
        &#34;&#34;&#34;
        inserts the value into the buffer using the timestamp as the key

        :param value: value to add.  Must include a timestamp and the same data type as the other buffer elements
        &#34;&#34;&#34;
        if len(buffer) &lt; 1:
            buffer.append(value)
        else:
            insort(buffer, value)

    def add(self, timestamp: float, value):
        &#34;&#34;&#34;
        add a value into one or more queues.
        If a queue is not full, the value is added automatically
        If the first_data queue is full, the value is only added if it comes before the last element.
        If the last_data queue is full, the value is only added if it comes after the first element.

        :param timestamp: timestamp in microseconds since epoch UTC to add.
        :param value: value to add.  Must be the same type of data as the other elements in the queue.
        &#34;&#34;&#34;
        if len(self.first_data) &lt; self.capacity or timestamp &lt; self.first_data[-1][0]:
            self.__ordered_insert(self.first_data, (timestamp, value))
            while len(self.first_data) &gt; self.capacity:
                self.first_data.pop()
        if len(self.last_data) &lt; self.capacity or timestamp &gt; self.last_data[0][0]:
            self.__ordered_insert(self.last_data, (timestamp, value))
            while len(self.last_data) &gt; self.capacity:
                self.last_data.pop(0)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.FirstLastBuffer.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data: dict) ‑> <a title="redvox.common.session_model_utils.FirstLastBuffer" href="#redvox.common.session_model_utils.FirstLastBuffer">FirstLastBuffer</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param data: dictionary to read from
:return: FirstLastBuffer defined by the dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(data: dict) -&gt; &#34;FirstLastBuffer&#34;:
    &#34;&#34;&#34;
    :param data: dictionary to read from
    :return: FirstLastBuffer defined by the dictionary
    &#34;&#34;&#34;
    result = FirstLastBuffer(data[&#34;capacity&#34;])
    result.first_data = data[&#34;first_data&#34;]
    result.last_data = data[&#34;last_data&#34;]
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.FirstLastBuffer.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, timestamp: float, value)</span>
</code></dt>
<dd>
<div class="desc"><p>add a value into one or more queues.
If a queue is not full, the value is added automatically
If the first_data queue is full, the value is only added if it comes before the last element.
If the last_data queue is full, the value is only added if it comes after the first element.</p>
<p>:param timestamp: timestamp in microseconds since epoch UTC to add.
:param value: value to add.
Must be the same type of data as the other elements in the queue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, timestamp: float, value):
    &#34;&#34;&#34;
    add a value into one or more queues.
    If a queue is not full, the value is added automatically
    If the first_data queue is full, the value is only added if it comes before the last element.
    If the last_data queue is full, the value is only added if it comes after the first element.

    :param timestamp: timestamp in microseconds since epoch UTC to add.
    :param value: value to add.  Must be the same type of data as the other elements in the queue.
    &#34;&#34;&#34;
    if len(self.first_data) &lt; self.capacity or timestamp &lt; self.first_data[-1][0]:
        self.__ordered_insert(self.first_data, (timestamp, value))
        while len(self.first_data) &gt; self.capacity:
            self.first_data.pop()
    if len(self.last_data) &lt; self.capacity or timestamp &gt; self.last_data[0][0]:
        self.__ordered_insert(self.last_data, (timestamp, value))
        while len(self.last_data) &gt; self.capacity:
            self.last_data.pop(0)</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.FirstLastBuffer.first_data_as_string"><code class="name flex">
<span>def <span class="ident">first_data_as_string</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: string representation of the first_data queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_data_as_string(self) -&gt; str:
    &#34;&#34;&#34;
    :return: string representation of the first_data queue
    &#34;&#34;&#34;
    return self._data_as_string(self.first_data)</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.FirstLastBuffer.last_data_as_string"><code class="name flex">
<span>def <span class="ident">last_data_as_string</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: string representation of the last_data queue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_data_as_string(self) -&gt; str:
    &#34;&#34;&#34;
    :return: string representation of the last_data queue
    &#34;&#34;&#34;
    return self._data_as_string(self.last_data)</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.FirstLastBuffer.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>:return: FirstLastBuffer as a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    :return: FirstLastBuffer as a dictionary
    &#34;&#34;&#34;
    return {
        &#34;capacity&#34;: self.capacity,
        &#34;first_data&#34;: self.first_data,
        &#34;last_data&#34;: self.last_data
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.session_model_utils.LocationModel"><code class="flex name class">
<span>class <span class="ident">LocationModel</span></span>
<span>(</span><span>capacity: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Location data used to build models
All times and timestamps are in microseconds since epoch UTC</p>
<h2 id="properties">Properties</h2>
<p>latitudes: WelfordStatsContainer for latitude values</p>
<p>longitudes: WelfordStatsContainer for longitude values</p>
<p>altitudes: WelfordStatsContainer for altitude values</p>
<p>first_last_location_data: FirstLastBuffer of Location data, a fixed size list of location data points.</p>
<p>initialize a LocationModel</p>
<p>:param capacity: int, number of data points to store in the first and last buffers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocationModel:
    &#34;&#34;&#34;
    Location data used to build models
    All times and timestamps are in microseconds since epoch UTC

    Properties:
        latitudes: WelfordStatsContainer for latitude values

        longitudes: WelfordStatsContainer for longitude values

        altitudes: WelfordStatsContainer for altitude values

        first_last_location_data: FirstLastBuffer of Location data, a fixed size list of location data points.
    &#34;&#34;&#34;
    def __init__(self, capacity: int):
        &#34;&#34;&#34;
        initialize a LocationModel

        :param capacity: int, number of data points to store in the first and last buffers.
        &#34;&#34;&#34;
        self.latitudes = WelfordStatsContainer()
        self.longitudes = WelfordStatsContainer()
        self.altitudes = WelfordStatsContainer()
        self.first_last_location_data = FirstLastBuffer(capacity)

    def __repr__(self):
        return f&#34;latitudes: {self.latitudes}, &#34; \
               f&#34;longitudes: {self.longitudes}, &#34; \
               f&#34;altitudes: {self.altitudes}, &#34; \
               f&#34;first_last_location_data: {self.first_last_location_data}&#34;

    def __str__(self):
        return f&#34;latitudes: {self.latitudes}, &#34; \
               f&#34;longitudes: {self.longitudes}, &#34; \
               f&#34;altitudes: {self.altitudes}, &#34; \
               f&#34;location data: {self.first_last_location_data}&#34;

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: LocationModel as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;latitudes&#34;: self.latitudes.to_dict(),
            &#34;longitudes&#34;: self.longitudes.to_dict(),
            &#34;altitudes&#34;: self.altitudes.to_dict(),
            &#34;first_last_location_data&#34;: self.first_last_location_data.to_dict(),
        }

    @staticmethod
    def from_dict(source: dict) -&gt; &#34;LocationModel&#34;:
        &#34;&#34;&#34;
        :param source: dictionary to read from
        :return: LocationModel
        &#34;&#34;&#34;
        flb = FirstLastBuffer.from_dict(source[&#34;first_last_location_data&#34;])
        result = LocationModel(0)
        result.latitudes = WelfordStatsContainer.from_dict(source[&#34;latitudes&#34;])
        result.longitudes = WelfordStatsContainer.from_dict(source[&#34;longitudes&#34;])
        result.altitudes = WelfordStatsContainer.from_dict(source[&#34;altitudes&#34;])
        result.first_last_location_data = flb
        return result

    def update_location(self, lat: float, lon: float, alt: float, timestamp: float):
        &#34;&#34;&#34;
        Add a location to the LocationStats

        :param lat: float, latitude in degrees
        :param lon: float, longitude in degrees
        :param alt: float, altitude in meters
        :param timestamp: float, timestamp of location in microseconds since epoch UTC
        &#34;&#34;&#34;
        self.latitudes.update(lat)
        self.longitudes.update(lon)
        self.altitudes.update(alt)
        self.first_last_location_data.add(timestamp, (lat, lon, alt))

    def finalized_latitude(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the latitude
        &#34;&#34;&#34;
        return self.latitudes.finalized()

    def finalized_longitude(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the longitude
        &#34;&#34;&#34;
        return self.longitudes.finalized()

    def finalized_altitude(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the altitude
        &#34;&#34;&#34;
        return self.altitudes.finalized()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.LocationModel.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>source: dict) ‑> <a title="redvox.common.session_model_utils.LocationModel" href="#redvox.common.session_model_utils.LocationModel">LocationModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param source: dictionary to read from
:return: LocationModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(source: dict) -&gt; &#34;LocationModel&#34;:
    &#34;&#34;&#34;
    :param source: dictionary to read from
    :return: LocationModel
    &#34;&#34;&#34;
    flb = FirstLastBuffer.from_dict(source[&#34;first_last_location_data&#34;])
    result = LocationModel(0)
    result.latitudes = WelfordStatsContainer.from_dict(source[&#34;latitudes&#34;])
    result.longitudes = WelfordStatsContainer.from_dict(source[&#34;longitudes&#34;])
    result.altitudes = WelfordStatsContainer.from_dict(source[&#34;altitudes&#34;])
    result.first_last_location_data = flb
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.LocationModel.finalized_altitude"><code class="name flex">
<span>def <span class="ident">finalized_altitude</span></span>(<span>self) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the mean and variance of the altitude</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalized_altitude(self) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    :return: the mean and variance of the altitude
    &#34;&#34;&#34;
    return self.altitudes.finalized()</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.LocationModel.finalized_latitude"><code class="name flex">
<span>def <span class="ident">finalized_latitude</span></span>(<span>self) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the mean and variance of the latitude</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalized_latitude(self) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    :return: the mean and variance of the latitude
    &#34;&#34;&#34;
    return self.latitudes.finalized()</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.LocationModel.finalized_longitude"><code class="name flex">
<span>def <span class="ident">finalized_longitude</span></span>(<span>self) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the mean and variance of the longitude</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalized_longitude(self) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    :return: the mean and variance of the longitude
    &#34;&#34;&#34;
    return self.longitudes.finalized()</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.LocationModel.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>:return: LocationModel as a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    :return: LocationModel as a dictionary
    &#34;&#34;&#34;
    return {
        &#34;latitudes&#34;: self.latitudes.to_dict(),
        &#34;longitudes&#34;: self.longitudes.to_dict(),
        &#34;altitudes&#34;: self.altitudes.to_dict(),
        &#34;first_last_location_data&#34;: self.first_last_location_data.to_dict(),
    }</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.LocationModel.update_location"><code class="name flex">
<span>def <span class="ident">update_location</span></span>(<span>self, lat: float, lon: float, alt: float, timestamp: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a location to the LocationStats</p>
<p>:param lat: float, latitude in degrees
:param lon: float, longitude in degrees
:param alt: float, altitude in meters
:param timestamp: float, timestamp of location in microseconds since epoch UTC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_location(self, lat: float, lon: float, alt: float, timestamp: float):
    &#34;&#34;&#34;
    Add a location to the LocationStats

    :param lat: float, latitude in degrees
    :param lon: float, longitude in degrees
    :param alt: float, altitude in meters
    :param timestamp: float, timestamp of location in microseconds since epoch UTC
    &#34;&#34;&#34;
    self.latitudes.update(lat)
    self.longitudes.update(lon)
    self.altitudes.update(alt)
    self.first_last_location_data.add(timestamp, (lat, lon, alt))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.session_model_utils.MetricsSessionModel"><code class="flex name class">
<span>class <span class="ident">MetricsSessionModel</span></span>
<span>(</span><span>capacity: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Metrics stored by the SessionModel</p>
<p>initialize the metrics stored by the session model</p>
<p>:param capacity: int, number of data points to store</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetricsSessionModel:
    &#34;&#34;&#34;
    Metrics stored by the SessionModel
    &#34;&#34;&#34;
    def __init__(self, capacity: int):
        &#34;&#34;&#34;
        initialize the metrics stored by the session model

        :param capacity: int, number of data points to store
        &#34;&#34;&#34;
        self.capacity: int = capacity
        self.location: Dict[str, LocationModel] = {}
        self.battery: WelfordStatsContainer = WelfordStatsContainer()
        self.temperature: WelfordStatsContainer = WelfordStatsContainer()

    def __repr__(self):
        return f&#34;location: {self.location}, &#34; \
               f&#34;battery: {self.battery}, &#34; \
               f&#34;temperature: {self.temperature}&#34;

    def __str__(self):
        return f&#34;location: {self.location}, &#34; \
               f&#34;battery percent: {self.battery}, &#34; \
               f&#34;temperature (C): {self.temperature}&#34;

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: MetricsSessionModel as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;capacity&#34;: self.capacity,
            &#34;location&#34;: {n: m.to_dict() for n, m in self.location.items()},
            &#34;battery&#34;: self.battery.to_dict(),
            &#34;temperature&#34;: self.temperature.to_dict()
        }

    @staticmethod
    def from_dict(source: dict) -&gt; &#34;MetricsSessionModel&#34;:
        &#34;&#34;&#34;
        :param source: dictionary to read from
        :return: MetricsSessionModel from dictionary
        &#34;&#34;&#34;
        result = MetricsSessionModel(source[&#34;capacity&#34;])
        result.location = {n: LocationModel.from_dict(m) for n, m in source[&#34;location&#34;].items()}
        result.battery = WelfordStatsContainer.from_dict(source[&#34;battery&#34;])
        result.temperature = WelfordStatsContainer.from_dict(source[&#34;temperature&#34;])
        return result

    def add_location(self, source: str, lat: float, lon: float, alt: float, timestamp: float):
        &#34;&#34;&#34;
        add a location from the named source to the session model

        :param source: str, name of the location data source
        :param lat: float, latitude in degrees
        :param lon: float, longitude in degrees
        :param alt: float, altitude in meters
        :param timestamp: float, timestamp of location in microseconds since epoch UTC
        &#34;&#34;&#34;
        if source not in self.location.keys():
            self.location[source] = LocationModel(self.capacity)
        self.location[source].update_location(lat, lon, alt, timestamp)

    def add_battery(self, data: float):
        &#34;&#34;&#34;
        add battery data to the session model

        :param data: float, battery percentage to add
        &#34;&#34;&#34;
        self.battery.update(data)

    def add_temperature(self, data: float):
        &#34;&#34;&#34;
        add temperature data to the session model

        :param data: float, temperature in Celsius to add
        &#34;&#34;&#34;
        self.temperature.update(data)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.MetricsSessionModel.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>source: dict) ‑> <a title="redvox.common.session_model_utils.MetricsSessionModel" href="#redvox.common.session_model_utils.MetricsSessionModel">MetricsSessionModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param source: dictionary to read from
:return: MetricsSessionModel from dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(source: dict) -&gt; &#34;MetricsSessionModel&#34;:
    &#34;&#34;&#34;
    :param source: dictionary to read from
    :return: MetricsSessionModel from dictionary
    &#34;&#34;&#34;
    result = MetricsSessionModel(source[&#34;capacity&#34;])
    result.location = {n: LocationModel.from_dict(m) for n, m in source[&#34;location&#34;].items()}
    result.battery = WelfordStatsContainer.from_dict(source[&#34;battery&#34;])
    result.temperature = WelfordStatsContainer.from_dict(source[&#34;temperature&#34;])
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.MetricsSessionModel.add_battery"><code class="name flex">
<span>def <span class="ident">add_battery</span></span>(<span>self, data: float)</span>
</code></dt>
<dd>
<div class="desc"><p>add battery data to the session model</p>
<p>:param data: float, battery percentage to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_battery(self, data: float):
    &#34;&#34;&#34;
    add battery data to the session model

    :param data: float, battery percentage to add
    &#34;&#34;&#34;
    self.battery.update(data)</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.MetricsSessionModel.add_location"><code class="name flex">
<span>def <span class="ident">add_location</span></span>(<span>self, source: str, lat: float, lon: float, alt: float, timestamp: float)</span>
</code></dt>
<dd>
<div class="desc"><p>add a location from the named source to the session model</p>
<p>:param source: str, name of the location data source
:param lat: float, latitude in degrees
:param lon: float, longitude in degrees
:param alt: float, altitude in meters
:param timestamp: float, timestamp of location in microseconds since epoch UTC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_location(self, source: str, lat: float, lon: float, alt: float, timestamp: float):
    &#34;&#34;&#34;
    add a location from the named source to the session model

    :param source: str, name of the location data source
    :param lat: float, latitude in degrees
    :param lon: float, longitude in degrees
    :param alt: float, altitude in meters
    :param timestamp: float, timestamp of location in microseconds since epoch UTC
    &#34;&#34;&#34;
    if source not in self.location.keys():
        self.location[source] = LocationModel(self.capacity)
    self.location[source].update_location(lat, lon, alt, timestamp)</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.MetricsSessionModel.add_temperature"><code class="name flex">
<span>def <span class="ident">add_temperature</span></span>(<span>self, data: float)</span>
</code></dt>
<dd>
<div class="desc"><p>add temperature data to the session model</p>
<p>:param data: float, temperature in Celsius to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_temperature(self, data: float):
    &#34;&#34;&#34;
    add temperature data to the session model

    :param data: float, temperature in Celsius to add
    &#34;&#34;&#34;
    self.temperature.update(data)</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.MetricsSessionModel.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>:return: MetricsSessionModel as a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    :return: MetricsSessionModel as a dictionary
    &#34;&#34;&#34;
    return {
        &#34;capacity&#34;: self.capacity,
        &#34;location&#34;: {n: m.to_dict() for n, m in self.location.items()},
        &#34;battery&#34;: self.battery.to_dict(),
        &#34;temperature&#34;: self.temperature.to_dict()
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.session_model_utils.SensorModel"><code class="flex name class">
<span>class <span class="ident">SensorModel</span></span>
<span>(</span><span>name: str, desc: str, mean_sample_rate: float)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple representation of a Sensor.
Sample rate data is in Hz</p>
<h2 id="properties">Properties</h2>
<p>name: str, name of the Sensor</p>
<p>description: str, description of the Sensor</p>
<p>sample_rate_stats: WelfordStatsContainer used to calculate the mean, std deviation, variance, etc. of the
sensor's sample rate</p>
<p>initialize SensorModel</p>
<p>:param name: name of the sensor
:param desc: description of the sensor
:param mean_sample_rate: mean sample rate of the sensor in Hz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorModel:
    &#34;&#34;&#34;
    A simple representation of a Sensor.  Sample rate data is in Hz

    Properties:
        name: str, name of the Sensor

        description: str, description of the Sensor

        sample_rate_stats: WelfordStatsContainer used to calculate the mean, std deviation, variance, etc. of the
        sensor&#39;s sample rate
    &#34;&#34;&#34;
    def __init__(self, name: str, desc: str, mean_sample_rate: float):
        &#34;&#34;&#34;
        initialize SensorModel

        :param name: name of the sensor
        :param desc: description of the sensor
        :param mean_sample_rate: mean sample rate of the sensor in Hz
        &#34;&#34;&#34;
        self.name: str = name
        self.description: str = desc
        self.sample_rate_stats: WelfordStatsContainer = WelfordStatsContainer()
        self.sample_rate_stats.update(mean_sample_rate)

    def __repr__(self):
        return f&#34;name: {self.name}, &#34; \
               f&#34;description: {self.description}, &#34; \
               f&#34;sample_rate_stats: {self.sample_rate_stats}&#34;

    def to_dict(self) -&gt; Dict:
        &#34;&#34;&#34;
        :return: sensor model as dictionary
        &#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;description&#34;: self.description,
            &#34;sample_rate_stats&#34;: self.sample_rate_stats.to_dict()
        }

    @staticmethod
    def from_dict(source: dict) -&gt; &#34;SensorModel&#34;:
        &#34;&#34;&#34;
        :param source: dictionary to read
        :return: SensorModel from dictionary
        &#34;&#34;&#34;
        result = SensorModel(source[&#34;name&#34;], source[&#34;description&#34;], 0)
        result.sample_rate_stats = WelfordStatsContainer.from_dict(source[&#34;sample_rate_stats&#34;])
        return result

    def update(self, new_mean_sr: float):
        &#34;&#34;&#34;
        adds a new mean sample rate to the SensorModel

        :param new_mean_sr: new mean sample rate to add
        &#34;&#34;&#34;
        self.sample_rate_stats.update(new_mean_sr)

    def finalized(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        :return: the mean and variance of the sample rate stats
        &#34;&#34;&#34;
        return self.sample_rate_stats.finalized()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.SensorModel.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>source: dict) ‑> <a title="redvox.common.session_model_utils.SensorModel" href="#redvox.common.session_model_utils.SensorModel">SensorModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param source: dictionary to read
:return: SensorModel from dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(source: dict) -&gt; &#34;SensorModel&#34;:
    &#34;&#34;&#34;
    :param source: dictionary to read
    :return: SensorModel from dictionary
    &#34;&#34;&#34;
    result = SensorModel(source[&#34;name&#34;], source[&#34;description&#34;], 0)
    result.sample_rate_stats = WelfordStatsContainer.from_dict(source[&#34;sample_rate_stats&#34;])
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.SensorModel.finalized"><code class="name flex">
<span>def <span class="ident">finalized</span></span>(<span>self) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the mean and variance of the sample rate stats</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalized(self) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    :return: the mean and variance of the sample rate stats
    &#34;&#34;&#34;
    return self.sample_rate_stats.finalized()</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.SensorModel.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>:return: sensor model as dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; Dict:
    &#34;&#34;&#34;
    :return: sensor model as dictionary
    &#34;&#34;&#34;
    return {
        &#34;name&#34;: self.name,
        &#34;description&#34;: self.description,
        &#34;sample_rate_stats&#34;: self.sample_rate_stats.to_dict()
    }</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.SensorModel.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, new_mean_sr: float)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a new mean sample rate to the SensorModel</p>
<p>:param new_mean_sr: new mean sample rate to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, new_mean_sr: float):
    &#34;&#34;&#34;
    adds a new mean sample rate to the SensorModel

    :param new_mean_sr: new mean sample rate to add
    &#34;&#34;&#34;
    self.sample_rate_stats.update(new_mean_sr)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.session_model_utils.TimeSyncModel"><code class="flex name class">
<span>class <span class="ident">TimeSyncModel</span></span>
<span>(</span><span>capacity: int, first_timesync_timestamp: float = inf, last_timesync_timestamp: float = 0.0, mean_latency: float = 0.0, mean_offset: float = 0.0, num_exchanges: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>TimeSync data used to build models
All times and timestamps are in microseconds since epoch UTC</p>
<h2 id="properties">Properties</h2>
<p>first_timesync_timestamp: float, the first timestamp of the TimeSync data.
Default infinity</p>
<p>last_timesync_timestamp: float, the last timestamp of the TimeSync data.
Default 0.0</p>
<p>mean_latency: float, the mean latency of the TimeSync data.
Default 0.0</p>
<p>mean_offset: float, the mean offset of the TimeSync data.
Default 0.0</p>
<p>num_exchanges: int, number of exchanges in the TimeSync data.
Default 0</p>
<p>first_last_timesync_data: FirstLastBuffer of TimeSync data, a fixed size list of timesync exchanges used to
calculate the offset model.</p>
<p>Initialize the TimeSyncModel</p>
<p>:param capacity: the number of data points to keep in each of the first and last data buffers
:param first_timesync_timestamp: the first timestamp of the TimeSync data.
Default infinity
:param last_timesync_timestamp: the last timestamp of the TimeSync data.
Default 0.0
:param mean_latency: the mean latency of the TimeSync data.
Default 0.0
:param mean_offset: the mean offset of the TimeSync data.
Default 0.0
:param num_exchanges: the number of exchanges in the TimeSync data.
Default 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeSyncModel:
    &#34;&#34;&#34;
    TimeSync data used to build models
    All times and timestamps are in microseconds since epoch UTC

    Properties:
        first_timesync_timestamp: float, the first timestamp of the TimeSync data.  Default infinity

        last_timesync_timestamp: float, the last timestamp of the TimeSync data.  Default 0.0

        mean_latency: float, the mean latency of the TimeSync data.  Default 0.0

        mean_offset: float, the mean offset of the TimeSync data.  Default 0.0

        num_exchanges: int, number of exchanges in the TimeSync data.  Default 0

        first_last_timesync_data: FirstLastBuffer of TimeSync data, a fixed size list of timesync exchanges used to
                                    calculate the offset model.
    &#34;&#34;&#34;
    def __init__(self,
                 capacity: int,
                 first_timesync_timestamp: float = float(&#34;inf&#34;),
                 last_timesync_timestamp: float = 0.0,
                 mean_latency: float = 0.0,
                 mean_offset: float = 0.0,
                 num_exchanges: int = 0
                 ):
        &#34;&#34;&#34;
        Initialize the TimeSyncModel

        :param capacity: the number of data points to keep in each of the first and last data buffers
        :param first_timesync_timestamp: the first timestamp of the TimeSync data.  Default infinity
        :param last_timesync_timestamp: the last timestamp of the TimeSync data.  Default 0.0
        :param mean_latency: the mean latency of the TimeSync data.  Default 0.0
        :param mean_offset: the mean offset of the TimeSync data.  Default 0.0
        :param num_exchanges: the number of exchanges in the TimeSync data.  Default 0
        &#34;&#34;&#34;
        self.first_timesync_timestamp = first_timesync_timestamp
        self.last_timesync_timestamp = last_timesync_timestamp
        self.mean_latency = mean_latency
        self.mean_offset = mean_offset
        self.num_exchanges = num_exchanges
        self.first_last_timesync_data: FirstLastBuffer = FirstLastBuffer(capacity)

    def __repr__(self):
        return f&#34;first_timesync_timestamp: {self.first_timesync_timestamp}, &#34; \
               f&#34;last_timesync_timestamp: {self.last_timesync_timestamp}, &#34; \
               f&#34;mean_latency: {self.mean_latency}, &#34; \
               f&#34;mean_offset: {self.mean_offset}, &#34; \
               f&#34;num_exchanges: {self.num_exchanges}, &#34; \
               f&#34;first_last_timesync_data: {self.first_last_timesync_data.to_dict()}&#34;

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: TimeSyncModel as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;first_timesync_timestamp&#34;: self.first_timesync_timestamp,
            &#34;last_timesync_timestamp&#34;: self.last_timesync_timestamp,
            &#34;mean_latency&#34;: self.mean_latency,
            &#34;mean_offset&#34;: self.mean_offset,
            &#34;num_exchanges&#34;: self.num_exchanges,
            &#34;first_last_timesync_data&#34;: self.first_last_timesync_data.to_dict()
        }

    @staticmethod
    def from_dict(source: dict) -&gt; &#34;TimeSyncModel&#34;:
        &#34;&#34;&#34;
        :param source: dictionary to read from
        :return: TimeSyncModel from dictionary
        &#34;&#34;&#34;
        flb = FirstLastBuffer.from_dict(source[&#34;first_last_timesync_data&#34;])
        result = TimeSyncModel(0, source[&#34;first_timesync_timestamp&#34;],
                               source[&#34;last_timesync_timestamp&#34;], source[&#34;mean_latency&#34;], source[&#34;mean_offset&#34;],
                               source[&#34;num_exchanges&#34;])
        result.first_last_timesync_data = flb
        return result

    def update_model(self, ts: TimeSync):
        &#34;&#34;&#34;
        Use a TimeSync object to update the TimeSyncModel

        :param ts: TimeSync object to update the model with
        &#34;&#34;&#34;
        if ts.num_tri_messages() &gt; 0:
            self.num_exchanges += ts.num_tri_messages()
            self.mean_latency = \
                (self.mean_latency * self.num_exchanges + ts.best_latency()) / (self.num_exchanges + 1)
            self.mean_offset = \
                (self.mean_offset * self.num_exchanges + ts.best_offset()) / (self.num_exchanges + 1)
            _ts_latencies = ts.latencies().flatten()
            _ts_offsets = ts.offsets().flatten()
            _ts_timestamps = ts.get_device_exchanges_timestamps()
            if ts.data_start_timestamp() &lt; self.first_timesync_timestamp:
                self.first_timesync_timestamp = ts.data_start_timestamp()
            if ts.data_end_timestamp() &gt; self.last_timesync_timestamp:
                self.last_timesync_timestamp = ts.data_end_timestamp()
            # add data to the buffers
            for i in range(len(_ts_timestamps)):
                self.first_last_timesync_data.add(_ts_timestamps[i], (_ts_latencies[i], _ts_offsets[i]))

    def create_offset_model(self) -&gt; OffsetModel:
        &#34;&#34;&#34;
        :return: OffsetModel using the data in the TimeSyncModel
        &#34;&#34;&#34;
        latencies = []
        offsets = []
        timestamps = []
        for n in self.first_last_timesync_data.first_data:
            latencies.append(n[1][0])
            offsets.append(n[1][0])
            timestamps.append(n[0])
        for n in self.first_last_timesync_data.last_data:
            latencies.append(n[1][0])
            offsets.append(n[1][0])
            timestamps.append(n[0])
        return OffsetModel(np.array(latencies), np.array(offsets), np.array(timestamps),
                           self.first_timesync_timestamp, self.last_timesync_timestamp,
                           min_samples_per_bin=1)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.TimeSyncModel.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>source: dict) ‑> <a title="redvox.common.session_model_utils.TimeSyncModel" href="#redvox.common.session_model_utils.TimeSyncModel">TimeSyncModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param source: dictionary to read from
:return: TimeSyncModel from dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(source: dict) -&gt; &#34;TimeSyncModel&#34;:
    &#34;&#34;&#34;
    :param source: dictionary to read from
    :return: TimeSyncModel from dictionary
    &#34;&#34;&#34;
    flb = FirstLastBuffer.from_dict(source[&#34;first_last_timesync_data&#34;])
    result = TimeSyncModel(0, source[&#34;first_timesync_timestamp&#34;],
                           source[&#34;last_timesync_timestamp&#34;], source[&#34;mean_latency&#34;], source[&#34;mean_offset&#34;],
                           source[&#34;num_exchanges&#34;])
    result.first_last_timesync_data = flb
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.session_model_utils.TimeSyncModel.create_offset_model"><code class="name flex">
<span>def <span class="ident">create_offset_model</span></span>(<span>self) ‑> <a title="redvox.common.offset_model.OffsetModel" href="offset_model.html#redvox.common.offset_model.OffsetModel">OffsetModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: OffsetModel using the data in the TimeSyncModel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_offset_model(self) -&gt; OffsetModel:
    &#34;&#34;&#34;
    :return: OffsetModel using the data in the TimeSyncModel
    &#34;&#34;&#34;
    latencies = []
    offsets = []
    timestamps = []
    for n in self.first_last_timesync_data.first_data:
        latencies.append(n[1][0])
        offsets.append(n[1][0])
        timestamps.append(n[0])
    for n in self.first_last_timesync_data.last_data:
        latencies.append(n[1][0])
        offsets.append(n[1][0])
        timestamps.append(n[0])
    return OffsetModel(np.array(latencies), np.array(offsets), np.array(timestamps),
                       self.first_timesync_timestamp, self.last_timesync_timestamp,
                       min_samples_per_bin=1)</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.TimeSyncModel.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>:return: TimeSyncModel as a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    :return: TimeSyncModel as a dictionary
    &#34;&#34;&#34;
    return {
        &#34;first_timesync_timestamp&#34;: self.first_timesync_timestamp,
        &#34;last_timesync_timestamp&#34;: self.last_timesync_timestamp,
        &#34;mean_latency&#34;: self.mean_latency,
        &#34;mean_offset&#34;: self.mean_offset,
        &#34;num_exchanges&#34;: self.num_exchanges,
        &#34;first_last_timesync_data&#34;: self.first_last_timesync_data.to_dict()
    }</code></pre>
</details>
</dd>
<dt id="redvox.common.session_model_utils.TimeSyncModel.update_model"><code class="name flex">
<span>def <span class="ident">update_model</span></span>(<span>self, ts: <a title="redvox.common.timesync.TimeSync" href="timesync.html#redvox.common.timesync.TimeSync">TimeSync</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Use a TimeSync object to update the TimeSyncModel</p>
<p>:param ts: TimeSync object to update the model with</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_model(self, ts: TimeSync):
    &#34;&#34;&#34;
    Use a TimeSync object to update the TimeSyncModel

    :param ts: TimeSync object to update the model with
    &#34;&#34;&#34;
    if ts.num_tri_messages() &gt; 0:
        self.num_exchanges += ts.num_tri_messages()
        self.mean_latency = \
            (self.mean_latency * self.num_exchanges + ts.best_latency()) / (self.num_exchanges + 1)
        self.mean_offset = \
            (self.mean_offset * self.num_exchanges + ts.best_offset()) / (self.num_exchanges + 1)
        _ts_latencies = ts.latencies().flatten()
        _ts_offsets = ts.offsets().flatten()
        _ts_timestamps = ts.get_device_exchanges_timestamps()
        if ts.data_start_timestamp() &lt; self.first_timesync_timestamp:
            self.first_timesync_timestamp = ts.data_start_timestamp()
        if ts.data_end_timestamp() &gt; self.last_timesync_timestamp:
            self.last_timesync_timestamp = ts.data_end_timestamp()
        # add data to the buffers
        for i in range(len(_ts_timestamps)):
            self.first_last_timesync_data.add(_ts_timestamps[i], (_ts_latencies[i], _ts_offsets[i]))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.common.session_model_utils.FirstLastBuffer" href="#redvox.common.session_model_utils.FirstLastBuffer">FirstLastBuffer</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.session_model_utils.FirstLastBuffer.add" href="#redvox.common.session_model_utils.FirstLastBuffer.add">add</a></code></li>
<li><code><a title="redvox.common.session_model_utils.FirstLastBuffer.first_data_as_string" href="#redvox.common.session_model_utils.FirstLastBuffer.first_data_as_string">first_data_as_string</a></code></li>
<li><code><a title="redvox.common.session_model_utils.FirstLastBuffer.from_dict" href="#redvox.common.session_model_utils.FirstLastBuffer.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.session_model_utils.FirstLastBuffer.last_data_as_string" href="#redvox.common.session_model_utils.FirstLastBuffer.last_data_as_string">last_data_as_string</a></code></li>
<li><code><a title="redvox.common.session_model_utils.FirstLastBuffer.to_dict" href="#redvox.common.session_model_utils.FirstLastBuffer.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.session_model_utils.LocationModel" href="#redvox.common.session_model_utils.LocationModel">LocationModel</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.common.session_model_utils.LocationModel.finalized_altitude" href="#redvox.common.session_model_utils.LocationModel.finalized_altitude">finalized_altitude</a></code></li>
<li><code><a title="redvox.common.session_model_utils.LocationModel.finalized_latitude" href="#redvox.common.session_model_utils.LocationModel.finalized_latitude">finalized_latitude</a></code></li>
<li><code><a title="redvox.common.session_model_utils.LocationModel.finalized_longitude" href="#redvox.common.session_model_utils.LocationModel.finalized_longitude">finalized_longitude</a></code></li>
<li><code><a title="redvox.common.session_model_utils.LocationModel.from_dict" href="#redvox.common.session_model_utils.LocationModel.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.session_model_utils.LocationModel.to_dict" href="#redvox.common.session_model_utils.LocationModel.to_dict">to_dict</a></code></li>
<li><code><a title="redvox.common.session_model_utils.LocationModel.update_location" href="#redvox.common.session_model_utils.LocationModel.update_location">update_location</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.session_model_utils.MetricsSessionModel" href="#redvox.common.session_model_utils.MetricsSessionModel">MetricsSessionModel</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.session_model_utils.MetricsSessionModel.add_battery" href="#redvox.common.session_model_utils.MetricsSessionModel.add_battery">add_battery</a></code></li>
<li><code><a title="redvox.common.session_model_utils.MetricsSessionModel.add_location" href="#redvox.common.session_model_utils.MetricsSessionModel.add_location">add_location</a></code></li>
<li><code><a title="redvox.common.session_model_utils.MetricsSessionModel.add_temperature" href="#redvox.common.session_model_utils.MetricsSessionModel.add_temperature">add_temperature</a></code></li>
<li><code><a title="redvox.common.session_model_utils.MetricsSessionModel.from_dict" href="#redvox.common.session_model_utils.MetricsSessionModel.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.session_model_utils.MetricsSessionModel.to_dict" href="#redvox.common.session_model_utils.MetricsSessionModel.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.session_model_utils.SensorModel" href="#redvox.common.session_model_utils.SensorModel">SensorModel</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.session_model_utils.SensorModel.finalized" href="#redvox.common.session_model_utils.SensorModel.finalized">finalized</a></code></li>
<li><code><a title="redvox.common.session_model_utils.SensorModel.from_dict" href="#redvox.common.session_model_utils.SensorModel.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.session_model_utils.SensorModel.to_dict" href="#redvox.common.session_model_utils.SensorModel.to_dict">to_dict</a></code></li>
<li><code><a title="redvox.common.session_model_utils.SensorModel.update" href="#redvox.common.session_model_utils.SensorModel.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.session_model_utils.TimeSyncModel" href="#redvox.common.session_model_utils.TimeSyncModel">TimeSyncModel</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.session_model_utils.TimeSyncModel.create_offset_model" href="#redvox.common.session_model_utils.TimeSyncModel.create_offset_model">create_offset_model</a></code></li>
<li><code><a title="redvox.common.session_model_utils.TimeSyncModel.from_dict" href="#redvox.common.session_model_utils.TimeSyncModel.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.session_model_utils.TimeSyncModel.to_dict" href="#redvox.common.session_model_utils.TimeSyncModel.to_dict">to_dict</a></code></li>
<li><code><a title="redvox.common.session_model_utils.TimeSyncModel.update_model" href="#redvox.common.session_model_utils.TimeSyncModel.update_model">update_model</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>