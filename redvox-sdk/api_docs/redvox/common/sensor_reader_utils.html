<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>redvox.common.sensor_reader_utils API documentation</title>
<meta name="description" content="This module loads sensor data from Redvox packets" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.sensor_reader_utils</code></h1>
</header>
<section id="section-intro">
<p>This module loads sensor data from Redvox packets</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module loads sensor data from Redvox packets
&#34;&#34;&#34;

from typing import List, Optional, Tuple

import numpy as np
import pandas as pd

from redvox.common import date_time_utils as dtu
from redvox.common.sensor_data import SensorType, SensorData
from redvox.api1000.wrapped_redvox_packet.sensors import xyz, single
from redvox.api1000.wrapped_redvox_packet.wrapped_packet import WrappedRedvoxPacketM
from redvox.api1000.wrapped_redvox_packet.sensors.audio import AudioCodec
from redvox.api1000.wrapped_redvox_packet.sensors.location import LocationProvider
from redvox.api1000.wrapped_redvox_packet.sensors.image import ImageCodec
from redvox.api1000.wrapped_redvox_packet.station_information import NetworkType, PowerState, CellServiceState


def get_empty_sensor_data(
        name: str, sensor_type: SensorType = SensorType.UNKNOWN_SENSOR
) -&gt; SensorData:
    &#34;&#34;&#34;
    create a sensor data object with no data
    :param name: name of the sensor
    :param sensor_type: type of the sensor to create, default SensorType.UNKNOWN_SENSOR
    :return: empty sensor
    &#34;&#34;&#34;
    return SensorData(name, pd.DataFrame([], columns=[&#34;timestamps&#34;]), sensor_type)


def calc_evenly_sampled_timestamps(
        start: float, samples: int, rate_hz: float
) -&gt; np.array:
    &#34;&#34;&#34;
    given a start time, calculates samples amount of evenly spaced timestamps at rate_hz
    :param start: float, start timestamp in microseconds
    :param samples: int, number of samples
    :param rate_hz: float, sample rate in hz
    :return: np.array with evenly spaced timestamps starting at start
    &#34;&#34;&#34;
    return start + (np.arange(0, samples) / rate_hz) * dtu.MICROSECONDS_IN_SECOND


def get_sample_statistics(data_df: pd.DataFrame) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;
    calculate the sample rate, interval and interval std dev using the timestamps in the dataframe
    :param data_df: the dataframe containing timestamps to calculate statistics from
    :return: a Tuple containing the sample rate, interval and interval std dev
    &#34;&#34;&#34;
    if data_df[&#34;timestamps&#34;].size &gt; 1:
        sample_interval = dtu.microseconds_to_seconds(
            float(np.mean(np.diff(data_df[&#34;timestamps&#34;])))
        )
        sample_interval_std = dtu.microseconds_to_seconds(
            float(np.std(np.diff(data_df[&#34;timestamps&#34;])))
        )
    else:
        sample_interval = np.nan
        sample_interval_std = np.nan
    return 1 / sample_interval, sample_interval, sample_interval_std


def read_apim_xyz_sensor(sensor: xyz.Xyz, column_id: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    read a sensor that has xyz data channels from an api M data packet
    raises Attribute Error if sensor does not contain xyz channels
    :param sensor: the xyz api M sensor to read
    :param column_id: string, used to name the columns
    :return: Dataframe representing the data in the sensor
    &#34;&#34;&#34;
    timestamps = sensor.get_timestamps().get_timestamps()
    try:
        columns = [&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, f&#34;{column_id}_x&#34;, f&#34;{column_id}_y&#34;, f&#34;{column_id}_z&#34;]
        return pd.DataFrame(
            np.transpose(
                [
                    timestamps,
                    timestamps,
                    sensor.get_x_samples().get_values(),
                    sensor.get_y_samples().get_values(),
                    sensor.get_z_samples().get_values(),
                ]
            ),
            columns=columns,
        )
    except AttributeError:
        raise


def load_apim_xyz_sensor(sensor_type: SensorType, data, name, description) -&gt; Optional[SensorData]:
    if len(data[0]) &gt; 0:
        return SensorData(
            description,
            pd.DataFrame(np.transpose([data[0], data[0], data[1], data[2], data[3]]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, f&#34;{name}_x&#34;, f&#34;{name}_y&#34;, f&#34;{name}_z&#34;]),
            sensor_type,
            calculate_stats=True
        )
    return None


def read_apim_single_sensor(sensor: single.Single, column_id: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    read a sensor that has a single data channel from an api M data packet
    raises Attribute Error if sensor does not contain exactly one data channel
    :param sensor: the single channel api M sensor to read
    :param column_id: string, used to name the columns
    :return: Dataframe representing the data in the sensor
    &#34;&#34;&#34;
    timestamps = sensor.get_timestamps().get_timestamps()
    try:
        columns = [&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, column_id]
        return pd.DataFrame(
            np.transpose([timestamps, timestamps, sensor.get_samples().get_values()]),
            columns=columns,
        )
    except AttributeError:
        raise


def load_apim_audio(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load audio data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: audio sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    audio = wrapped_packet.get_sensors().get_audio()
    if audio and wrapped_packet.get_sensors().validate_audio():
        sample_rate_hz = audio.get_sample_rate()
        data_for_df = audio.get_samples().get_values()
        timestamps = calc_evenly_sampled_timestamps(
            audio.get_first_sample_timestamp(), audio.get_num_samples(), sample_rate_hz
        )
        return SensorData(
            audio.get_sensor_description(),
            pd.DataFrame(
                np.transpose([timestamps, timestamps, data_for_df]),
                columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;microphone&#34;],
            ),
            SensorType.AUDIO,
            sample_rate_hz,
            1 / sample_rate_hz,
            0.0,
            True,
            )
    return None


def fill_audio_gaps(
        timestamps: np.array,
        audio_data: np.array,
        sample_interval_micros: float,
        samples_per_packet: int,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    fills gaps in the dataframe with np.nan by interpolating timestamps based on the mean expected sample interval
    :param timestamps: array of timestamps for the data
    :param audio_data: array of data points
    :param sample_interval_micros: sample interval in microseconds
    :param samples_per_packet: number of samples to create per packet
    :return: dataframe without gaps
    &#34;&#34;&#34;
    PERCENT_PACKET_CONFIRM = .9
    PERCENT_NOT_PACKET_CONFIRM = .02
    result_df = pd.DataFrame(np.transpose([timestamps, timestamps, audio_data]),
                             columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;microphone&#34;])
    num_points = len(timestamps)
    # if there are less points than our expected amount, we have gaps to fill
    if num_points &lt; 10000:
        # look at every timestamp difference
        timestamp_diffs = np.diff(timestamps)
        for index in np.where(timestamp_diffs &gt; sample_interval_micros)[0]:
            num_samples = timestamp_diffs[index] / sample_interval_micros
            if num_samples &lt;= samples_per_packet * PERCENT_NOT_PACKET_CONFIRM:
                break  # difference too small, no gap
            elif num_samples &gt;= samples_per_packet * PERCENT_PACKET_CONFIRM:
                # add samples per packet for each packet missing
                num_samples = samples_per_packet * np.floor(num_samples / (samples_per_packet * PERCENT_PACKET_CONFIRM))
            # add the gap data to the result dataframe
            result_df = add_dataless_timestamps_to_df(
                result_df,
                index,
                sample_interval_micros,
                num_samples,
            )
    else:
        # too many points to check, divide and conquer using recursion!
        half_samples = int(num_points / 2)
        first_data_timestamps = timestamps[:half_samples]
        first_audio_data = audio_data[:half_samples]
        second_data_timestamps = timestamps[half_samples:]
        second_audio_data = audio_data[half_samples:]
        # give half the samples to each recursive call
        first_data_timestamps = fill_audio_gaps(
            first_data_timestamps,
            first_audio_data,
            sample_interval_micros,
            samples_per_packet,
        )
        second_data_timestamps = fill_audio_gaps(
            second_data_timestamps,
            second_audio_data,
            sample_interval_micros,
            samples_per_packet,
        )
        result_df = first_data_timestamps.append(second_data_timestamps, ignore_index=True)
        mid_timestamps = timestamps[half_samples-1:half_samples+1]
        mid_audio_data = audio_data[half_samples-1:half_samples+1]
        mid_df = fill_audio_gaps(mid_timestamps, mid_audio_data, sample_interval_micros, samples_per_packet)
        if len(mid_df[&#34;timestamps&#34;]) &gt; 2:
            mid_df = mid_df.iloc[1:len(mid_df[&#34;timestamps&#34;])-1]
            result_df = result_df.append(mid_df, ignore_index=True)
    return result_df.sort_values(&#34;timestamps&#34;, ignore_index=True)


def add_dataless_timestamps_to_df(dataframe: pd.DataFrame,
                                  start_index: int,
                                  sample_interval_micros: float,
                                  num_samples_to_add: int,
                                  add_to_start: bool = False,) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    adds dataless timestamps directly to a dataframe that already contains data
    Note:   dataframe must not be empty,
            start_index must be non-negative and less than the length of dataframe,
            num_samples_to_add must be greater than 0
    :param dataframe: dataframe to add dataless timestamps to
    :param start_index: index of the dataframe to use as starting point for creating new values
    :param sample_interval_micros: sample interval in microseconds of the timestamps
    :param num_samples_to_add: the number of timestamps to create
    :param add_to_start: if True, subtracts sample_interval_micros from start_timestamp, default False
    :return: updated dataframe with synthetic data points
    &#34;&#34;&#34;
    if len(dataframe) &gt; start_index and len(dataframe) &gt; 0 and num_samples_to_add &gt; 0:
        start_timestamp = dataframe[&#34;timestamps&#34;][start_index]
        dataframe = dataframe.append(
            create_dataless_timestamps_df(start_timestamp, sample_interval_micros,
                                          dataframe.columns, num_samples_to_add, add_to_start),
            ignore_index=True)
    return dataframe


def create_dataless_timestamps_df(
        start_timestamp: float,
        sample_interval_micros: float,
        columns: pd.Index,
        num_samples_to_add: int,
        add_to_start: bool = False,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Creates an empty dataframe with num_samples_to_add timestamps, using columns as the columns
    the first timestamp created is 1 sample_interval_s from the start_timestamp
    :param start_timestamp: timestamp in microseconds since epoch UTC to start calculating other timestamps from
    :param sample_interval_micros: fixed sample interval in microseconds since epoch UTC
    :param columns: dataframe the non-timestamp columns of the dataframe
    :param num_samples_to_add: the number of timestamps to create
    :param add_to_start: if True, subtracts sample_interval_s from start_timestamp, default False
    :return: dataframe with timestamps and no data
    &#34;&#34;&#34;
    empty_df = pd.DataFrame([], columns=columns)
    if num_samples_to_add &gt; 0:
        for column_index in columns:
            if column_index == &#34;timestamps&#34;:
                if add_to_start:
                    sample_interval_micros = -sample_interval_micros
                empty_df[column_index] = (
                        start_timestamp + np.arange(1, num_samples_to_add + 1) * sample_interval_micros
                )
            elif column_index == &#34;location_provider&#34;:
                empty_df[column_index] = LocationProvider.UNKNOWN
            elif column_index == &#34;image_codec&#34;:
                empty_df[column_index] = ImageCodec.UNKNOWN
            elif column_index == &#34;audio_codec&#34;:
                empty_df[column_index] = AudioCodec.UNKNOWN
            elif column_index == &#34;network_type&#34;:
                empty_df[column_index] = NetworkType.UNKNOWN_NETWORK
            elif column_index == &#34;power_state&#34;:
                empty_df[column_index] = PowerState.UNKNOWN_POWER_STATE
            elif column_index == &#34;cell_service&#34;:
                empty_df[column_index] = CellServiceState.UNKNOWN
            else:
                empty_df[column_index] = np.nan
    return empty_df


def load_apim_audio_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load audio data from a list of wrapped packets
    NOTE: This only works because audio sensors in the list should all have the same number of data points.
    :param wrapped_packets: packets with data to load
    :return: audio sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    if len(wrapped_packets) &gt; 0:
        if wrapped_packets[0].get_sensors().get_audio() and wrapped_packets[0].get_sensors().validate_audio():
            try:
                sample_rate_hz = wrapped_packets[0].get_sensors().get_audio().get_sample_rate()
                samples_per_packet = wrapped_packets[0].get_sensors().get_audio().get_num_samples()
                timestamps = np.array(
                    [calc_evenly_sampled_timestamps(p.get_sensors().get_audio().get_first_sample_timestamp(),
                                                    p.get_sensors().get_audio().get_num_samples(), sample_rate_hz)
                     for p in wrapped_packets]).flatten()
                data_vals = np.array([p.get_sensors().get_audio().get_samples().get_values()
                                      for p in wrapped_packets]).flatten()
                df = fill_audio_gaps(timestamps, data_vals,
                                     dtu.seconds_to_microseconds(1/sample_rate_hz), samples_per_packet)

                return SensorData(
                    wrapped_packets[0].get_sensors().get_audio().get_sensor_description(),
                    df,
                    SensorType.AUDIO,
                    sample_rate_hz,
                    1 / sample_rate_hz,
                    0.0,
                    True,
                    )
            except ValueError:
                print(&#34;Data arrays do not have the same number of points.\n&#34;
                      &#34;Original error message: &#34;, ValueError)
    return None


def load_apim_compressed_audio(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load compressed audio data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: compressed audio sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    comp_audio = wrapped_packet.get_sensors().get_compressed_audio()
    if comp_audio and wrapped_packet.get_sensors().validate_compressed_audio():
        sample_rate_hz = comp_audio.get_sample_rate()
        return SensorData(
            comp_audio.get_sensor_description(),
            pd.DataFrame(
                np.transpose(
                    [
                        comp_audio.get_first_sample_timestamp(),
                        comp_audio.get_first_sample_timestamp(),
                        comp_audio.get_audio_bytes(),
                        comp_audio.get_audio_codec(),
                    ]
                ),
                columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;compressed_audio&#34;, &#34;audio_codec&#34;],
            ),
            SensorType.COMPRESSED_AUDIO,
            sample_rate_hz,
            1 / sample_rate_hz,
            0.0,
            True,
            )
    return None


def load_apim_compressed_audio_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load compressed audio data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: compressed audio sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], []]
    for packet in wrapped_packets:
        comp_audio = packet.get_sensors().get_compressed_audio()
        if comp_audio and packet.get_sensors().validate_compressed_audio():
            data_df[0].append(comp_audio.get_first_sample_timestamp())
            data_df[1].append(comp_audio.get_audio_bytes())
            data_df[2].append(comp_audio.get_audio_codec())
    if len(data_df[0]) &gt; 0:
        sample_rate_hz = wrapped_packets[0].get_sensors().get_compressed_audio().get_sample_rate()
        return SensorData(
            wrapped_packets[0].get_sensors().get_compressed_audio().get_sensor_description(),
            pd.DataFrame(
                np.transpose([data_df[0], data_df[0], data_df[1], data_df[2]]),
                columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;compressed_audio&#34;, &#34;audio_codec&#34;],
            ),
            SensorType.COMPRESSED_AUDIO,
            sample_rate_hz,
            1 / sample_rate_hz,
            0.0,
            True,
            )
    return None


def load_apim_image(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load image data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: image sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    image = wrapped_packet.get_sensors().get_image()
    if image and wrapped_packet.get_sensors().validate_image():
        timestamps = image.get_timestamps().get_timestamps()
        codecs = np.full(len(timestamps), image.get_image_codec().value)
        data_df = pd.DataFrame(
            np.transpose([timestamps, timestamps, image.get_samples(), codecs]),
            columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;image&#34;, &#34;image_codec&#34;],
        )
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            image.get_sensor_description(),
            data_df,
            SensorType.IMAGE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )
    return None


def load_apim_image_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load image data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: image sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_list = [[], [], []]
    for packet in wrapped_packets:
        image = packet.get_sensors().get_image()
        if image and packet.get_sensors().validate_image():
            data_list[0].append(image.get_timestamps().get_timestamps())
            data_list[1].append(image.get_samples())
            data_list[2].append(np.full(len(data_list[0]), image.get_image_codec().value))
    if len(data_list[0]) &gt; 0:
        data_df = pd.DataFrame(
            np.transpose([data_list[0], data_list[0], data_list[1], data_list[2]]),
            columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;image&#34;, &#34;image_codec&#34;],
        )
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            wrapped_packets[0].get_sensors().get_image().get_sensor_description(),
            data_df,
            SensorType.IMAGE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )
    return None


def load_apim_location(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load location data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: location sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    loc = wrapped_packet.get_sensors().get_location()
    if loc and wrapped_packet.get_sensors().validate_location():
        if loc.is_only_best_values():
            if loc.get_last_best_location():
                best_loc = loc.get_last_best_location()
            else:
                best_loc = loc.get_overall_best_location()
            data_for_df = [
                [
                    best_loc.get_latitude_longitude_timestamp().get_mach(),
                    best_loc.get_latitude_longitude_timestamp().get_mach(),
                    best_loc.get_latitude(),
                    best_loc.get_longitude(),
                    best_loc.get_altitude(),
                    best_loc.get_speed(),
                    best_loc.get_bearing(),
                    best_loc.get_horizontal_accuracy(),
                    best_loc.get_vertical_accuracy(),
                    best_loc.get_speed_accuracy(),
                    best_loc.get_bearing_accuracy(),
                    best_loc.get_location_provider(),
                ]
            ]
        else:
            timestamps = loc.get_timestamps().get_timestamps()
            if len(timestamps) &gt; 0:
                lat_samples = loc.get_latitude_samples().get_values()
                lon_samples = loc.get_longitude_samples().get_values()
                alt_samples = loc.get_altitude_samples().get_values()
                spd_samples = loc.get_speed_samples().get_values()
                bear_samples = loc.get_bearing_samples().get_values()
                hor_acc_samples = loc.get_horizontal_accuracy_samples().get_values()
                vert_acc_samples = loc.get_vertical_accuracy_samples().get_values()
                spd_acc_samples = loc.get_speed_accuracy_samples().get_values()
                bear_acc_samples = loc.get_bearing_accuracy_samples().get_values()
                loc_prov_samples = loc.get_location_providers().get_values()
                data_for_df = []
                for i in range(len(timestamps)):
                    new_entry = [
                        timestamps[i],
                        timestamps[i],
                        lat_samples[i],
                        lon_samples[i],
                        np.nan if len(alt_samples) &lt; i + 1 else alt_samples[i],
                        np.nan if len(spd_samples) &lt; i + 1 else spd_samples[i],
                        np.nan if len(bear_samples) &lt; i + 1 else bear_samples[i],
                        np.nan if len(hor_acc_samples) &lt; i + 1 else hor_acc_samples[i],
                        np.nan if len(vert_acc_samples) &lt; i + 1 else vert_acc_samples[i],
                        np.nan if len(spd_acc_samples) &lt; i + 1 else spd_acc_samples[i],
                        np.nan if len(bear_acc_samples) &lt; i + 1 else bear_acc_samples[i],
                        np.nan if len(loc_prov_samples) &lt; i + 1 else loc_prov_samples[i],
                    ]
                    data_for_df.append(new_entry)
            else:
                return None
        data_df = pd.DataFrame(
            data_for_df,
            columns=[
                &#34;timestamps&#34;,
                &#34;unaltered_timestamps&#34;,
                &#34;latitude&#34;,
                &#34;longitude&#34;,
                &#34;altitude&#34;,
                &#34;speed&#34;,
                &#34;bearing&#34;,
                &#34;horizontal_accuracy&#34;,
                &#34;vertical_accuracy&#34;,
                &#34;speed_accuracy&#34;,
                &#34;bearing_accuracy&#34;,
                &#34;location_provider&#34;,
            ],
        )
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            loc.get_sensor_description(),
            data_df,
            SensorType.LOCATION,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )
    return None


def load_apim_location_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load location data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: location sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_for_df = [[], [], [], [], [], [], [], [], [], [], []]
    for packet in wrapped_packets:
        loc = packet.get_sensors().get_location()
        if loc and packet.get_sensors().validate_location():
            if loc.is_only_best_values():
                if loc.get_last_best_location():
                    best_loc = loc.get_last_best_location()
                else:
                    best_loc = loc.get_overall_best_location()
                data_for_df[0].append(best_loc.get_latitude_longitude_timestamp().get_mach())
                data_for_df[1].append(best_loc.get_latitude())
                data_for_df[2].append(best_loc.get_longitude())
                data_for_df[3].append(best_loc.get_altitude())
                data_for_df[4].append(best_loc.get_speed())
                data_for_df[5].append(best_loc.get_bearing())
                data_for_df[6].append(best_loc.get_horizontal_accuracy())
                data_for_df[7].append(best_loc.get_vertical_accuracy())
                data_for_df[8].append(best_loc.get_speed_accuracy())
                data_for_df[9].append(best_loc.get_bearing_accuracy())
                data_for_df[10].append(best_loc.get_location_provider())
            else:
                timestamps = loc.get_timestamps().get_timestamps()
                if len(timestamps) &gt; 0:
                    data_for_df[0].extend(timestamps)
                    data_for_df[1].extend(loc.get_latitude_samples().get_values())
                    data_for_df[2].extend(loc.get_longitude_samples().get_values())
                    alt_samples = loc.get_altitude_samples().get_values()
                    if len(alt_samples) &lt;= 0:
                        alt_samples = np.full(len(timestamps), np.nan)
                    data_for_df[3].extend(alt_samples)
                    spd_samples = loc.get_speed_samples().get_values()
                    if len(spd_samples) &lt;= 0:
                        spd_samples = np.full(len(timestamps), np.nan)
                    data_for_df[4].extend(spd_samples)
                    bear_samples = loc.get_bearing_samples().get_values()
                    if len(bear_samples) &lt;= 0:
                        bear_samples = np.full(len(timestamps), np.nan)
                    data_for_df[5].extend(bear_samples)
                    hor_acc_samples = loc.get_horizontal_accuracy_samples().get_values()
                    if len(hor_acc_samples) &lt;= 0:
                        hor_acc_samples = np.full(len(timestamps), np.nan)
                    data_for_df[6].extend(hor_acc_samples)
                    vert_acc_samples = loc.get_vertical_accuracy_samples().get_values()
                    if len(vert_acc_samples) &lt;= 0:
                        vert_acc_samples = np.full(len(timestamps), np.nan)
                    data_for_df[7].extend(vert_acc_samples)
                    spd_acc_samples = loc.get_speed_accuracy_samples().get_values()
                    if len(spd_acc_samples) &lt;= 0:
                        spd_acc_samples = np.full(len(timestamps), np.nan)
                    data_for_df[8].extend(spd_acc_samples)
                    bear_acc_samples = loc.get_bearing_accuracy_samples().get_values()
                    if len(bear_acc_samples) &lt;= 0:
                        bear_acc_samples = np.full(len(timestamps), np.nan)
                    data_for_df[9].extend(bear_acc_samples)
                    loc_prov_samples = loc.get_location_providers().get_values()
                    if len(loc_prov_samples) &lt;= len(timestamps):
                        loc_prov_samples = np.full(len(timestamps), loc_prov_samples[0])
                    data_for_df[10].extend(loc_prov_samples)
    if len(data_for_df[0]) &gt; 0:
        data_for_df.insert(1, data_for_df[0].copy())
        return SensorData(
            wrapped_packets[0].get_sensors().get_location().get_sensor_description(),
            pd.DataFrame(np.transpose(data_for_df), columns=[
                &#34;timestamps&#34;,
                &#34;unaltered_timestamps&#34;,
                &#34;latitude&#34;,
                &#34;longitude&#34;,
                &#34;altitude&#34;,
                &#34;speed&#34;,
                &#34;bearing&#34;,
                &#34;horizontal_accuracy&#34;,
                &#34;vertical_accuracy&#34;,
                &#34;speed_accuracy&#34;,
                &#34;bearing_accuracy&#34;,
                &#34;location_provider&#34;,
            ]),
            SensorType.LOCATION,
            calculate_stats=True
        )
    return None


def load_apim_pressure(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load pressure data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: pressure sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    pressure = wrapped_packet.get_sensors().get_pressure()
    if pressure and wrapped_packet.get_sensors().validate_pressure():
        data_df = read_apim_single_sensor(pressure, &#34;pressure&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            pressure.get_sensor_description(),
            data_df,
            SensorType.PRESSURE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_pressure_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load pressure data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: pressure sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        pressure = packet.get_sensors().get_pressure()
        if pressure and packet.get_sensors().validate_pressure():
            data_df.extend(pressure.get_samples().get_values())
            timestamps.extend(pressure.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_pressure().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;pressure&#34;]),
            SensorType.PRESSURE,
            calculate_stats=True
        )
    return None


def load_apim_light(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load light data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: light sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    light = wrapped_packet.get_sensors().get_light()
    if light and wrapped_packet.get_sensors().validate_light():
        data_df = read_apim_single_sensor(light, &#34;light&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            light.get_sensor_description(),
            data_df,
            SensorType.LIGHT,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_light_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load light data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: light sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        light = packet.get_sensors().get_light()
        if light and packet.get_sensors().validate_light():
            data_df.extend(light.get_samples().get_values())
            timestamps.extend(light.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_light().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;light&#34;]),
            SensorType.LIGHT,
            calculate_stats=True
        )
    return None


def load_apim_proximity(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load proximity data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: proximity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    proximity = wrapped_packet.get_sensors().get_proximity()
    if proximity and wrapped_packet.get_sensors().validate_proximity():
        data_df = read_apim_single_sensor(proximity, &#34;proximity&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            proximity.get_sensor_description(),
            data_df,
            SensorType.PROXIMITY,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_proximity_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load proximity data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: proximity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        proximity = packet.get_sensors().get_proximity()
        if proximity and packet.get_sensors().validate_proximity():
            data_df.extend(proximity.get_samples().get_values())
            timestamps.extend(proximity.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_proximity().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;proximity&#34;]),
            SensorType.PROXIMITY,
            calculate_stats=True
        )
    return None


def load_apim_ambient_temp(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load ambient temperature data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: ambient temperature sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    ambient_temp = wrapped_packet.get_sensors().get_ambient_temperature()
    if ambient_temp and wrapped_packet.get_sensors().validate_ambient_temperature():
        data_df = read_apim_single_sensor(ambient_temp, &#34;ambient_temp&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            ambient_temp.get_sensor_description(),
            data_df,
            SensorType.AMBIENT_TEMPERATURE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_ambient_temp_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load ambient temperature data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: ambient temperature sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        amb_temp = packet.get_sensors().get_ambient_temperature()
        if amb_temp and packet.get_sensors().validate_ambient_temperature():
            data_df.extend(amb_temp.get_samples().get_values())
            timestamps.extend(amb_temp.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_ambient_temperature().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;ambient_temp&#34;]),
            SensorType.AMBIENT_TEMPERATURE,
            calculate_stats=True
        )
    return None


def load_apim_rel_humidity(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load relative humidity data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: relative humidity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    rel_humidity = wrapped_packet.get_sensors().get_relative_humidity()
    if rel_humidity and wrapped_packet.get_sensors().validate_relative_humidity():
        data_df = read_apim_single_sensor(rel_humidity, &#34;rel_humidity&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            rel_humidity.get_sensor_description(),
            data_df,
            SensorType.RELATIVE_HUMIDITY,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_rel_humidity_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load relative humidity data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: relative humidity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        rel_hum = packet.get_sensors().get_relative_humidity()
        if rel_hum and packet.get_sensors().validate_relative_humidity():
            data_df.extend(rel_hum.get_samples().get_values())
            timestamps.extend(rel_hum.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_relative_humidity().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;rel_humidity&#34;]),
            SensorType.RELATIVE_HUMIDITY,
            calculate_stats=True
        )
    return None


def load_apim_accelerometer(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load accelerometer data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: accelerometer sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    accel = wrapped_packet.get_sensors().get_accelerometer()
    if accel and wrapped_packet.get_sensors().validate_accelerometer():
        data_df = read_apim_xyz_sensor(accel, &#34;accelerometer&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            accel.get_sensor_description(),
            data_df,
            SensorType.ACCELEROMETER,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_accelerometer_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load accelerometer data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: accelerometer sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        accel = packet.get_sensors().get_accelerometer()
        if accel and packet.get_sensors().validate_accelerometer():
            data_df[0].extend(accel.get_timestamps().get_timestamps())
            data_df[1].extend(accel.get_x_samples().get_values())
            data_df[2].extend(accel.get_y_samples().get_values())
            data_df[3].extend(accel.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.ACCELEROMETER, data_df, &#34;accelerometer&#34;,
                                    wrapped_packets[0].get_sensors().get_accelerometer().get_sensor_description())
    return None


def load_apim_magnetometer(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load magnetometer data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: magnetometer sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    mag = wrapped_packet.get_sensors().get_magnetometer()
    if mag and wrapped_packet.get_sensors().validate_magnetometer():
        data_df = read_apim_xyz_sensor(mag, &#34;magnetometer&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            mag.get_sensor_description(),
            data_df,
            SensorType.MAGNETOMETER,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_magnetometer_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load magnetometer data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: magnetometer sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        mag = packet.get_sensors().get_magnetometer()
        if mag and packet.get_sensors().validate_magnetometer():
            data_df[0].extend(mag.get_timestamps().get_timestamps())
            data_df[1].extend(mag.get_x_samples().get_values())
            data_df[2].extend(mag.get_y_samples().get_values())
            data_df[3].extend(mag.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.MAGNETOMETER, data_df, &#34;magnetometer&#34;,
                                    wrapped_packets[0].get_sensors().get_magnetometer().get_sensor_description())
    return None


def load_apim_gyroscope(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load gyroscope data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: gyroscope sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    gyro = wrapped_packet.get_sensors().get_gyroscope()
    if gyro and wrapped_packet.get_sensors().validate_gyroscope():
        data_df = read_apim_xyz_sensor(gyro, &#34;gyroscope&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            gyro.get_sensor_description(),
            data_df,
            SensorType.GYROSCOPE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_gyroscope_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load gyroscope data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: gyroscope sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        gyro = packet.get_sensors().get_gyroscope()
        if gyro and packet.get_sensors().validate_gyroscope():
            data_df[0].extend(gyro.get_timestamps().get_timestamps())
            data_df[1].extend(gyro.get_x_samples().get_values())
            data_df[2].extend(gyro.get_y_samples().get_values())
            data_df[3].extend(gyro.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.GYROSCOPE, data_df, &#34;gyroscope&#34;,
                                    wrapped_packets[0].get_sensors().get_gyroscope().get_sensor_description())
    return None


def load_apim_gravity(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load gravity data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: gravity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    gravity = wrapped_packet.get_sensors().get_gravity()
    if gravity and wrapped_packet.get_sensors().validate_gravity():
        data_df = read_apim_xyz_sensor(gravity, &#34;gravity&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            gravity.get_sensor_description(),
            data_df,
            SensorType.GRAVITY,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_gravity_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load gravity data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: gravity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        gravity = packet.get_sensors().get_gravity()
        if gravity and packet.get_sensors().validate_gravity():
            data_df[0].extend(gravity.get_timestamps().get_timestamps())
            data_df[1].extend(gravity.get_x_samples().get_values())
            data_df[2].extend(gravity.get_y_samples().get_values())
            data_df[3].extend(gravity.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.GRAVITY, data_df, &#34;gravity&#34;,
                                    wrapped_packets[0].get_sensors().get_gravity().get_sensor_description())
    return None


def load_apim_orientation(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load orientation data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: orientation sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    orientation = wrapped_packet.get_sensors().get_orientation()
    if orientation and wrapped_packet.get_sensors().validate_orientation():
        data_df = read_apim_xyz_sensor(orientation, &#34;orientation&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            orientation.get_sensor_description(),
            data_df,
            SensorType.ORIENTATION,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_orientation_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load orientation data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: orientation sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        orient = packet.get_sensors().get_orientation()
        if orient and packet.get_sensors().validate_orientation():
            data_df[0].extend(orient.get_timestamps().get_timestamps())
            data_df[1].extend(orient.get_x_samples().get_values())
            data_df[2].extend(orient.get_y_samples().get_values())
            data_df[3].extend(orient.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.ORIENTATION, data_df, &#34;orientation&#34;,
                                    wrapped_packets[0].get_sensors().get_orientation().get_sensor_description())
    return None


def load_apim_linear_accel(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load linear acceleration data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: linear acceleration sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    linear_accel = wrapped_packet.get_sensors().get_linear_acceleration()
    if linear_accel and wrapped_packet.get_sensors().validate_linear_acceleration():
        data_df = read_apim_xyz_sensor(linear_accel, &#34;linear_accel&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            linear_accel.get_sensor_description(),
            data_df,
            SensorType.LINEAR_ACCELERATION,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_linear_accel_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load linear acceleration data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: linear acceleration sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        lin_acc = packet.get_sensors().get_linear_acceleration()
        if lin_acc and packet.get_sensors().validate_linear_acceleration():
            data_df[0].extend(lin_acc.get_timestamps().get_timestamps())
            data_df[1].extend(lin_acc.get_x_samples().get_values())
            data_df[2].extend(lin_acc.get_y_samples().get_values())
            data_df[3].extend(lin_acc.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.LINEAR_ACCELERATION, data_df, &#34;linear_accel&#34;,
                                    wrapped_packets[0].get_sensors().get_linear_acceleration().get_sensor_description())
    return None


def load_apim_rotation_vector(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load rotation vector data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: rotation vector sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    rotation = wrapped_packet.get_sensors().get_rotation_vector()
    if rotation and wrapped_packet.get_sensors().validate_rotation_vector():
        data_df = read_apim_xyz_sensor(rotation, &#34;rotation_vector&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            rotation.get_sensor_description(),
            data_df,
            SensorType.ROTATION_VECTOR,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )


def load_apim_rotation_vector_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load rotation vector data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: rotation vector sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        rot_vec = packet.get_sensors().get_rotation_vector()
        if rot_vec and packet.get_sensors().validate_rotation_vector():
            data_df[0].extend(rot_vec.get_timestamps().get_timestamps())
            data_df[1].extend(rot_vec.get_x_samples().get_values())
            data_df[2].extend(rot_vec.get_y_samples().get_values())
            data_df[3].extend(rot_vec.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.ROTATION_VECTOR, data_df, &#34;rotation_vector&#34;,
                                    wrapped_packets[0].get_sensors().get_rotation_vector().get_sensor_description())
    return None


def load_apim_health(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load station health data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: station health data if it exists, None otherwise
    &#34;&#34;&#34;
    metrics = wrapped_packet.get_station_information().get_station_metrics()
    timestamps = metrics.get_timestamps().get_timestamps()
    if len(timestamps) &gt; 0:
        bat_samples = metrics.get_battery().get_values()
        bat_cur_samples = metrics.get_battery_current().get_values()
        temp_samples = metrics.get_temperature().get_values()
        net_samples = metrics.get_network_type().get_values()
        net_str_samples = metrics.get_network_strength().get_values()
        pow_samples = metrics.get_power_state().get_values()
        avail_ram_samples = metrics.get_available_ram().get_values()
        avail_disk_samples = metrics.get_available_disk().get_values()
        cell_samples = metrics.get_cell_service_state().get_values()
        data_for_df = []
        for i in range(len(timestamps)):
            new_entry = [
                timestamps[i],
                timestamps[i],
                np.nan if len(bat_samples) &lt; i + 1 else bat_samples[i],
                np.nan if len(bat_cur_samples) &lt; i + 1 else bat_cur_samples[i],
                np.nan if len(temp_samples) &lt; i + 1 else temp_samples[i],
                np.nan if len(net_samples) &lt; i + 1 else net_samples[i],
                np.nan if len(net_str_samples) &lt; i + 1 else net_str_samples[i],
                np.nan if len(pow_samples) &lt; i + 1 else pow_samples[i],
                np.nan if len(avail_ram_samples) &lt; i + 1 else avail_ram_samples[i],
                np.nan if len(avail_disk_samples) &lt; i + 1 else avail_disk_samples[i],
                np.nan if len(cell_samples) &lt; i + 1 else cell_samples[i],
            ]
            data_for_df.append(new_entry)
        data_df = pd.DataFrame(
            data_for_df,
            columns=[
                &#34;timestamps&#34;,
                &#34;unaltered_timestamps&#34;,
                &#34;battery_charge_remaining&#34;,
                &#34;battery_current_strength&#34;,
                &#34;internal_temp_c&#34;,
                &#34;network_type&#34;,
                &#34;network_strength&#34;,
                &#34;power_state&#34;,
                &#34;avail_ram&#34;,
                &#34;avail_disk&#34;,
                &#34;cell_service&#34;,
            ],
        )
        sample_rate = len(data_for_df) / wrapped_packet.get_packet_duration().total_seconds()
        return SensorData(
            &#34;station health&#34;,
            data_df,
            SensorType.STATION_HEALTH,
            sample_rate,
            1 / sample_rate,
            np.nan if len(data_for_df) &lt;= 1
            else dtu.microseconds_to_seconds(float(np.std(np.diff(data_df[&#34;timestamps&#34;])))),
            False,
            )
    return None


def load_apim_health_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load station health data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: station health sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_for_df = [[], [], [], [], [], [], [], [], [], []]
    for packet in wrapped_packets:
        metrics = packet.get_station_information().get_station_metrics()
        timestamps = metrics.get_timestamps().get_timestamps()
        if len(timestamps) &gt; 0:
            data_for_df[0].extend(timestamps)
            bat_samples = metrics.get_battery().get_values()
            if len(bat_samples) &lt;= 0:
                bat_samples = np.full(len(timestamps), np.nan)
            data_for_df[1].extend(bat_samples)
            bat_cur_samples = metrics.get_battery_current().get_values()
            if len(bat_cur_samples) &lt;= 0:
                bat_cur_samples = np.full(len(timestamps), np.nan)
            data_for_df[2].extend(bat_cur_samples)
            temp_samples = metrics.get_temperature().get_values()
            if len(temp_samples) &lt;= 0:
                temp_samples = np.full(len(timestamps), np.nan)
            data_for_df[3].extend(temp_samples)
            net_samples = metrics.get_network_type().get_values()
            if len(net_samples) &lt;= 0:
                net_samples = np.full(len(timestamps), np.nan)
            data_for_df[4].extend(net_samples)
            net_str_samples = metrics.get_network_strength().get_values()
            if len(net_str_samples) &lt;= 0:
                net_str_samples = np.full(len(timestamps), np.nan)
            data_for_df[5].extend(net_str_samples)
            pow_samples = metrics.get_power_state().get_values()
            if len(pow_samples) &lt;= 0:
                pow_samples = np.full(len(timestamps), np.nan)
            data_for_df[6].extend(pow_samples)
            avail_ram_samples = metrics.get_available_ram().get_values()
            if len(avail_ram_samples) &lt;= 0:
                avail_ram_samples = np.full(len(timestamps), np.nan)
            data_for_df[7].extend(avail_ram_samples)
            avail_disk_samples = metrics.get_available_disk().get_values()
            if len(avail_disk_samples) &lt;= 0:
                avail_disk_samples = np.full(len(timestamps), np.nan)
            data_for_df[8].extend(avail_disk_samples)
            cell_samples = metrics.get_cell_service_state().get_values()
            if len(cell_samples) &lt;= 0:
                cell_samples = np.full(len(timestamps), np.nan)
            data_for_df[9].extend(cell_samples)
    if len(data_for_df[0]) &gt; 0:
        data_for_df.insert(1, data_for_df[0].copy())
        return SensorData(
            &#34;station health&#34;,
            pd.DataFrame(
                np.transpose(data_for_df),
                columns=[
                    &#34;timestamps&#34;,
                    &#34;unaltered_timestamps&#34;,
                    &#34;battery_charge_remaining&#34;,
                    &#34;battery_current_strength&#34;,
                    &#34;internal_temp_c&#34;,
                    &#34;network_type&#34;,
                    &#34;network_strength&#34;,
                    &#34;power_state&#34;,
                    &#34;avail_ram&#34;,
                    &#34;avail_disk&#34;,
                    &#34;cell_service&#34;,
                ],
            ),
            SensorType.STATION_HEALTH,
            calculate_stats=True
        )
    return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.common.sensor_reader_utils.add_dataless_timestamps_to_df"><code class="name flex">
<span>def <span class="ident">add_dataless_timestamps_to_df</span></span>(<span>dataframe: pandas.core.frame.DataFrame, start_index: int, sample_interval_micros: float, num_samples_to_add: int, add_to_start: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>adds dataless timestamps directly to a dataframe that already contains data
Note:
dataframe must not be empty,
start_index must be non-negative and less than the length of dataframe,
num_samples_to_add must be greater than 0
:param dataframe: dataframe to add dataless timestamps to
:param start_index: index of the dataframe to use as starting point for creating new values
:param sample_interval_micros: sample interval in microseconds of the timestamps
:param num_samples_to_add: the number of timestamps to create
:param add_to_start: if True, subtracts sample_interval_micros from start_timestamp, default False
:return: updated dataframe with synthetic data points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dataless_timestamps_to_df(dataframe: pd.DataFrame,
                                  start_index: int,
                                  sample_interval_micros: float,
                                  num_samples_to_add: int,
                                  add_to_start: bool = False,) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    adds dataless timestamps directly to a dataframe that already contains data
    Note:   dataframe must not be empty,
            start_index must be non-negative and less than the length of dataframe,
            num_samples_to_add must be greater than 0
    :param dataframe: dataframe to add dataless timestamps to
    :param start_index: index of the dataframe to use as starting point for creating new values
    :param sample_interval_micros: sample interval in microseconds of the timestamps
    :param num_samples_to_add: the number of timestamps to create
    :param add_to_start: if True, subtracts sample_interval_micros from start_timestamp, default False
    :return: updated dataframe with synthetic data points
    &#34;&#34;&#34;
    if len(dataframe) &gt; start_index and len(dataframe) &gt; 0 and num_samples_to_add &gt; 0:
        start_timestamp = dataframe[&#34;timestamps&#34;][start_index]
        dataframe = dataframe.append(
            create_dataless_timestamps_df(start_timestamp, sample_interval_micros,
                                          dataframe.columns, num_samples_to_add, add_to_start),
            ignore_index=True)
    return dataframe</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.calc_evenly_sampled_timestamps"><code class="name flex">
<span>def <span class="ident">calc_evenly_sampled_timestamps</span></span>(<span>start: float, samples: int, rate_hz: float) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>given a start time, calculates samples amount of evenly spaced timestamps at rate_hz
:param start: float, start timestamp in microseconds
:param samples: int, number of samples
:param rate_hz: float, sample rate in hz
:return: np.array with evenly spaced timestamps starting at start</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_evenly_sampled_timestamps(
        start: float, samples: int, rate_hz: float
) -&gt; np.array:
    &#34;&#34;&#34;
    given a start time, calculates samples amount of evenly spaced timestamps at rate_hz
    :param start: float, start timestamp in microseconds
    :param samples: int, number of samples
    :param rate_hz: float, sample rate in hz
    :return: np.array with evenly spaced timestamps starting at start
    &#34;&#34;&#34;
    return start + (np.arange(0, samples) / rate_hz) * dtu.MICROSECONDS_IN_SECOND</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.create_dataless_timestamps_df"><code class="name flex">
<span>def <span class="ident">create_dataless_timestamps_df</span></span>(<span>start_timestamp: float, sample_interval_micros: float, columns: pandas.core.indexes.base.Index, num_samples_to_add: int, add_to_start: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an empty dataframe with num_samples_to_add timestamps, using columns as the columns
the first timestamp created is 1 sample_interval_s from the start_timestamp
:param start_timestamp: timestamp in microseconds since epoch UTC to start calculating other timestamps from
:param sample_interval_micros: fixed sample interval in microseconds since epoch UTC
:param columns: dataframe the non-timestamp columns of the dataframe
:param num_samples_to_add: the number of timestamps to create
:param add_to_start: if True, subtracts sample_interval_s from start_timestamp, default False
:return: dataframe with timestamps and no data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_dataless_timestamps_df(
        start_timestamp: float,
        sample_interval_micros: float,
        columns: pd.Index,
        num_samples_to_add: int,
        add_to_start: bool = False,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Creates an empty dataframe with num_samples_to_add timestamps, using columns as the columns
    the first timestamp created is 1 sample_interval_s from the start_timestamp
    :param start_timestamp: timestamp in microseconds since epoch UTC to start calculating other timestamps from
    :param sample_interval_micros: fixed sample interval in microseconds since epoch UTC
    :param columns: dataframe the non-timestamp columns of the dataframe
    :param num_samples_to_add: the number of timestamps to create
    :param add_to_start: if True, subtracts sample_interval_s from start_timestamp, default False
    :return: dataframe with timestamps and no data
    &#34;&#34;&#34;
    empty_df = pd.DataFrame([], columns=columns)
    if num_samples_to_add &gt; 0:
        for column_index in columns:
            if column_index == &#34;timestamps&#34;:
                if add_to_start:
                    sample_interval_micros = -sample_interval_micros
                empty_df[column_index] = (
                        start_timestamp + np.arange(1, num_samples_to_add + 1) * sample_interval_micros
                )
            elif column_index == &#34;location_provider&#34;:
                empty_df[column_index] = LocationProvider.UNKNOWN
            elif column_index == &#34;image_codec&#34;:
                empty_df[column_index] = ImageCodec.UNKNOWN
            elif column_index == &#34;audio_codec&#34;:
                empty_df[column_index] = AudioCodec.UNKNOWN
            elif column_index == &#34;network_type&#34;:
                empty_df[column_index] = NetworkType.UNKNOWN_NETWORK
            elif column_index == &#34;power_state&#34;:
                empty_df[column_index] = PowerState.UNKNOWN_POWER_STATE
            elif column_index == &#34;cell_service&#34;:
                empty_df[column_index] = CellServiceState.UNKNOWN
            else:
                empty_df[column_index] = np.nan
    return empty_df</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.fill_audio_gaps"><code class="name flex">
<span>def <span class="ident">fill_audio_gaps</span></span>(<span>timestamps: <built-in function array>, audio_data: <built-in function array>, sample_interval_micros: float, samples_per_packet: int) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>fills gaps in the dataframe with np.nan by interpolating timestamps based on the mean expected sample interval
:param timestamps: array of timestamps for the data
:param audio_data: array of data points
:param sample_interval_micros: sample interval in microseconds
:param samples_per_packet: number of samples to create per packet
:return: dataframe without gaps</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_audio_gaps(
        timestamps: np.array,
        audio_data: np.array,
        sample_interval_micros: float,
        samples_per_packet: int,
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    fills gaps in the dataframe with np.nan by interpolating timestamps based on the mean expected sample interval
    :param timestamps: array of timestamps for the data
    :param audio_data: array of data points
    :param sample_interval_micros: sample interval in microseconds
    :param samples_per_packet: number of samples to create per packet
    :return: dataframe without gaps
    &#34;&#34;&#34;
    PERCENT_PACKET_CONFIRM = .9
    PERCENT_NOT_PACKET_CONFIRM = .02
    result_df = pd.DataFrame(np.transpose([timestamps, timestamps, audio_data]),
                             columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;microphone&#34;])
    num_points = len(timestamps)
    # if there are less points than our expected amount, we have gaps to fill
    if num_points &lt; 10000:
        # look at every timestamp difference
        timestamp_diffs = np.diff(timestamps)
        for index in np.where(timestamp_diffs &gt; sample_interval_micros)[0]:
            num_samples = timestamp_diffs[index] / sample_interval_micros
            if num_samples &lt;= samples_per_packet * PERCENT_NOT_PACKET_CONFIRM:
                break  # difference too small, no gap
            elif num_samples &gt;= samples_per_packet * PERCENT_PACKET_CONFIRM:
                # add samples per packet for each packet missing
                num_samples = samples_per_packet * np.floor(num_samples / (samples_per_packet * PERCENT_PACKET_CONFIRM))
            # add the gap data to the result dataframe
            result_df = add_dataless_timestamps_to_df(
                result_df,
                index,
                sample_interval_micros,
                num_samples,
            )
    else:
        # too many points to check, divide and conquer using recursion!
        half_samples = int(num_points / 2)
        first_data_timestamps = timestamps[:half_samples]
        first_audio_data = audio_data[:half_samples]
        second_data_timestamps = timestamps[half_samples:]
        second_audio_data = audio_data[half_samples:]
        # give half the samples to each recursive call
        first_data_timestamps = fill_audio_gaps(
            first_data_timestamps,
            first_audio_data,
            sample_interval_micros,
            samples_per_packet,
        )
        second_data_timestamps = fill_audio_gaps(
            second_data_timestamps,
            second_audio_data,
            sample_interval_micros,
            samples_per_packet,
        )
        result_df = first_data_timestamps.append(second_data_timestamps, ignore_index=True)
        mid_timestamps = timestamps[half_samples-1:half_samples+1]
        mid_audio_data = audio_data[half_samples-1:half_samples+1]
        mid_df = fill_audio_gaps(mid_timestamps, mid_audio_data, sample_interval_micros, samples_per_packet)
        if len(mid_df[&#34;timestamps&#34;]) &gt; 2:
            mid_df = mid_df.iloc[1:len(mid_df[&#34;timestamps&#34;])-1]
            result_df = result_df.append(mid_df, ignore_index=True)
    return result_df.sort_values(&#34;timestamps&#34;, ignore_index=True)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.get_empty_sensor_data"><code class="name flex">
<span>def <span class="ident">get_empty_sensor_data</span></span>(<span>name: str, sensor_type: <a title="redvox.common.sensor_data.SensorType" href="sensor_data.html#redvox.common.sensor_data.SensorType">SensorType</a> = SensorType.UNKNOWN_SENSOR) ‑> <a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a sensor data object with no data
:param name: name of the sensor
:param sensor_type: type of the sensor to create, default SensorType.UNKNOWN_SENSOR
:return: empty sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_empty_sensor_data(
        name: str, sensor_type: SensorType = SensorType.UNKNOWN_SENSOR
) -&gt; SensorData:
    &#34;&#34;&#34;
    create a sensor data object with no data
    :param name: name of the sensor
    :param sensor_type: type of the sensor to create, default SensorType.UNKNOWN_SENSOR
    :return: empty sensor
    &#34;&#34;&#34;
    return SensorData(name, pd.DataFrame([], columns=[&#34;timestamps&#34;]), sensor_type)</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.get_sample_statistics"><code class="name flex">
<span>def <span class="ident">get_sample_statistics</span></span>(<span>data_df: pandas.core.frame.DataFrame) ‑> typing.Tuple[float, float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>calculate the sample rate, interval and interval std dev using the timestamps in the dataframe
:param data_df: the dataframe containing timestamps to calculate statistics from
:return: a Tuple containing the sample rate, interval and interval std dev</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sample_statistics(data_df: pd.DataFrame) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;
    calculate the sample rate, interval and interval std dev using the timestamps in the dataframe
    :param data_df: the dataframe containing timestamps to calculate statistics from
    :return: a Tuple containing the sample rate, interval and interval std dev
    &#34;&#34;&#34;
    if data_df[&#34;timestamps&#34;].size &gt; 1:
        sample_interval = dtu.microseconds_to_seconds(
            float(np.mean(np.diff(data_df[&#34;timestamps&#34;])))
        )
        sample_interval_std = dtu.microseconds_to_seconds(
            float(np.std(np.diff(data_df[&#34;timestamps&#34;])))
        )
    else:
        sample_interval = np.nan
        sample_interval_std = np.nan
    return 1 / sample_interval, sample_interval, sample_interval_std</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_accelerometer"><code class="name flex">
<span>def <span class="ident">load_apim_accelerometer</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load accelerometer data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: accelerometer sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_accelerometer(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load accelerometer data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: accelerometer sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    accel = wrapped_packet.get_sensors().get_accelerometer()
    if accel and wrapped_packet.get_sensors().validate_accelerometer():
        data_df = read_apim_xyz_sensor(accel, &#34;accelerometer&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            accel.get_sensor_description(),
            data_df,
            SensorType.ACCELEROMETER,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_accelerometer_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_accelerometer_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load accelerometer data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: accelerometer sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_accelerometer_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load accelerometer data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: accelerometer sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        accel = packet.get_sensors().get_accelerometer()
        if accel and packet.get_sensors().validate_accelerometer():
            data_df[0].extend(accel.get_timestamps().get_timestamps())
            data_df[1].extend(accel.get_x_samples().get_values())
            data_df[2].extend(accel.get_y_samples().get_values())
            data_df[3].extend(accel.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.ACCELEROMETER, data_df, &#34;accelerometer&#34;,
                                    wrapped_packets[0].get_sensors().get_accelerometer().get_sensor_description())
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_ambient_temp"><code class="name flex">
<span>def <span class="ident">load_apim_ambient_temp</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load ambient temperature data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: ambient temperature sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_ambient_temp(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load ambient temperature data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: ambient temperature sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    ambient_temp = wrapped_packet.get_sensors().get_ambient_temperature()
    if ambient_temp and wrapped_packet.get_sensors().validate_ambient_temperature():
        data_df = read_apim_single_sensor(ambient_temp, &#34;ambient_temp&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            ambient_temp.get_sensor_description(),
            data_df,
            SensorType.AMBIENT_TEMPERATURE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_ambient_temp_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_ambient_temp_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load ambient temperature data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: ambient temperature sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_ambient_temp_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load ambient temperature data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: ambient temperature sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        amb_temp = packet.get_sensors().get_ambient_temperature()
        if amb_temp and packet.get_sensors().validate_ambient_temperature():
            data_df.extend(amb_temp.get_samples().get_values())
            timestamps.extend(amb_temp.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_ambient_temperature().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;ambient_temp&#34;]),
            SensorType.AMBIENT_TEMPERATURE,
            calculate_stats=True
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_audio"><code class="name flex">
<span>def <span class="ident">load_apim_audio</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load audio data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: audio sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_audio(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load audio data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: audio sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    audio = wrapped_packet.get_sensors().get_audio()
    if audio and wrapped_packet.get_sensors().validate_audio():
        sample_rate_hz = audio.get_sample_rate()
        data_for_df = audio.get_samples().get_values()
        timestamps = calc_evenly_sampled_timestamps(
            audio.get_first_sample_timestamp(), audio.get_num_samples(), sample_rate_hz
        )
        return SensorData(
            audio.get_sensor_description(),
            pd.DataFrame(
                np.transpose([timestamps, timestamps, data_for_df]),
                columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;microphone&#34;],
            ),
            SensorType.AUDIO,
            sample_rate_hz,
            1 / sample_rate_hz,
            0.0,
            True,
            )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_audio_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_audio_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load audio data from a list of wrapped packets
NOTE: This only works because audio sensors in the list should all have the same number of data points.
:param wrapped_packets: packets with data to load
:return: audio sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_audio_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load audio data from a list of wrapped packets
    NOTE: This only works because audio sensors in the list should all have the same number of data points.
    :param wrapped_packets: packets with data to load
    :return: audio sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    if len(wrapped_packets) &gt; 0:
        if wrapped_packets[0].get_sensors().get_audio() and wrapped_packets[0].get_sensors().validate_audio():
            try:
                sample_rate_hz = wrapped_packets[0].get_sensors().get_audio().get_sample_rate()
                samples_per_packet = wrapped_packets[0].get_sensors().get_audio().get_num_samples()
                timestamps = np.array(
                    [calc_evenly_sampled_timestamps(p.get_sensors().get_audio().get_first_sample_timestamp(),
                                                    p.get_sensors().get_audio().get_num_samples(), sample_rate_hz)
                     for p in wrapped_packets]).flatten()
                data_vals = np.array([p.get_sensors().get_audio().get_samples().get_values()
                                      for p in wrapped_packets]).flatten()
                df = fill_audio_gaps(timestamps, data_vals,
                                     dtu.seconds_to_microseconds(1/sample_rate_hz), samples_per_packet)

                return SensorData(
                    wrapped_packets[0].get_sensors().get_audio().get_sensor_description(),
                    df,
                    SensorType.AUDIO,
                    sample_rate_hz,
                    1 / sample_rate_hz,
                    0.0,
                    True,
                    )
            except ValueError:
                print(&#34;Data arrays do not have the same number of points.\n&#34;
                      &#34;Original error message: &#34;, ValueError)
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_compressed_audio"><code class="name flex">
<span>def <span class="ident">load_apim_compressed_audio</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load compressed audio data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: compressed audio sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_compressed_audio(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load compressed audio data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: compressed audio sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    comp_audio = wrapped_packet.get_sensors().get_compressed_audio()
    if comp_audio and wrapped_packet.get_sensors().validate_compressed_audio():
        sample_rate_hz = comp_audio.get_sample_rate()
        return SensorData(
            comp_audio.get_sensor_description(),
            pd.DataFrame(
                np.transpose(
                    [
                        comp_audio.get_first_sample_timestamp(),
                        comp_audio.get_first_sample_timestamp(),
                        comp_audio.get_audio_bytes(),
                        comp_audio.get_audio_codec(),
                    ]
                ),
                columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;compressed_audio&#34;, &#34;audio_codec&#34;],
            ),
            SensorType.COMPRESSED_AUDIO,
            sample_rate_hz,
            1 / sample_rate_hz,
            0.0,
            True,
            )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_compressed_audio_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_compressed_audio_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load compressed audio data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: compressed audio sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_compressed_audio_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load compressed audio data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: compressed audio sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], []]
    for packet in wrapped_packets:
        comp_audio = packet.get_sensors().get_compressed_audio()
        if comp_audio and packet.get_sensors().validate_compressed_audio():
            data_df[0].append(comp_audio.get_first_sample_timestamp())
            data_df[1].append(comp_audio.get_audio_bytes())
            data_df[2].append(comp_audio.get_audio_codec())
    if len(data_df[0]) &gt; 0:
        sample_rate_hz = wrapped_packets[0].get_sensors().get_compressed_audio().get_sample_rate()
        return SensorData(
            wrapped_packets[0].get_sensors().get_compressed_audio().get_sensor_description(),
            pd.DataFrame(
                np.transpose([data_df[0], data_df[0], data_df[1], data_df[2]]),
                columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;compressed_audio&#34;, &#34;audio_codec&#34;],
            ),
            SensorType.COMPRESSED_AUDIO,
            sample_rate_hz,
            1 / sample_rate_hz,
            0.0,
            True,
            )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_gravity"><code class="name flex">
<span>def <span class="ident">load_apim_gravity</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load gravity data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: gravity sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_gravity(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load gravity data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: gravity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    gravity = wrapped_packet.get_sensors().get_gravity()
    if gravity and wrapped_packet.get_sensors().validate_gravity():
        data_df = read_apim_xyz_sensor(gravity, &#34;gravity&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            gravity.get_sensor_description(),
            data_df,
            SensorType.GRAVITY,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_gravity_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_gravity_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load gravity data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: gravity sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_gravity_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load gravity data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: gravity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        gravity = packet.get_sensors().get_gravity()
        if gravity and packet.get_sensors().validate_gravity():
            data_df[0].extend(gravity.get_timestamps().get_timestamps())
            data_df[1].extend(gravity.get_x_samples().get_values())
            data_df[2].extend(gravity.get_y_samples().get_values())
            data_df[3].extend(gravity.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.GRAVITY, data_df, &#34;gravity&#34;,
                                    wrapped_packets[0].get_sensors().get_gravity().get_sensor_description())
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_gyroscope"><code class="name flex">
<span>def <span class="ident">load_apim_gyroscope</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load gyroscope data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: gyroscope sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_gyroscope(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load gyroscope data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: gyroscope sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    gyro = wrapped_packet.get_sensors().get_gyroscope()
    if gyro and wrapped_packet.get_sensors().validate_gyroscope():
        data_df = read_apim_xyz_sensor(gyro, &#34;gyroscope&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            gyro.get_sensor_description(),
            data_df,
            SensorType.GYROSCOPE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_gyroscope_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_gyroscope_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load gyroscope data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: gyroscope sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_gyroscope_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load gyroscope data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: gyroscope sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        gyro = packet.get_sensors().get_gyroscope()
        if gyro and packet.get_sensors().validate_gyroscope():
            data_df[0].extend(gyro.get_timestamps().get_timestamps())
            data_df[1].extend(gyro.get_x_samples().get_values())
            data_df[2].extend(gyro.get_y_samples().get_values())
            data_df[3].extend(gyro.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.GYROSCOPE, data_df, &#34;gyroscope&#34;,
                                    wrapped_packets[0].get_sensors().get_gyroscope().get_sensor_description())
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_health"><code class="name flex">
<span>def <span class="ident">load_apim_health</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load station health data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: station health data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_health(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load station health data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: station health data if it exists, None otherwise
    &#34;&#34;&#34;
    metrics = wrapped_packet.get_station_information().get_station_metrics()
    timestamps = metrics.get_timestamps().get_timestamps()
    if len(timestamps) &gt; 0:
        bat_samples = metrics.get_battery().get_values()
        bat_cur_samples = metrics.get_battery_current().get_values()
        temp_samples = metrics.get_temperature().get_values()
        net_samples = metrics.get_network_type().get_values()
        net_str_samples = metrics.get_network_strength().get_values()
        pow_samples = metrics.get_power_state().get_values()
        avail_ram_samples = metrics.get_available_ram().get_values()
        avail_disk_samples = metrics.get_available_disk().get_values()
        cell_samples = metrics.get_cell_service_state().get_values()
        data_for_df = []
        for i in range(len(timestamps)):
            new_entry = [
                timestamps[i],
                timestamps[i],
                np.nan if len(bat_samples) &lt; i + 1 else bat_samples[i],
                np.nan if len(bat_cur_samples) &lt; i + 1 else bat_cur_samples[i],
                np.nan if len(temp_samples) &lt; i + 1 else temp_samples[i],
                np.nan if len(net_samples) &lt; i + 1 else net_samples[i],
                np.nan if len(net_str_samples) &lt; i + 1 else net_str_samples[i],
                np.nan if len(pow_samples) &lt; i + 1 else pow_samples[i],
                np.nan if len(avail_ram_samples) &lt; i + 1 else avail_ram_samples[i],
                np.nan if len(avail_disk_samples) &lt; i + 1 else avail_disk_samples[i],
                np.nan if len(cell_samples) &lt; i + 1 else cell_samples[i],
            ]
            data_for_df.append(new_entry)
        data_df = pd.DataFrame(
            data_for_df,
            columns=[
                &#34;timestamps&#34;,
                &#34;unaltered_timestamps&#34;,
                &#34;battery_charge_remaining&#34;,
                &#34;battery_current_strength&#34;,
                &#34;internal_temp_c&#34;,
                &#34;network_type&#34;,
                &#34;network_strength&#34;,
                &#34;power_state&#34;,
                &#34;avail_ram&#34;,
                &#34;avail_disk&#34;,
                &#34;cell_service&#34;,
            ],
        )
        sample_rate = len(data_for_df) / wrapped_packet.get_packet_duration().total_seconds()
        return SensorData(
            &#34;station health&#34;,
            data_df,
            SensorType.STATION_HEALTH,
            sample_rate,
            1 / sample_rate,
            np.nan if len(data_for_df) &lt;= 1
            else dtu.microseconds_to_seconds(float(np.std(np.diff(data_df[&#34;timestamps&#34;])))),
            False,
            )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_health_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_health_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load station health data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: station health sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_health_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load station health data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: station health sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_for_df = [[], [], [], [], [], [], [], [], [], []]
    for packet in wrapped_packets:
        metrics = packet.get_station_information().get_station_metrics()
        timestamps = metrics.get_timestamps().get_timestamps()
        if len(timestamps) &gt; 0:
            data_for_df[0].extend(timestamps)
            bat_samples = metrics.get_battery().get_values()
            if len(bat_samples) &lt;= 0:
                bat_samples = np.full(len(timestamps), np.nan)
            data_for_df[1].extend(bat_samples)
            bat_cur_samples = metrics.get_battery_current().get_values()
            if len(bat_cur_samples) &lt;= 0:
                bat_cur_samples = np.full(len(timestamps), np.nan)
            data_for_df[2].extend(bat_cur_samples)
            temp_samples = metrics.get_temperature().get_values()
            if len(temp_samples) &lt;= 0:
                temp_samples = np.full(len(timestamps), np.nan)
            data_for_df[3].extend(temp_samples)
            net_samples = metrics.get_network_type().get_values()
            if len(net_samples) &lt;= 0:
                net_samples = np.full(len(timestamps), np.nan)
            data_for_df[4].extend(net_samples)
            net_str_samples = metrics.get_network_strength().get_values()
            if len(net_str_samples) &lt;= 0:
                net_str_samples = np.full(len(timestamps), np.nan)
            data_for_df[5].extend(net_str_samples)
            pow_samples = metrics.get_power_state().get_values()
            if len(pow_samples) &lt;= 0:
                pow_samples = np.full(len(timestamps), np.nan)
            data_for_df[6].extend(pow_samples)
            avail_ram_samples = metrics.get_available_ram().get_values()
            if len(avail_ram_samples) &lt;= 0:
                avail_ram_samples = np.full(len(timestamps), np.nan)
            data_for_df[7].extend(avail_ram_samples)
            avail_disk_samples = metrics.get_available_disk().get_values()
            if len(avail_disk_samples) &lt;= 0:
                avail_disk_samples = np.full(len(timestamps), np.nan)
            data_for_df[8].extend(avail_disk_samples)
            cell_samples = metrics.get_cell_service_state().get_values()
            if len(cell_samples) &lt;= 0:
                cell_samples = np.full(len(timestamps), np.nan)
            data_for_df[9].extend(cell_samples)
    if len(data_for_df[0]) &gt; 0:
        data_for_df.insert(1, data_for_df[0].copy())
        return SensorData(
            &#34;station health&#34;,
            pd.DataFrame(
                np.transpose(data_for_df),
                columns=[
                    &#34;timestamps&#34;,
                    &#34;unaltered_timestamps&#34;,
                    &#34;battery_charge_remaining&#34;,
                    &#34;battery_current_strength&#34;,
                    &#34;internal_temp_c&#34;,
                    &#34;network_type&#34;,
                    &#34;network_strength&#34;,
                    &#34;power_state&#34;,
                    &#34;avail_ram&#34;,
                    &#34;avail_disk&#34;,
                    &#34;cell_service&#34;,
                ],
            ),
            SensorType.STATION_HEALTH,
            calculate_stats=True
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_image"><code class="name flex">
<span>def <span class="ident">load_apim_image</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load image data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: image sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_image(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load image data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: image sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    image = wrapped_packet.get_sensors().get_image()
    if image and wrapped_packet.get_sensors().validate_image():
        timestamps = image.get_timestamps().get_timestamps()
        codecs = np.full(len(timestamps), image.get_image_codec().value)
        data_df = pd.DataFrame(
            np.transpose([timestamps, timestamps, image.get_samples(), codecs]),
            columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;image&#34;, &#34;image_codec&#34;],
        )
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            image.get_sensor_description(),
            data_df,
            SensorType.IMAGE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_image_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_image_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load image data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: image sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_image_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load image data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: image sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_list = [[], [], []]
    for packet in wrapped_packets:
        image = packet.get_sensors().get_image()
        if image and packet.get_sensors().validate_image():
            data_list[0].append(image.get_timestamps().get_timestamps())
            data_list[1].append(image.get_samples())
            data_list[2].append(np.full(len(data_list[0]), image.get_image_codec().value))
    if len(data_list[0]) &gt; 0:
        data_df = pd.DataFrame(
            np.transpose([data_list[0], data_list[0], data_list[1], data_list[2]]),
            columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;image&#34;, &#34;image_codec&#34;],
        )
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            wrapped_packets[0].get_sensors().get_image().get_sensor_description(),
            data_df,
            SensorType.IMAGE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_light"><code class="name flex">
<span>def <span class="ident">load_apim_light</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load light data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: light sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_light(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load light data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: light sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    light = wrapped_packet.get_sensors().get_light()
    if light and wrapped_packet.get_sensors().validate_light():
        data_df = read_apim_single_sensor(light, &#34;light&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            light.get_sensor_description(),
            data_df,
            SensorType.LIGHT,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_light_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_light_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load light data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: light sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_light_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load light data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: light sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        light = packet.get_sensors().get_light()
        if light and packet.get_sensors().validate_light():
            data_df.extend(light.get_samples().get_values())
            timestamps.extend(light.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_light().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;light&#34;]),
            SensorType.LIGHT,
            calculate_stats=True
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_linear_accel"><code class="name flex">
<span>def <span class="ident">load_apim_linear_accel</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load linear acceleration data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: linear acceleration sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_linear_accel(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load linear acceleration data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: linear acceleration sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    linear_accel = wrapped_packet.get_sensors().get_linear_acceleration()
    if linear_accel and wrapped_packet.get_sensors().validate_linear_acceleration():
        data_df = read_apim_xyz_sensor(linear_accel, &#34;linear_accel&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            linear_accel.get_sensor_description(),
            data_df,
            SensorType.LINEAR_ACCELERATION,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_linear_accel_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_linear_accel_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load linear acceleration data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: linear acceleration sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_linear_accel_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load linear acceleration data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: linear acceleration sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        lin_acc = packet.get_sensors().get_linear_acceleration()
        if lin_acc and packet.get_sensors().validate_linear_acceleration():
            data_df[0].extend(lin_acc.get_timestamps().get_timestamps())
            data_df[1].extend(lin_acc.get_x_samples().get_values())
            data_df[2].extend(lin_acc.get_y_samples().get_values())
            data_df[3].extend(lin_acc.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.LINEAR_ACCELERATION, data_df, &#34;linear_accel&#34;,
                                    wrapped_packets[0].get_sensors().get_linear_acceleration().get_sensor_description())
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_location"><code class="name flex">
<span>def <span class="ident">load_apim_location</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load location data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: location sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_location(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load location data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: location sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    loc = wrapped_packet.get_sensors().get_location()
    if loc and wrapped_packet.get_sensors().validate_location():
        if loc.is_only_best_values():
            if loc.get_last_best_location():
                best_loc = loc.get_last_best_location()
            else:
                best_loc = loc.get_overall_best_location()
            data_for_df = [
                [
                    best_loc.get_latitude_longitude_timestamp().get_mach(),
                    best_loc.get_latitude_longitude_timestamp().get_mach(),
                    best_loc.get_latitude(),
                    best_loc.get_longitude(),
                    best_loc.get_altitude(),
                    best_loc.get_speed(),
                    best_loc.get_bearing(),
                    best_loc.get_horizontal_accuracy(),
                    best_loc.get_vertical_accuracy(),
                    best_loc.get_speed_accuracy(),
                    best_loc.get_bearing_accuracy(),
                    best_loc.get_location_provider(),
                ]
            ]
        else:
            timestamps = loc.get_timestamps().get_timestamps()
            if len(timestamps) &gt; 0:
                lat_samples = loc.get_latitude_samples().get_values()
                lon_samples = loc.get_longitude_samples().get_values()
                alt_samples = loc.get_altitude_samples().get_values()
                spd_samples = loc.get_speed_samples().get_values()
                bear_samples = loc.get_bearing_samples().get_values()
                hor_acc_samples = loc.get_horizontal_accuracy_samples().get_values()
                vert_acc_samples = loc.get_vertical_accuracy_samples().get_values()
                spd_acc_samples = loc.get_speed_accuracy_samples().get_values()
                bear_acc_samples = loc.get_bearing_accuracy_samples().get_values()
                loc_prov_samples = loc.get_location_providers().get_values()
                data_for_df = []
                for i in range(len(timestamps)):
                    new_entry = [
                        timestamps[i],
                        timestamps[i],
                        lat_samples[i],
                        lon_samples[i],
                        np.nan if len(alt_samples) &lt; i + 1 else alt_samples[i],
                        np.nan if len(spd_samples) &lt; i + 1 else spd_samples[i],
                        np.nan if len(bear_samples) &lt; i + 1 else bear_samples[i],
                        np.nan if len(hor_acc_samples) &lt; i + 1 else hor_acc_samples[i],
                        np.nan if len(vert_acc_samples) &lt; i + 1 else vert_acc_samples[i],
                        np.nan if len(spd_acc_samples) &lt; i + 1 else spd_acc_samples[i],
                        np.nan if len(bear_acc_samples) &lt; i + 1 else bear_acc_samples[i],
                        np.nan if len(loc_prov_samples) &lt; i + 1 else loc_prov_samples[i],
                    ]
                    data_for_df.append(new_entry)
            else:
                return None
        data_df = pd.DataFrame(
            data_for_df,
            columns=[
                &#34;timestamps&#34;,
                &#34;unaltered_timestamps&#34;,
                &#34;latitude&#34;,
                &#34;longitude&#34;,
                &#34;altitude&#34;,
                &#34;speed&#34;,
                &#34;bearing&#34;,
                &#34;horizontal_accuracy&#34;,
                &#34;vertical_accuracy&#34;,
                &#34;speed_accuracy&#34;,
                &#34;bearing_accuracy&#34;,
                &#34;location_provider&#34;,
            ],
        )
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            loc.get_sensor_description(),
            data_df,
            SensorType.LOCATION,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_location_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_location_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load location data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: location sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_location_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load location data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: location sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_for_df = [[], [], [], [], [], [], [], [], [], [], []]
    for packet in wrapped_packets:
        loc = packet.get_sensors().get_location()
        if loc and packet.get_sensors().validate_location():
            if loc.is_only_best_values():
                if loc.get_last_best_location():
                    best_loc = loc.get_last_best_location()
                else:
                    best_loc = loc.get_overall_best_location()
                data_for_df[0].append(best_loc.get_latitude_longitude_timestamp().get_mach())
                data_for_df[1].append(best_loc.get_latitude())
                data_for_df[2].append(best_loc.get_longitude())
                data_for_df[3].append(best_loc.get_altitude())
                data_for_df[4].append(best_loc.get_speed())
                data_for_df[5].append(best_loc.get_bearing())
                data_for_df[6].append(best_loc.get_horizontal_accuracy())
                data_for_df[7].append(best_loc.get_vertical_accuracy())
                data_for_df[8].append(best_loc.get_speed_accuracy())
                data_for_df[9].append(best_loc.get_bearing_accuracy())
                data_for_df[10].append(best_loc.get_location_provider())
            else:
                timestamps = loc.get_timestamps().get_timestamps()
                if len(timestamps) &gt; 0:
                    data_for_df[0].extend(timestamps)
                    data_for_df[1].extend(loc.get_latitude_samples().get_values())
                    data_for_df[2].extend(loc.get_longitude_samples().get_values())
                    alt_samples = loc.get_altitude_samples().get_values()
                    if len(alt_samples) &lt;= 0:
                        alt_samples = np.full(len(timestamps), np.nan)
                    data_for_df[3].extend(alt_samples)
                    spd_samples = loc.get_speed_samples().get_values()
                    if len(spd_samples) &lt;= 0:
                        spd_samples = np.full(len(timestamps), np.nan)
                    data_for_df[4].extend(spd_samples)
                    bear_samples = loc.get_bearing_samples().get_values()
                    if len(bear_samples) &lt;= 0:
                        bear_samples = np.full(len(timestamps), np.nan)
                    data_for_df[5].extend(bear_samples)
                    hor_acc_samples = loc.get_horizontal_accuracy_samples().get_values()
                    if len(hor_acc_samples) &lt;= 0:
                        hor_acc_samples = np.full(len(timestamps), np.nan)
                    data_for_df[6].extend(hor_acc_samples)
                    vert_acc_samples = loc.get_vertical_accuracy_samples().get_values()
                    if len(vert_acc_samples) &lt;= 0:
                        vert_acc_samples = np.full(len(timestamps), np.nan)
                    data_for_df[7].extend(vert_acc_samples)
                    spd_acc_samples = loc.get_speed_accuracy_samples().get_values()
                    if len(spd_acc_samples) &lt;= 0:
                        spd_acc_samples = np.full(len(timestamps), np.nan)
                    data_for_df[8].extend(spd_acc_samples)
                    bear_acc_samples = loc.get_bearing_accuracy_samples().get_values()
                    if len(bear_acc_samples) &lt;= 0:
                        bear_acc_samples = np.full(len(timestamps), np.nan)
                    data_for_df[9].extend(bear_acc_samples)
                    loc_prov_samples = loc.get_location_providers().get_values()
                    if len(loc_prov_samples) &lt;= len(timestamps):
                        loc_prov_samples = np.full(len(timestamps), loc_prov_samples[0])
                    data_for_df[10].extend(loc_prov_samples)
    if len(data_for_df[0]) &gt; 0:
        data_for_df.insert(1, data_for_df[0].copy())
        return SensorData(
            wrapped_packets[0].get_sensors().get_location().get_sensor_description(),
            pd.DataFrame(np.transpose(data_for_df), columns=[
                &#34;timestamps&#34;,
                &#34;unaltered_timestamps&#34;,
                &#34;latitude&#34;,
                &#34;longitude&#34;,
                &#34;altitude&#34;,
                &#34;speed&#34;,
                &#34;bearing&#34;,
                &#34;horizontal_accuracy&#34;,
                &#34;vertical_accuracy&#34;,
                &#34;speed_accuracy&#34;,
                &#34;bearing_accuracy&#34;,
                &#34;location_provider&#34;,
            ]),
            SensorType.LOCATION,
            calculate_stats=True
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_magnetometer"><code class="name flex">
<span>def <span class="ident">load_apim_magnetometer</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load magnetometer data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: magnetometer sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_magnetometer(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load magnetometer data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: magnetometer sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    mag = wrapped_packet.get_sensors().get_magnetometer()
    if mag and wrapped_packet.get_sensors().validate_magnetometer():
        data_df = read_apim_xyz_sensor(mag, &#34;magnetometer&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            mag.get_sensor_description(),
            data_df,
            SensorType.MAGNETOMETER,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_magnetometer_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_magnetometer_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load magnetometer data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: magnetometer sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_magnetometer_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load magnetometer data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: magnetometer sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        mag = packet.get_sensors().get_magnetometer()
        if mag and packet.get_sensors().validate_magnetometer():
            data_df[0].extend(mag.get_timestamps().get_timestamps())
            data_df[1].extend(mag.get_x_samples().get_values())
            data_df[2].extend(mag.get_y_samples().get_values())
            data_df[3].extend(mag.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.MAGNETOMETER, data_df, &#34;magnetometer&#34;,
                                    wrapped_packets[0].get_sensors().get_magnetometer().get_sensor_description())
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_orientation"><code class="name flex">
<span>def <span class="ident">load_apim_orientation</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load orientation data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: orientation sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_orientation(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load orientation data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: orientation sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    orientation = wrapped_packet.get_sensors().get_orientation()
    if orientation and wrapped_packet.get_sensors().validate_orientation():
        data_df = read_apim_xyz_sensor(orientation, &#34;orientation&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            orientation.get_sensor_description(),
            data_df,
            SensorType.ORIENTATION,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_orientation_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_orientation_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load orientation data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: orientation sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_orientation_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load orientation data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: orientation sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        orient = packet.get_sensors().get_orientation()
        if orient and packet.get_sensors().validate_orientation():
            data_df[0].extend(orient.get_timestamps().get_timestamps())
            data_df[1].extend(orient.get_x_samples().get_values())
            data_df[2].extend(orient.get_y_samples().get_values())
            data_df[3].extend(orient.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.ORIENTATION, data_df, &#34;orientation&#34;,
                                    wrapped_packets[0].get_sensors().get_orientation().get_sensor_description())
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_pressure"><code class="name flex">
<span>def <span class="ident">load_apim_pressure</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load pressure data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: pressure sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_pressure(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load pressure data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: pressure sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    pressure = wrapped_packet.get_sensors().get_pressure()
    if pressure and wrapped_packet.get_sensors().validate_pressure():
        data_df = read_apim_single_sensor(pressure, &#34;pressure&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            pressure.get_sensor_description(),
            data_df,
            SensorType.PRESSURE,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_pressure_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_pressure_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load pressure data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: pressure sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_pressure_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load pressure data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: pressure sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        pressure = packet.get_sensors().get_pressure()
        if pressure and packet.get_sensors().validate_pressure():
            data_df.extend(pressure.get_samples().get_values())
            timestamps.extend(pressure.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_pressure().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;pressure&#34;]),
            SensorType.PRESSURE,
            calculate_stats=True
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_proximity"><code class="name flex">
<span>def <span class="ident">load_apim_proximity</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load proximity data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: proximity sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_proximity(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load proximity data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: proximity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    proximity = wrapped_packet.get_sensors().get_proximity()
    if proximity and wrapped_packet.get_sensors().validate_proximity():
        data_df = read_apim_single_sensor(proximity, &#34;proximity&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            proximity.get_sensor_description(),
            data_df,
            SensorType.PROXIMITY,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_proximity_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_proximity_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load proximity data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: proximity sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_proximity_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load proximity data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: proximity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        proximity = packet.get_sensors().get_proximity()
        if proximity and packet.get_sensors().validate_proximity():
            data_df.extend(proximity.get_samples().get_values())
            timestamps.extend(proximity.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_proximity().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;proximity&#34;]),
            SensorType.PROXIMITY,
            calculate_stats=True
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_rel_humidity"><code class="name flex">
<span>def <span class="ident">load_apim_rel_humidity</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load relative humidity data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: relative humidity sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_rel_humidity(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load relative humidity data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: relative humidity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    rel_humidity = wrapped_packet.get_sensors().get_relative_humidity()
    if rel_humidity and wrapped_packet.get_sensors().validate_relative_humidity():
        data_df = read_apim_single_sensor(rel_humidity, &#34;rel_humidity&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            rel_humidity.get_sensor_description(),
            data_df,
            SensorType.RELATIVE_HUMIDITY,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_rel_humidity_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_rel_humidity_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load relative humidity data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: relative humidity sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_rel_humidity_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load relative humidity data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: relative humidity sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = []
    timestamps = []
    for packet in wrapped_packets:
        rel_hum = packet.get_sensors().get_relative_humidity()
        if rel_hum and packet.get_sensors().validate_relative_humidity():
            data_df.extend(rel_hum.get_samples().get_values())
            timestamps.extend(rel_hum.get_timestamps().get_timestamps())
    if len(data_df) &gt; 0:
        return SensorData(
            wrapped_packets[0].get_sensors().get_relative_humidity().get_sensor_description(),
            pd.DataFrame(np.transpose([timestamps, timestamps, data_df]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, &#34;rel_humidity&#34;]),
            SensorType.RELATIVE_HUMIDITY,
            calculate_stats=True
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_rotation_vector"><code class="name flex">
<span>def <span class="ident">load_apim_rotation_vector</span></span>(<span>wrapped_packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load rotation vector data from a single wrapped packet
:param wrapped_packet: packet with data to load
:return: rotation vector sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_rotation_vector(wrapped_packet: WrappedRedvoxPacketM) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load rotation vector data from a single wrapped packet
    :param wrapped_packet: packet with data to load
    :return: rotation vector sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    rotation = wrapped_packet.get_sensors().get_rotation_vector()
    if rotation and wrapped_packet.get_sensors().validate_rotation_vector():
        data_df = read_apim_xyz_sensor(rotation, &#34;rotation_vector&#34;)
        sample_rate, sample_interval, sample_interval_std = get_sample_statistics(data_df)
        return SensorData(
            rotation.get_sensor_description(),
            data_df,
            SensorType.ROTATION_VECTOR,
            sample_rate,
            sample_interval,
            sample_interval_std,
            False,
        )</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_rotation_vector_from_list"><code class="name flex">
<span>def <span class="ident">load_apim_rotation_vector_from_list</span></span>(<span>wrapped_packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="../api1000/wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>load rotation vector data from a list of wrapped packets
:param wrapped_packets: packets with data to load
:return: rotation vector sensor data if it exists, None otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_rotation_vector_from_list(wrapped_packets: List[WrappedRedvoxPacketM]) -&gt; Optional[SensorData]:
    &#34;&#34;&#34;
    load rotation vector data from a list of wrapped packets
    :param wrapped_packets: packets with data to load
    :return: rotation vector sensor data if it exists, None otherwise
    &#34;&#34;&#34;
    data_df = [[], [], [], []]
    for packet in wrapped_packets:
        rot_vec = packet.get_sensors().get_rotation_vector()
        if rot_vec and packet.get_sensors().validate_rotation_vector():
            data_df[0].extend(rot_vec.get_timestamps().get_timestamps())
            data_df[1].extend(rot_vec.get_x_samples().get_values())
            data_df[2].extend(rot_vec.get_y_samples().get_values())
            data_df[3].extend(rot_vec.get_z_samples().get_values())
    if len(data_df[0]) &gt; 0:
        return load_apim_xyz_sensor(SensorType.ROTATION_VECTOR, data_df, &#34;rotation_vector&#34;,
                                    wrapped_packets[0].get_sensors().get_rotation_vector().get_sensor_description())
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.load_apim_xyz_sensor"><code class="name flex">
<span>def <span class="ident">load_apim_xyz_sensor</span></span>(<span>sensor_type: <a title="redvox.common.sensor_data.SensorType" href="sensor_data.html#redvox.common.sensor_data.SensorType">SensorType</a>, data, name, description) ‑> typing.Union[<a title="redvox.common.sensor_data.SensorData" href="sensor_data.html#redvox.common.sensor_data.SensorData">SensorData</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_apim_xyz_sensor(sensor_type: SensorType, data, name, description) -&gt; Optional[SensorData]:
    if len(data[0]) &gt; 0:
        return SensorData(
            description,
            pd.DataFrame(np.transpose([data[0], data[0], data[1], data[2], data[3]]),
                         columns=[&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, f&#34;{name}_x&#34;, f&#34;{name}_y&#34;, f&#34;{name}_z&#34;]),
            sensor_type,
            calculate_stats=True
        )
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.read_apim_single_sensor"><code class="name flex">
<span>def <span class="ident">read_apim_single_sensor</span></span>(<span>sensor: <a title="redvox.api1000.wrapped_redvox_packet.sensors.single.Single" href="../api1000/wrapped_redvox_packet/sensors/single.html#redvox.api1000.wrapped_redvox_packet.sensors.single.Single">Single</a>, column_id: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>read a sensor that has a single data channel from an api M data packet
raises Attribute Error if sensor does not contain exactly one data channel
:param sensor: the single channel api M sensor to read
:param column_id: string, used to name the columns
:return: Dataframe representing the data in the sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_apim_single_sensor(sensor: single.Single, column_id: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    read a sensor that has a single data channel from an api M data packet
    raises Attribute Error if sensor does not contain exactly one data channel
    :param sensor: the single channel api M sensor to read
    :param column_id: string, used to name the columns
    :return: Dataframe representing the data in the sensor
    &#34;&#34;&#34;
    timestamps = sensor.get_timestamps().get_timestamps()
    try:
        columns = [&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, column_id]
        return pd.DataFrame(
            np.transpose([timestamps, timestamps, sensor.get_samples().get_values()]),
            columns=columns,
        )
    except AttributeError:
        raise</code></pre>
</details>
</dd>
<dt id="redvox.common.sensor_reader_utils.read_apim_xyz_sensor"><code class="name flex">
<span>def <span class="ident">read_apim_xyz_sensor</span></span>(<span>sensor: <a title="redvox.api1000.wrapped_redvox_packet.sensors.xyz.Xyz" href="../api1000/wrapped_redvox_packet/sensors/xyz.html#redvox.api1000.wrapped_redvox_packet.sensors.xyz.Xyz">Xyz</a>, column_id: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>read a sensor that has xyz data channels from an api M data packet
raises Attribute Error if sensor does not contain xyz channels
:param sensor: the xyz api M sensor to read
:param column_id: string, used to name the columns
:return: Dataframe representing the data in the sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_apim_xyz_sensor(sensor: xyz.Xyz, column_id: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    read a sensor that has xyz data channels from an api M data packet
    raises Attribute Error if sensor does not contain xyz channels
    :param sensor: the xyz api M sensor to read
    :param column_id: string, used to name the columns
    :return: Dataframe representing the data in the sensor
    &#34;&#34;&#34;
    timestamps = sensor.get_timestamps().get_timestamps()
    try:
        columns = [&#34;timestamps&#34;, &#34;unaltered_timestamps&#34;, f&#34;{column_id}_x&#34;, f&#34;{column_id}_y&#34;, f&#34;{column_id}_z&#34;]
        return pd.DataFrame(
            np.transpose(
                [
                    timestamps,
                    timestamps,
                    sensor.get_x_samples().get_values(),
                    sensor.get_y_samples().get_values(),
                    sensor.get_z_samples().get_values(),
                ]
            ),
            columns=columns,
        )
    except AttributeError:
        raise</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.common.sensor_reader_utils.add_dataless_timestamps_to_df" href="#redvox.common.sensor_reader_utils.add_dataless_timestamps_to_df">add_dataless_timestamps_to_df</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.calc_evenly_sampled_timestamps" href="#redvox.common.sensor_reader_utils.calc_evenly_sampled_timestamps">calc_evenly_sampled_timestamps</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.create_dataless_timestamps_df" href="#redvox.common.sensor_reader_utils.create_dataless_timestamps_df">create_dataless_timestamps_df</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.fill_audio_gaps" href="#redvox.common.sensor_reader_utils.fill_audio_gaps">fill_audio_gaps</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.get_empty_sensor_data" href="#redvox.common.sensor_reader_utils.get_empty_sensor_data">get_empty_sensor_data</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.get_sample_statistics" href="#redvox.common.sensor_reader_utils.get_sample_statistics">get_sample_statistics</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_accelerometer" href="#redvox.common.sensor_reader_utils.load_apim_accelerometer">load_apim_accelerometer</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_accelerometer_from_list" href="#redvox.common.sensor_reader_utils.load_apim_accelerometer_from_list">load_apim_accelerometer_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_ambient_temp" href="#redvox.common.sensor_reader_utils.load_apim_ambient_temp">load_apim_ambient_temp</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_ambient_temp_from_list" href="#redvox.common.sensor_reader_utils.load_apim_ambient_temp_from_list">load_apim_ambient_temp_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_audio" href="#redvox.common.sensor_reader_utils.load_apim_audio">load_apim_audio</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_audio_from_list" href="#redvox.common.sensor_reader_utils.load_apim_audio_from_list">load_apim_audio_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_compressed_audio" href="#redvox.common.sensor_reader_utils.load_apim_compressed_audio">load_apim_compressed_audio</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_compressed_audio_from_list" href="#redvox.common.sensor_reader_utils.load_apim_compressed_audio_from_list">load_apim_compressed_audio_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_gravity" href="#redvox.common.sensor_reader_utils.load_apim_gravity">load_apim_gravity</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_gravity_from_list" href="#redvox.common.sensor_reader_utils.load_apim_gravity_from_list">load_apim_gravity_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_gyroscope" href="#redvox.common.sensor_reader_utils.load_apim_gyroscope">load_apim_gyroscope</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_gyroscope_from_list" href="#redvox.common.sensor_reader_utils.load_apim_gyroscope_from_list">load_apim_gyroscope_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_health" href="#redvox.common.sensor_reader_utils.load_apim_health">load_apim_health</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_health_from_list" href="#redvox.common.sensor_reader_utils.load_apim_health_from_list">load_apim_health_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_image" href="#redvox.common.sensor_reader_utils.load_apim_image">load_apim_image</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_image_from_list" href="#redvox.common.sensor_reader_utils.load_apim_image_from_list">load_apim_image_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_light" href="#redvox.common.sensor_reader_utils.load_apim_light">load_apim_light</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_light_from_list" href="#redvox.common.sensor_reader_utils.load_apim_light_from_list">load_apim_light_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_linear_accel" href="#redvox.common.sensor_reader_utils.load_apim_linear_accel">load_apim_linear_accel</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_linear_accel_from_list" href="#redvox.common.sensor_reader_utils.load_apim_linear_accel_from_list">load_apim_linear_accel_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_location" href="#redvox.common.sensor_reader_utils.load_apim_location">load_apim_location</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_location_from_list" href="#redvox.common.sensor_reader_utils.load_apim_location_from_list">load_apim_location_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_magnetometer" href="#redvox.common.sensor_reader_utils.load_apim_magnetometer">load_apim_magnetometer</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_magnetometer_from_list" href="#redvox.common.sensor_reader_utils.load_apim_magnetometer_from_list">load_apim_magnetometer_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_orientation" href="#redvox.common.sensor_reader_utils.load_apim_orientation">load_apim_orientation</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_orientation_from_list" href="#redvox.common.sensor_reader_utils.load_apim_orientation_from_list">load_apim_orientation_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_pressure" href="#redvox.common.sensor_reader_utils.load_apim_pressure">load_apim_pressure</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_pressure_from_list" href="#redvox.common.sensor_reader_utils.load_apim_pressure_from_list">load_apim_pressure_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_proximity" href="#redvox.common.sensor_reader_utils.load_apim_proximity">load_apim_proximity</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_proximity_from_list" href="#redvox.common.sensor_reader_utils.load_apim_proximity_from_list">load_apim_proximity_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_rel_humidity" href="#redvox.common.sensor_reader_utils.load_apim_rel_humidity">load_apim_rel_humidity</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_rel_humidity_from_list" href="#redvox.common.sensor_reader_utils.load_apim_rel_humidity_from_list">load_apim_rel_humidity_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_rotation_vector" href="#redvox.common.sensor_reader_utils.load_apim_rotation_vector">load_apim_rotation_vector</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_rotation_vector_from_list" href="#redvox.common.sensor_reader_utils.load_apim_rotation_vector_from_list">load_apim_rotation_vector_from_list</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.load_apim_xyz_sensor" href="#redvox.common.sensor_reader_utils.load_apim_xyz_sensor">load_apim_xyz_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.read_apim_single_sensor" href="#redvox.common.sensor_reader_utils.read_apim_single_sensor">read_apim_single_sensor</a></code></li>
<li><code><a title="redvox.common.sensor_reader_utils.read_apim_xyz_sensor" href="#redvox.common.sensor_reader_utils.read_apim_xyz_sensor">read_apim_xyz_sensor</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>