<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redvox.common.event_stream API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.event_stream</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import List, Optional, Dict
from dataclasses import dataclass, field
from pathlib import Path
import os

import numpy as np
import pyarrow as pa
import pyarrow.parquet as pq
from dataclasses_json import dataclass_json

from redvox.api1000.common.mapping import Mapping
from redvox.api1000.proto.redvox_api_m_pb2 import RedvoxPacketM
from redvox.api1000.wrapped_redvox_packet import event_streams as es
from redvox.common.errors import RedVoxExceptions
from redvox.common import offset_model as om
from redvox.common.io import FileSystemWriter as Fsw, FileSystemSaveMode
import redvox.common.event_stream_io as io


class EventStream:
    &#34;&#34;&#34;
    stores event stream data gathered from a single station.
    ALL timestamps in microseconds since epoch UTC unless otherwise stated
    &#34;&#34;&#34;
    def __init__(self, name: str = &#34;event&#34;,
                 schema: Optional[Dict[str, list]] = None,
                 save_mode: FileSystemSaveMode = FileSystemSaveMode.MEM,
                 base_dir: str = &#34;.&#34;):
        &#34;&#34;&#34;
        initialize EventStream for a station

        :param name: name of the EventStream.  Default &#34;event&#34;
        :param schema: a structured dictionary of the data table schema.  Dictionary must look like:
                    {&#34;string&#34;: [s_values], &#34;numeric&#34;: [n_values], &#34;boolean&#34;: [o_values], &#34;byte&#34;: [b_values]}
                    where [*_values] is a list of strings and can be empty.  Default None
        :param save_mode: FileSystemSaveMode that determines how data is saved.
                            Default FileSystemSaveMode.MEM (use RAM).  Other options are DISK (save to directory)
                            and TEMP (save to temporary directory)
        :param base_dir: the location of the parquet file that holds the data.  Not used if save_data is False.
                            Default current directory (&#34;.&#34;)
        &#34;&#34;&#34;
        self.name = name
        self.timestamps_metadata = {}
        self.metadata = {}

        self._errors = RedVoxExceptions(&#34;EventStream&#34;)
        self._is_timestamps_corrected = False
        self._fs_writer = Fsw(f&#34;event_{name}&#34;, &#34;parquet&#34;, base_dir, save_mode)
        self._data = None
        self._schema = {&#34;string&#34;: [], &#34;numeric&#34;: [], &#34;boolean&#34;: [], &#34;byte&#34;: []}
        if schema is not None:
            self.set_schema(schema)

    def as_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: EventStream as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;metadata&#34;: self.metadata,
            &#34;timestamps_metadata&#34;: self.timestamps_metadata,
            &#34;is_timestamps_corrected&#34;: self._is_timestamps_corrected,
            &#34;schema&#34;: self._schema,
            &#34;file_path&#34;: self.full_path(),
            &#34;errors&#34;: self._errors.as_dict()
        }

    @staticmethod
    def __get_items(payload: Mapping[str]):
        return payload.get_metadata().items()

    @staticmethod
    def __get_items_raw(payload):
        return payload.items()

    @staticmethod
    def __get_keys(ptype: str, payload: Mapping[str]):
        return ptype, payload.get_metadata().keys()

    @staticmethod
    def __get_keys_raw(ptype: str, payload):
        return ptype, payload.keys()

    def __set_schema(self, name: str, value: str):
        self._schema[name].append(value)

    def _get_tbl_schema(self) -&gt; Dict[str, list]:
        &#34;&#34;&#34;
        :return: the dictionary used to create the EventStream data object
        &#34;&#34;&#34;
        if self._data:
            result = {}
            for f in self._data.schema.names:
                result[f] = []
        else:
            result = {&#34;timestamps&#34;: [], &#34;unaltered_timestamps&#34;: []}
            for t, s in self._schema.items():
                for k in s:
                    result[k] = []
        return result

    def read_events(self, eventstream: es.EventStream):
        &#34;&#34;&#34;
        read the payloads of each event in the eventstream and separate the data by payload type

        :param eventstream: stream of events to process
        &#34;&#34;&#34;
        self.name = eventstream.get_name()
        self._fs_writer.file_name = f&#34;event_{self.name}&#34;
        num_events = eventstream.get_events().get_count()
        if num_events &gt; 1:
            tbl = self._get_tbl_schema()
            self.timestamps_metadata = eventstream.get_timestamps().get_metadata()
            self.metadata = eventstream.get_metadata()
            first_event = eventstream.get_events().get_values()[0]
            for t, c in map(self.__get_keys, [&#34;string&#34;, &#34;numeric&#34;, &#34;boolean&#34;, &#34;byte&#34;],
                            [first_event.get_string_payload(), first_event.get_numeric_payload(),
                             first_event.get_boolean_payload(), first_event.get_byte_payload()]):
                for k in c:
                    self.add_to_schema(t, k)
                    tbl[k] = []
            for i in range(num_events):
                tbl[&#34;timestamps&#34;].append(eventstream.get_timestamps().get_timestamps()[i])
                tbl[&#34;unaltered_timestamps&#34;].append(eventstream.get_timestamps().get_timestamps()[i])
                evnt = eventstream.get_events().get_values()[i]
                for items in map(self.__get_items, [evnt.get_string_payload(), evnt.get_numeric_payload(),
                                                    evnt.get_boolean_payload(), evnt.get_byte_payload()]):
                    for c, st in items:
                        tbl[c].append(st)
            self._data = pa.Table.from_pydict(tbl)

    def read_raw(self, stream: RedvoxPacketM.EventStream) -&gt; &#39;EventStream&#39;:
        &#34;&#34;&#34;
        read the contents of a protobuf stream

        :param stream: the protobuf stream to read
        &#34;&#34;&#34;
        self.name = stream.name
        self._fs_writer.file_name = f&#34;event_{self.name}&#34;
        num_events = len(stream.events)
        if num_events &gt; 1:
            tbl = self._get_tbl_schema()
            self.timestamps_metadata = stream.timestamps.metadata
            self.metadata = stream.metadata
            first_event = stream.events[0]
            for t, c in map(EventStream.__get_keys_raw, [&#34;string&#34;, &#34;numeric&#34;, &#34;boolean&#34;, &#34;byte&#34;],
                            [first_event.string_payload, first_event.numeric_payload,
                             first_event.boolean_payload, first_event.byte_payload]):
                for k in c:
                    self.add_to_schema(t, k)
                    tbl[k] = []
            for i in range(num_events):
                tbl[&#34;timestamps&#34;].append(stream.timestamps.timestamps[i])
                tbl[&#34;unaltered_timestamps&#34;].append(stream.timestamps.timestamps[i])
                evnt = stream.events[i]
                for items in map(EventStream.__get_items_raw, [evnt.string_payload, evnt.numeric_payload,
                                                               evnt.boolean_payload, evnt.byte_payload]):
                    for c, st in items:
                        tbl[c].append(st)
            self._data = pa.Table.from_pydict(tbl)
        return self

    def read_from_dir(self, file: str):
        &#34;&#34;&#34;
        read a pyarrow table from a file on disk

        :param file: full path to the file to read
        &#34;&#34;&#34;
        try:
            tbl = pq.read_table(file)
            if tbl.schema.names == self._get_tbl_schema():
                self._data = tbl
        except FileNotFoundError:
            self._errors.append(&#34;No data file was found; this event is empty.&#34;)
            self._data = None

    def get_string_schema(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: the column names of string typed data as a list of strings
        &#34;&#34;&#34;
        return self._schema[&#34;string&#34;]

    def get_numeric_schema(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: the column names of numeric typed data as a list of strings
        &#34;&#34;&#34;
        return self._schema[&#34;numeric&#34;]

    def get_boolean_schema(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: the column names of boolean typed data as a list of strings
        &#34;&#34;&#34;
        return self._schema[&#34;boolean&#34;]

    def get_byte_schema(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: the column names of byte typed data as a list of strings
        &#34;&#34;&#34;
        return self._schema[&#34;byte&#34;]

    def get_schema(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: the schema of the EventStream
        &#34;&#34;&#34;
        return self._schema

    def get_string_values(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the string data as a pyarrow table
        &#34;&#34;&#34;
        return self._data.select(self.get_string_schema()) if self._data else pa.Table.from_pydict({})

    def get_numeric_values(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the numeric data as a pyarrow table
        &#34;&#34;&#34;
        return self._data.select(self.get_numeric_schema()) if self._data else pa.Table.from_pydict({})

    def get_boolean_values(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the boolean data as a pyarrow table
        &#34;&#34;&#34;
        return self._data.select(self.get_boolean_schema()) if self._data else pa.Table.from_pydict({})

    def get_byte_values(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the byte data as a pyarrow table
        &#34;&#34;&#34;
        return self._data.select(self.get_byte_schema()) if self._data else pa.Table.from_pydict({})

    def _check_for_name(self, column_name: str, schema: List[str]) -&gt; bool:
        &#34;&#34;&#34;
        :param column_name: name of column to check for
        :param schema: list of allowed names
        :return: True if column_name is in schema, sets error and returns False if not
        &#34;&#34;&#34;
        if column_name not in schema:
            self._errors.append(f&#34;WARNING: Column {column_name} does not exist; try one of {schema}&#34;)
            return False
        return True

    def __get_column_data(self, schema: List[str], column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param schema: list of column names to search
        :param column_name: column name to get
        :return: the data as an np.array; if empty, column name or data doesn&#39;t exist
        &#34;&#34;&#34;
        return self._data[column_name].to_numpy() if self._check_for_name(column_name, schema) else np.array([])

    def get_string_column(self, column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param column_name: name of string payload to retrieve
        :return: string data from the column specified
        &#34;&#34;&#34;
        return self.__get_column_data(self.get_string_schema(), column_name)

    def get_numeric_column(self, column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param column_name: name of numeric payload to retrieve
        :return: numeric data from the column specified
        &#34;&#34;&#34;
        return self.__get_column_data(self.get_numeric_schema(), column_name)

    def get_boolean_column(self, column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param column_name: name of boolean payload to retrieve
        :return: boolean data from the column specified
        &#34;&#34;&#34;
        return self.__get_column_data(self.get_boolean_schema(), column_name)

    def get_byte_column(self, column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param column_name: name of byte payload to retrieve
        :return: bytes data from the column specified
        &#34;&#34;&#34;
        return self.__get_column_data(self.get_byte_schema(), column_name)

    def set_schema(self, schema: Dict[str, list]):
        &#34;&#34;&#34;
        sets the schema of the EventStream using a specially structured dictionary.
        Structure is:

        {&#34;string&#34;: [s_values], &#34;numeric&#34;: [n_values], &#34;boolean&#34;: [o_values], &#34;byte&#34;: [b_values]}

        where [*_values] is a list of strings and can be empty

        :param schema: specially structured dictionary of data table schema
        &#34;&#34;&#34;
        if schema.keys() != self._schema.keys():
            self._errors.append(f&#34;Attempted to add invalid schema with keys {list(schema.keys())} to EventStreams.\n&#34;
                                f&#34;Valid keys are: {list(self._schema.keys())}&#34;)
        else:
            self._schema = schema

    def add_to_schema(self, key: str, value: str):
        &#34;&#34;&#34;
        adds a value to the schema, under the specified key

        :param key: one of &#34;string&#34;, &#34;numeric&#34;, &#34;boolean&#34;, or &#34;byte&#34;
        :param value: the name of the column to add to the schema
        &#34;&#34;&#34;
        if key not in self._schema.keys():
            self._errors.append(&#34;Attempted to add an unknown key to the EventStream schema.\n&#34;
                                f&#34;You must use one of {self._schema.keys()}.&#34;)
        else:
            self._schema[key].append(value)

    def add(self, other_stream: es.EventStream):
        &#34;&#34;&#34;
        adds a Redvox Api1000 EventStream with the same name to the data

        :param other_stream: another EventStream with the same name
        &#34;&#34;&#34;
        if self.name != other_stream.get_name():
            self._errors.append(f&#34;Attempted to add a stream with a different name ({other_stream.get_name()})&#34;)
        else:
            self.timestamps_metadata = {**self.timestamps_metadata, **other_stream.get_timestamps().get_metadata()}
            self.metadata = {**self.metadata, **other_stream.get_metadata()}
            num_events = other_stream.get_events().get_count()
            if num_events &gt; 1:
                tbl = self._get_tbl_schema()
                for i in range(num_events):
                    tbl[&#34;timestamps&#34;].append(other_stream.get_timestamps().get_timestamps()[i])
                    tbl[&#34;unaltered_timestamps&#34;].append(other_stream.get_timestamps().get_timestamps()[i])
                    evnt = other_stream.get_events().get_values()[i]
                    for items in map(self.__get_items, [evnt.get_string_payload(), evnt.get_numeric_payload(),
                                                        evnt.get_boolean_payload(), evnt.get_byte_payload()]):
                        for c, st in items:
                            tbl[c].append(st)
                self._data = pa.concat_tables([self._data, pa.Table.from_pydict(tbl)])

    def add_raw(self, other_stream: RedvoxPacketM.EventStream):
        &#34;&#34;&#34;
        add a protobuf EventStream with the same name to the data

        :param other_stream: a protobuf EventStream to add
        &#34;&#34;&#34;
        if self.name != other_stream.name:
            self._errors.append(f&#34;Attempted to add a stream with a different name ({other_stream.name})&#34;)
        else:
            self.timestamps_metadata = {**self.timestamps_metadata, **other_stream.timestamps.metadata}
            self.metadata = {**self.metadata, **other_stream.metadata}
            num_events = len(other_stream.events)
            if num_events &gt; 1:
                tbl = self._get_tbl_schema()
                for i in range(num_events):
                    tbl[&#34;timestamps&#34;].append(other_stream.timestamps.timestamps[i])
                    tbl[&#34;unaltered_timestamps&#34;].append(other_stream.timestamps.timestamps[i])
                    evnt = other_stream.events[i]
                    for items in map(EventStream.__get_items_raw, [evnt.string_payload, evnt.numeric_payload,
                                                                   evnt.boolean_payload, evnt.byte_payload]):
                        for c, st in items:
                            tbl[c].append(st)
                self._data = pa.concat_tables([self._data, pa.Table.from_pydict(tbl)])

    def append(self, other_stream: &#34;EventStream&#34;):
        &#34;&#34;&#34;
        add another EventStream onto the calling one if they have the same name

        :param other_stream: other stream to add to current
        &#34;&#34;&#34;
        if other_stream.name == self.name:
            self._data = pa.concat_tables([self._data, other_stream._data])
            self.timestamps_metadata = {**self.timestamps_metadata, **other_stream.timestamps_metadata}
            self.metadata = {**self.metadata, **other_stream.metadata}
            self._errors.extend_error(other_stream.errors())

    def timestamps(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: the timestamps as a numpy array; returns empty array if no timestamps exist
        &#34;&#34;&#34;
        if &#34;timestamps&#34; in self.data().schema.names:
            return self.data()[&#34;timestamps&#34;].to_numpy()
        else:
            return np.array([])

    def unaltered_timestamps(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: the unaltered timestamps as a numpy array; returns empty array if no timestamps exist
        &#34;&#34;&#34;
        if &#34;unaltered_timestamps&#34; in self.data().schema.names:
            return self.data()[&#34;unaltered_timestamps&#34;].to_numpy()
        else:
            return np.array([])

    def update_timestamps(self, offset_model: om.OffsetModel, use_model_function: bool = False):
        &#34;&#34;&#34;
        updates the timestamps of the data points

        :param offset_model: model used to update the timestamps
        :param use_model_function: if True, use the model&#39;s slope function to update the timestamps.
                                    otherwise uses the best offset (model&#39;s intercept value).  Default False
        &#34;&#34;&#34;
        if self._data is not None and self._data.num_rows &gt; 0:
            timestamps = pa.array(offset_model.update_timestamps(self._data[&#34;timestamps&#34;].to_numpy(),
                                                                 use_model_function))
            self._data.set_column(0, &#34;timestamps&#34;, timestamps)

    def default_json_file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: default event stream json file name (event_[event.name]): note there is no extension
        &#34;&#34;&#34;
        return f&#34;event_{self.name}&#34;

    def is_save_to_disk(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: True if sensor will be saved to disk
        &#34;&#34;&#34;
        return self._fs_writer.is_save_disk()

    def set_save_to_disk(self, save: bool):
        &#34;&#34;&#34;
        :param save: If True, save to disk
        &#34;&#34;&#34;
        self._fs_writer.save_to_disk = save

    def set_save_mode(self, save_mode: FileSystemSaveMode):
        &#34;&#34;&#34;
        set the save mode

        :param save_mode: new save mode
        &#34;&#34;&#34;
        self._fs_writer.set_save_mode(save_mode)

    def set_file_name(self, new_file: Optional[str] = None):
        &#34;&#34;&#34;
        * set the pyarrow file name or use the default: event_{EventStream.name}
        * Do not give an extension

        :param new_file: optional file name to change to; default None (use default name)
        &#34;&#34;&#34;
        self._fs_writer.file_name = new_file if new_file else f&#34;event_{self.name}&#34;

    def full_file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: full name of parquet file containing the data
        &#34;&#34;&#34;
        return self._fs_writer.full_name()

    def file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: file name without extension
        &#34;&#34;&#34;
        return self._fs_writer.file_name

    def set_save_dir(self, new_dir: Optional[str] = None):
        &#34;&#34;&#34;
        set the pyarrow directory or use the default: &#34;.&#34; (current directory)

        :param new_dir: the directory to change to; default None (use current directory)
        &#34;&#34;&#34;
        self._fs_writer.base_dir = new_dir if new_dir else &#34;.&#34;

    def save_dir(self) -&gt; str:
        &#34;&#34;&#34;
        :return: directory containing parquet files for the sensor
        &#34;&#34;&#34;
        return self._fs_writer.save_dir()

    def full_path(self) -&gt; str:
        &#34;&#34;&#34;
        :return: the full path to the data file
        &#34;&#34;&#34;
        return self._fs_writer.full_path()

    def fs_writer(self) -&gt; Fsw:
        &#34;&#34;&#34;
        :return: FileSystemWriter object
        &#34;&#34;&#34;
        return self._fs_writer

    def write_table(self):
        &#34;&#34;&#34;
        writes the event stream data to disk.
        &#34;&#34;&#34;
        if self._data is not None:
            pq.write_table(self._data, self.full_path())

    def data(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the data as a pyarrow table
        &#34;&#34;&#34;
        if self._data is None:
            if self.is_save_to_disk():
                self._data = pq.read_table(self.full_path())
            else:
                return pa.Table.from_pydict({})
        return self._data

    @staticmethod
    def from_json_file(file_dir: str, file_name: str) -&gt; &#34;EventStream&#34;:
        &#34;&#34;&#34;
        :param file_dir: full path to containing directory for the file
        :param file_name: name of file and extension to load data from
        :return: EventStream from json file
        &#34;&#34;&#34;
        if file_name is None:
            file_name = io.get_json_file(file_dir)
            if file_name is None:
                result = EventStream(&#34;Empty&#34;)
                result.append_error(&#34;JSON file to load EventStream from not found.&#34;)
                return result
        json_data = io.json_file_to_dict(os.path.join(file_dir, f&#34;{file_name}.json&#34;))
        if &#34;name&#34; in json_data.keys():
            result = EventStream(json_data[&#34;name&#34;], json_data[&#34;schema&#34;], FileSystemSaveMode.DISK, file_dir)
            result.metadata = json_data[&#34;metadata&#34;]
            result.timestamps_metadata = json_data[&#34;timestamps_metadata&#34;]
            result.set_errors(RedVoxExceptions.from_dict(json_data[&#34;errors&#34;]))
            result.read_from_dir(json_data[&#34;file_path&#34;])
        else:
            result = EventStream(&#34;Empty&#34;)
            result.append_error(f&#34;Loading from {file_name} failed; missing EventStream name.&#34;)
        return result

    def to_json_file(self, file_name: Optional[str] = None) -&gt; Path:
        &#34;&#34;&#34;
        saves the EventStream as a json file

        :param file_name: the optional base file name.  Do not include a file extension.
                            If None, a default file name is created using this format:
                            event_[event.name].json
        :return: path to json file
        &#34;&#34;&#34;
        if self._fs_writer.file_extension == &#34;parquet&#34; and self._data is not None:
            self.write_table()
        return io.to_json_file(self, file_name)

    def errors(self) -&gt; RedVoxExceptions:
        &#34;&#34;&#34;
        :return: errors of the sensor
        &#34;&#34;&#34;
        return self._errors

    def set_errors(self, errors: RedVoxExceptions):
        &#34;&#34;&#34;
        sets the errors of the Sensor

        :param errors: errors to set
        &#34;&#34;&#34;
        self._errors = errors

    def append_error(self, error: str):
        &#34;&#34;&#34;
        add an error to the Sensor

        :param error: error to add
        &#34;&#34;&#34;
        self._errors.append(error)

    def print_errors(self):
        &#34;&#34;&#34;
        print all errors to screen
        &#34;&#34;&#34;
        self._errors.print()


@dataclass_json
@dataclass
class EventStreams:
    &#34;&#34;&#34;
    stores multiple event streams per station
    ALL timestamps in microseconds since epoch UTC unless otherwise stated
    &#34;&#34;&#34;
    streams: List[EventStream] = field(default_factory=lambda: [])
    save_mode: FileSystemSaveMode = FileSystemSaveMode.MEM
    base_dir: str = &#34;.&#34;
    debug: bool = False

    def list_for_dict(self) -&gt; list:
        &#34;&#34;&#34;
        :return: the name of files that store event streams
        &#34;&#34;&#34;
        return [s.file_name() for s in self.streams]

    def read_from_packet(self, packet: RedvoxPacketM):
        &#34;&#34;&#34;
        read the eventstream payload from a single Redvox Api1000 packet

        :param packet: packet to read data from
        &#34;&#34;&#34;
        for st in packet.event_streams:
            if st.name in self.get_stream_names():
                self.get_stream(st.name).add_raw(st)
            else:
                self.streams.append(EventStream(save_mode=self.save_mode, base_dir=self.base_dir).read_raw(st))

    def read_from_packets_list(self, packets: List[RedvoxPacketM]):
        &#34;&#34;&#34;
        read the eventstream payload from multiple Redvox Api1000 packets

        :param packets: packets to read data from
        &#34;&#34;&#34;
        for p in packets:
            if type(p) == RedvoxPacketM:
                self.read_from_packet(p)

    def append(self, other_stream: EventStream):
        &#34;&#34;&#34;
        append another EventStream to an existing EventStream or add to the list of EventStream

        :param other_stream: other EventStream to add
        &#34;&#34;&#34;
        if other_stream.name in self.get_stream_names():
            self.get_stream(other_stream.name).append(other_stream)
        else:
            self.streams.append(other_stream)

    def append_streams(self, other_streams: &#34;EventStreams&#34;):
        &#34;&#34;&#34;
        append another EventStreams object to an existing EventStreams object

        :param other_streams: EventStreams to add
        &#34;&#34;&#34;
        for s in other_streams.streams:
            self.append(s)

    def get_stream(self, stream_name: str) -&gt; Optional[EventStream]:
        &#34;&#34;&#34;
        :param stream_name: name of event stream to get
        :return: the EventStream that has the name specified or None if it doesn&#39;t exist
        &#34;&#34;&#34;
        for s in self.streams:
            if s.name == stream_name:
                return s
        if self.debug:
            print(f&#34;{stream_name} does not exist in streams.  Use one of {[self.get_stream_names()]}&#34;)
        return None

    def get_stream_names(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: names of all streams
        &#34;&#34;&#34;
        return [s.name for s in self.streams]

    def save_streams(self):
        &#34;&#34;&#34;
        saves all streams to disk

        note: use the function set_save_dir() to change where events are saved
        &#34;&#34;&#34;
        for s in self.streams:
            s.to_json_file()

    def set_save_dir(self, new_dir: str):
        &#34;&#34;&#34;
        change the directory where events are saved to

        :param new_dir: new directory path
        &#34;&#34;&#34;
        self.base_dir = new_dir
        for s in self.streams:
            s.set_save_dir(new_dir)

    def set_save_mode(self, new_save_mode: FileSystemSaveMode):
        &#34;&#34;&#34;
        update the save mode for all EventStream

        :param new_save_mode: save mode to set
        &#34;&#34;&#34;
        for s in self.streams:
            s.set_save_mode(new_save_mode)

    def update_timestamps(self, offset_model: om.OffsetModel, use_model_function: bool = False):
        &#34;&#34;&#34;
        update the timestamps in the data

        :param offset_model: model used to update the timestamps
        :param use_model_function: if True, use the model&#39;s slope function to update the timestamps.
                                    otherwise uses the best offset (model&#39;s intercept value).  Default False
        &#34;&#34;&#34;
        for evnt in self.streams:
            evnt.update_timestamps(offset_model, use_model_function)

    @staticmethod
    def from_dir(base_dir: str, file_names: List[str]) -&gt; &#34;EventStreams&#34;:
        &#34;&#34;&#34;
        :param base_dir: directory containing EventStream files
        :param file_names: the names of .json files containing EventStream data

        :return: EventStreams object from a directory
        &#34;&#34;&#34;
        return EventStreams([EventStream.from_json_file(base_dir, e) for e in file_names],
                            save_mode=FileSystemSaveMode.DISK, base_dir=base_dir)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.common.event_stream.EventStream"><code class="flex name class">
<span>class <span class="ident">EventStream</span></span>
<span>(</span><span>name: str = 'event', schema: Optional[Dict[str, list]] = None, save_mode: <a title="redvox.common.io.FileSystemSaveMode" href="io.html#redvox.common.io.FileSystemSaveMode">FileSystemSaveMode</a> = FileSystemSaveMode.MEM, base_dir: str = '.')</span>
</code></dt>
<dd>
<div class="desc"><p>stores event stream data gathered from a single station.
ALL timestamps in microseconds since epoch UTC unless otherwise stated</p>
<p>initialize EventStream for a station</p>
<p>:param name: name of the EventStream.
Default "event"
:param schema: a structured dictionary of the data table schema.
Dictionary must look like:
{"string": [s_values], "numeric": [n_values], "boolean": [o_values], "byte": [b_values]}
where [*_values] is a list of strings and can be empty.
Default None
:param save_mode: FileSystemSaveMode that determines how data is saved.
Default FileSystemSaveMode.MEM (use RAM).
Other options are DISK (save to directory)
and TEMP (save to temporary directory)
:param base_dir: the location of the parquet file that holds the data.
Not used if save_data is False.
Default current directory (".")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventStream:
    &#34;&#34;&#34;
    stores event stream data gathered from a single station.
    ALL timestamps in microseconds since epoch UTC unless otherwise stated
    &#34;&#34;&#34;
    def __init__(self, name: str = &#34;event&#34;,
                 schema: Optional[Dict[str, list]] = None,
                 save_mode: FileSystemSaveMode = FileSystemSaveMode.MEM,
                 base_dir: str = &#34;.&#34;):
        &#34;&#34;&#34;
        initialize EventStream for a station

        :param name: name of the EventStream.  Default &#34;event&#34;
        :param schema: a structured dictionary of the data table schema.  Dictionary must look like:
                    {&#34;string&#34;: [s_values], &#34;numeric&#34;: [n_values], &#34;boolean&#34;: [o_values], &#34;byte&#34;: [b_values]}
                    where [*_values] is a list of strings and can be empty.  Default None
        :param save_mode: FileSystemSaveMode that determines how data is saved.
                            Default FileSystemSaveMode.MEM (use RAM).  Other options are DISK (save to directory)
                            and TEMP (save to temporary directory)
        :param base_dir: the location of the parquet file that holds the data.  Not used if save_data is False.
                            Default current directory (&#34;.&#34;)
        &#34;&#34;&#34;
        self.name = name
        self.timestamps_metadata = {}
        self.metadata = {}

        self._errors = RedVoxExceptions(&#34;EventStream&#34;)
        self._is_timestamps_corrected = False
        self._fs_writer = Fsw(f&#34;event_{name}&#34;, &#34;parquet&#34;, base_dir, save_mode)
        self._data = None
        self._schema = {&#34;string&#34;: [], &#34;numeric&#34;: [], &#34;boolean&#34;: [], &#34;byte&#34;: []}
        if schema is not None:
            self.set_schema(schema)

    def as_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: EventStream as a dictionary
        &#34;&#34;&#34;
        return {
            &#34;name&#34;: self.name,
            &#34;metadata&#34;: self.metadata,
            &#34;timestamps_metadata&#34;: self.timestamps_metadata,
            &#34;is_timestamps_corrected&#34;: self._is_timestamps_corrected,
            &#34;schema&#34;: self._schema,
            &#34;file_path&#34;: self.full_path(),
            &#34;errors&#34;: self._errors.as_dict()
        }

    @staticmethod
    def __get_items(payload: Mapping[str]):
        return payload.get_metadata().items()

    @staticmethod
    def __get_items_raw(payload):
        return payload.items()

    @staticmethod
    def __get_keys(ptype: str, payload: Mapping[str]):
        return ptype, payload.get_metadata().keys()

    @staticmethod
    def __get_keys_raw(ptype: str, payload):
        return ptype, payload.keys()

    def __set_schema(self, name: str, value: str):
        self._schema[name].append(value)

    def _get_tbl_schema(self) -&gt; Dict[str, list]:
        &#34;&#34;&#34;
        :return: the dictionary used to create the EventStream data object
        &#34;&#34;&#34;
        if self._data:
            result = {}
            for f in self._data.schema.names:
                result[f] = []
        else:
            result = {&#34;timestamps&#34;: [], &#34;unaltered_timestamps&#34;: []}
            for t, s in self._schema.items():
                for k in s:
                    result[k] = []
        return result

    def read_events(self, eventstream: es.EventStream):
        &#34;&#34;&#34;
        read the payloads of each event in the eventstream and separate the data by payload type

        :param eventstream: stream of events to process
        &#34;&#34;&#34;
        self.name = eventstream.get_name()
        self._fs_writer.file_name = f&#34;event_{self.name}&#34;
        num_events = eventstream.get_events().get_count()
        if num_events &gt; 1:
            tbl = self._get_tbl_schema()
            self.timestamps_metadata = eventstream.get_timestamps().get_metadata()
            self.metadata = eventstream.get_metadata()
            first_event = eventstream.get_events().get_values()[0]
            for t, c in map(self.__get_keys, [&#34;string&#34;, &#34;numeric&#34;, &#34;boolean&#34;, &#34;byte&#34;],
                            [first_event.get_string_payload(), first_event.get_numeric_payload(),
                             first_event.get_boolean_payload(), first_event.get_byte_payload()]):
                for k in c:
                    self.add_to_schema(t, k)
                    tbl[k] = []
            for i in range(num_events):
                tbl[&#34;timestamps&#34;].append(eventstream.get_timestamps().get_timestamps()[i])
                tbl[&#34;unaltered_timestamps&#34;].append(eventstream.get_timestamps().get_timestamps()[i])
                evnt = eventstream.get_events().get_values()[i]
                for items in map(self.__get_items, [evnt.get_string_payload(), evnt.get_numeric_payload(),
                                                    evnt.get_boolean_payload(), evnt.get_byte_payload()]):
                    for c, st in items:
                        tbl[c].append(st)
            self._data = pa.Table.from_pydict(tbl)

    def read_raw(self, stream: RedvoxPacketM.EventStream) -&gt; &#39;EventStream&#39;:
        &#34;&#34;&#34;
        read the contents of a protobuf stream

        :param stream: the protobuf stream to read
        &#34;&#34;&#34;
        self.name = stream.name
        self._fs_writer.file_name = f&#34;event_{self.name}&#34;
        num_events = len(stream.events)
        if num_events &gt; 1:
            tbl = self._get_tbl_schema()
            self.timestamps_metadata = stream.timestamps.metadata
            self.metadata = stream.metadata
            first_event = stream.events[0]
            for t, c in map(EventStream.__get_keys_raw, [&#34;string&#34;, &#34;numeric&#34;, &#34;boolean&#34;, &#34;byte&#34;],
                            [first_event.string_payload, first_event.numeric_payload,
                             first_event.boolean_payload, first_event.byte_payload]):
                for k in c:
                    self.add_to_schema(t, k)
                    tbl[k] = []
            for i in range(num_events):
                tbl[&#34;timestamps&#34;].append(stream.timestamps.timestamps[i])
                tbl[&#34;unaltered_timestamps&#34;].append(stream.timestamps.timestamps[i])
                evnt = stream.events[i]
                for items in map(EventStream.__get_items_raw, [evnt.string_payload, evnt.numeric_payload,
                                                               evnt.boolean_payload, evnt.byte_payload]):
                    for c, st in items:
                        tbl[c].append(st)
            self._data = pa.Table.from_pydict(tbl)
        return self

    def read_from_dir(self, file: str):
        &#34;&#34;&#34;
        read a pyarrow table from a file on disk

        :param file: full path to the file to read
        &#34;&#34;&#34;
        try:
            tbl = pq.read_table(file)
            if tbl.schema.names == self._get_tbl_schema():
                self._data = tbl
        except FileNotFoundError:
            self._errors.append(&#34;No data file was found; this event is empty.&#34;)
            self._data = None

    def get_string_schema(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: the column names of string typed data as a list of strings
        &#34;&#34;&#34;
        return self._schema[&#34;string&#34;]

    def get_numeric_schema(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: the column names of numeric typed data as a list of strings
        &#34;&#34;&#34;
        return self._schema[&#34;numeric&#34;]

    def get_boolean_schema(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: the column names of boolean typed data as a list of strings
        &#34;&#34;&#34;
        return self._schema[&#34;boolean&#34;]

    def get_byte_schema(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: the column names of byte typed data as a list of strings
        &#34;&#34;&#34;
        return self._schema[&#34;byte&#34;]

    def get_schema(self) -&gt; dict:
        &#34;&#34;&#34;
        :return: the schema of the EventStream
        &#34;&#34;&#34;
        return self._schema

    def get_string_values(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the string data as a pyarrow table
        &#34;&#34;&#34;
        return self._data.select(self.get_string_schema()) if self._data else pa.Table.from_pydict({})

    def get_numeric_values(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the numeric data as a pyarrow table
        &#34;&#34;&#34;
        return self._data.select(self.get_numeric_schema()) if self._data else pa.Table.from_pydict({})

    def get_boolean_values(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the boolean data as a pyarrow table
        &#34;&#34;&#34;
        return self._data.select(self.get_boolean_schema()) if self._data else pa.Table.from_pydict({})

    def get_byte_values(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the byte data as a pyarrow table
        &#34;&#34;&#34;
        return self._data.select(self.get_byte_schema()) if self._data else pa.Table.from_pydict({})

    def _check_for_name(self, column_name: str, schema: List[str]) -&gt; bool:
        &#34;&#34;&#34;
        :param column_name: name of column to check for
        :param schema: list of allowed names
        :return: True if column_name is in schema, sets error and returns False if not
        &#34;&#34;&#34;
        if column_name not in schema:
            self._errors.append(f&#34;WARNING: Column {column_name} does not exist; try one of {schema}&#34;)
            return False
        return True

    def __get_column_data(self, schema: List[str], column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param schema: list of column names to search
        :param column_name: column name to get
        :return: the data as an np.array; if empty, column name or data doesn&#39;t exist
        &#34;&#34;&#34;
        return self._data[column_name].to_numpy() if self._check_for_name(column_name, schema) else np.array([])

    def get_string_column(self, column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param column_name: name of string payload to retrieve
        :return: string data from the column specified
        &#34;&#34;&#34;
        return self.__get_column_data(self.get_string_schema(), column_name)

    def get_numeric_column(self, column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param column_name: name of numeric payload to retrieve
        :return: numeric data from the column specified
        &#34;&#34;&#34;
        return self.__get_column_data(self.get_numeric_schema(), column_name)

    def get_boolean_column(self, column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param column_name: name of boolean payload to retrieve
        :return: boolean data from the column specified
        &#34;&#34;&#34;
        return self.__get_column_data(self.get_boolean_schema(), column_name)

    def get_byte_column(self, column_name: str) -&gt; np.array:
        &#34;&#34;&#34;
        :param column_name: name of byte payload to retrieve
        :return: bytes data from the column specified
        &#34;&#34;&#34;
        return self.__get_column_data(self.get_byte_schema(), column_name)

    def set_schema(self, schema: Dict[str, list]):
        &#34;&#34;&#34;
        sets the schema of the EventStream using a specially structured dictionary.
        Structure is:

        {&#34;string&#34;: [s_values], &#34;numeric&#34;: [n_values], &#34;boolean&#34;: [o_values], &#34;byte&#34;: [b_values]}

        where [*_values] is a list of strings and can be empty

        :param schema: specially structured dictionary of data table schema
        &#34;&#34;&#34;
        if schema.keys() != self._schema.keys():
            self._errors.append(f&#34;Attempted to add invalid schema with keys {list(schema.keys())} to EventStreams.\n&#34;
                                f&#34;Valid keys are: {list(self._schema.keys())}&#34;)
        else:
            self._schema = schema

    def add_to_schema(self, key: str, value: str):
        &#34;&#34;&#34;
        adds a value to the schema, under the specified key

        :param key: one of &#34;string&#34;, &#34;numeric&#34;, &#34;boolean&#34;, or &#34;byte&#34;
        :param value: the name of the column to add to the schema
        &#34;&#34;&#34;
        if key not in self._schema.keys():
            self._errors.append(&#34;Attempted to add an unknown key to the EventStream schema.\n&#34;
                                f&#34;You must use one of {self._schema.keys()}.&#34;)
        else:
            self._schema[key].append(value)

    def add(self, other_stream: es.EventStream):
        &#34;&#34;&#34;
        adds a Redvox Api1000 EventStream with the same name to the data

        :param other_stream: another EventStream with the same name
        &#34;&#34;&#34;
        if self.name != other_stream.get_name():
            self._errors.append(f&#34;Attempted to add a stream with a different name ({other_stream.get_name()})&#34;)
        else:
            self.timestamps_metadata = {**self.timestamps_metadata, **other_stream.get_timestamps().get_metadata()}
            self.metadata = {**self.metadata, **other_stream.get_metadata()}
            num_events = other_stream.get_events().get_count()
            if num_events &gt; 1:
                tbl = self._get_tbl_schema()
                for i in range(num_events):
                    tbl[&#34;timestamps&#34;].append(other_stream.get_timestamps().get_timestamps()[i])
                    tbl[&#34;unaltered_timestamps&#34;].append(other_stream.get_timestamps().get_timestamps()[i])
                    evnt = other_stream.get_events().get_values()[i]
                    for items in map(self.__get_items, [evnt.get_string_payload(), evnt.get_numeric_payload(),
                                                        evnt.get_boolean_payload(), evnt.get_byte_payload()]):
                        for c, st in items:
                            tbl[c].append(st)
                self._data = pa.concat_tables([self._data, pa.Table.from_pydict(tbl)])

    def add_raw(self, other_stream: RedvoxPacketM.EventStream):
        &#34;&#34;&#34;
        add a protobuf EventStream with the same name to the data

        :param other_stream: a protobuf EventStream to add
        &#34;&#34;&#34;
        if self.name != other_stream.name:
            self._errors.append(f&#34;Attempted to add a stream with a different name ({other_stream.name})&#34;)
        else:
            self.timestamps_metadata = {**self.timestamps_metadata, **other_stream.timestamps.metadata}
            self.metadata = {**self.metadata, **other_stream.metadata}
            num_events = len(other_stream.events)
            if num_events &gt; 1:
                tbl = self._get_tbl_schema()
                for i in range(num_events):
                    tbl[&#34;timestamps&#34;].append(other_stream.timestamps.timestamps[i])
                    tbl[&#34;unaltered_timestamps&#34;].append(other_stream.timestamps.timestamps[i])
                    evnt = other_stream.events[i]
                    for items in map(EventStream.__get_items_raw, [evnt.string_payload, evnt.numeric_payload,
                                                                   evnt.boolean_payload, evnt.byte_payload]):
                        for c, st in items:
                            tbl[c].append(st)
                self._data = pa.concat_tables([self._data, pa.Table.from_pydict(tbl)])

    def append(self, other_stream: &#34;EventStream&#34;):
        &#34;&#34;&#34;
        add another EventStream onto the calling one if they have the same name

        :param other_stream: other stream to add to current
        &#34;&#34;&#34;
        if other_stream.name == self.name:
            self._data = pa.concat_tables([self._data, other_stream._data])
            self.timestamps_metadata = {**self.timestamps_metadata, **other_stream.timestamps_metadata}
            self.metadata = {**self.metadata, **other_stream.metadata}
            self._errors.extend_error(other_stream.errors())

    def timestamps(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: the timestamps as a numpy array; returns empty array if no timestamps exist
        &#34;&#34;&#34;
        if &#34;timestamps&#34; in self.data().schema.names:
            return self.data()[&#34;timestamps&#34;].to_numpy()
        else:
            return np.array([])

    def unaltered_timestamps(self) -&gt; np.array:
        &#34;&#34;&#34;
        :return: the unaltered timestamps as a numpy array; returns empty array if no timestamps exist
        &#34;&#34;&#34;
        if &#34;unaltered_timestamps&#34; in self.data().schema.names:
            return self.data()[&#34;unaltered_timestamps&#34;].to_numpy()
        else:
            return np.array([])

    def update_timestamps(self, offset_model: om.OffsetModel, use_model_function: bool = False):
        &#34;&#34;&#34;
        updates the timestamps of the data points

        :param offset_model: model used to update the timestamps
        :param use_model_function: if True, use the model&#39;s slope function to update the timestamps.
                                    otherwise uses the best offset (model&#39;s intercept value).  Default False
        &#34;&#34;&#34;
        if self._data is not None and self._data.num_rows &gt; 0:
            timestamps = pa.array(offset_model.update_timestamps(self._data[&#34;timestamps&#34;].to_numpy(),
                                                                 use_model_function))
            self._data.set_column(0, &#34;timestamps&#34;, timestamps)

    def default_json_file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: default event stream json file name (event_[event.name]): note there is no extension
        &#34;&#34;&#34;
        return f&#34;event_{self.name}&#34;

    def is_save_to_disk(self) -&gt; bool:
        &#34;&#34;&#34;
        :return: True if sensor will be saved to disk
        &#34;&#34;&#34;
        return self._fs_writer.is_save_disk()

    def set_save_to_disk(self, save: bool):
        &#34;&#34;&#34;
        :param save: If True, save to disk
        &#34;&#34;&#34;
        self._fs_writer.save_to_disk = save

    def set_save_mode(self, save_mode: FileSystemSaveMode):
        &#34;&#34;&#34;
        set the save mode

        :param save_mode: new save mode
        &#34;&#34;&#34;
        self._fs_writer.set_save_mode(save_mode)

    def set_file_name(self, new_file: Optional[str] = None):
        &#34;&#34;&#34;
        * set the pyarrow file name or use the default: event_{EventStream.name}
        * Do not give an extension

        :param new_file: optional file name to change to; default None (use default name)
        &#34;&#34;&#34;
        self._fs_writer.file_name = new_file if new_file else f&#34;event_{self.name}&#34;

    def full_file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: full name of parquet file containing the data
        &#34;&#34;&#34;
        return self._fs_writer.full_name()

    def file_name(self) -&gt; str:
        &#34;&#34;&#34;
        :return: file name without extension
        &#34;&#34;&#34;
        return self._fs_writer.file_name

    def set_save_dir(self, new_dir: Optional[str] = None):
        &#34;&#34;&#34;
        set the pyarrow directory or use the default: &#34;.&#34; (current directory)

        :param new_dir: the directory to change to; default None (use current directory)
        &#34;&#34;&#34;
        self._fs_writer.base_dir = new_dir if new_dir else &#34;.&#34;

    def save_dir(self) -&gt; str:
        &#34;&#34;&#34;
        :return: directory containing parquet files for the sensor
        &#34;&#34;&#34;
        return self._fs_writer.save_dir()

    def full_path(self) -&gt; str:
        &#34;&#34;&#34;
        :return: the full path to the data file
        &#34;&#34;&#34;
        return self._fs_writer.full_path()

    def fs_writer(self) -&gt; Fsw:
        &#34;&#34;&#34;
        :return: FileSystemWriter object
        &#34;&#34;&#34;
        return self._fs_writer

    def write_table(self):
        &#34;&#34;&#34;
        writes the event stream data to disk.
        &#34;&#34;&#34;
        if self._data is not None:
            pq.write_table(self._data, self.full_path())

    def data(self) -&gt; pa.Table:
        &#34;&#34;&#34;
        :return: the data as a pyarrow table
        &#34;&#34;&#34;
        if self._data is None:
            if self.is_save_to_disk():
                self._data = pq.read_table(self.full_path())
            else:
                return pa.Table.from_pydict({})
        return self._data

    @staticmethod
    def from_json_file(file_dir: str, file_name: str) -&gt; &#34;EventStream&#34;:
        &#34;&#34;&#34;
        :param file_dir: full path to containing directory for the file
        :param file_name: name of file and extension to load data from
        :return: EventStream from json file
        &#34;&#34;&#34;
        if file_name is None:
            file_name = io.get_json_file(file_dir)
            if file_name is None:
                result = EventStream(&#34;Empty&#34;)
                result.append_error(&#34;JSON file to load EventStream from not found.&#34;)
                return result
        json_data = io.json_file_to_dict(os.path.join(file_dir, f&#34;{file_name}.json&#34;))
        if &#34;name&#34; in json_data.keys():
            result = EventStream(json_data[&#34;name&#34;], json_data[&#34;schema&#34;], FileSystemSaveMode.DISK, file_dir)
            result.metadata = json_data[&#34;metadata&#34;]
            result.timestamps_metadata = json_data[&#34;timestamps_metadata&#34;]
            result.set_errors(RedVoxExceptions.from_dict(json_data[&#34;errors&#34;]))
            result.read_from_dir(json_data[&#34;file_path&#34;])
        else:
            result = EventStream(&#34;Empty&#34;)
            result.append_error(f&#34;Loading from {file_name} failed; missing EventStream name.&#34;)
        return result

    def to_json_file(self, file_name: Optional[str] = None) -&gt; Path:
        &#34;&#34;&#34;
        saves the EventStream as a json file

        :param file_name: the optional base file name.  Do not include a file extension.
                            If None, a default file name is created using this format:
                            event_[event.name].json
        :return: path to json file
        &#34;&#34;&#34;
        if self._fs_writer.file_extension == &#34;parquet&#34; and self._data is not None:
            self.write_table()
        return io.to_json_file(self, file_name)

    def errors(self) -&gt; RedVoxExceptions:
        &#34;&#34;&#34;
        :return: errors of the sensor
        &#34;&#34;&#34;
        return self._errors

    def set_errors(self, errors: RedVoxExceptions):
        &#34;&#34;&#34;
        sets the errors of the Sensor

        :param errors: errors to set
        &#34;&#34;&#34;
        self._errors = errors

    def append_error(self, error: str):
        &#34;&#34;&#34;
        add an error to the Sensor

        :param error: error to add
        &#34;&#34;&#34;
        self._errors.append(error)

    def print_errors(self):
        &#34;&#34;&#34;
        print all errors to screen
        &#34;&#34;&#34;
        self._errors.print()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.event_stream.EventStream.from_json_file"><code class="name flex">
<span>def <span class="ident">from_json_file</span></span>(<span>file_dir: str, file_name: str) ‑> <a title="redvox.common.event_stream.EventStream" href="#redvox.common.event_stream.EventStream">EventStream</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param file_dir: full path to containing directory for the file
:param file_name: name of file and extension to load data from
:return: EventStream from json file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json_file(file_dir: str, file_name: str) -&gt; &#34;EventStream&#34;:
    &#34;&#34;&#34;
    :param file_dir: full path to containing directory for the file
    :param file_name: name of file and extension to load data from
    :return: EventStream from json file
    &#34;&#34;&#34;
    if file_name is None:
        file_name = io.get_json_file(file_dir)
        if file_name is None:
            result = EventStream(&#34;Empty&#34;)
            result.append_error(&#34;JSON file to load EventStream from not found.&#34;)
            return result
    json_data = io.json_file_to_dict(os.path.join(file_dir, f&#34;{file_name}.json&#34;))
    if &#34;name&#34; in json_data.keys():
        result = EventStream(json_data[&#34;name&#34;], json_data[&#34;schema&#34;], FileSystemSaveMode.DISK, file_dir)
        result.metadata = json_data[&#34;metadata&#34;]
        result.timestamps_metadata = json_data[&#34;timestamps_metadata&#34;]
        result.set_errors(RedVoxExceptions.from_dict(json_data[&#34;errors&#34;]))
        result.read_from_dir(json_data[&#34;file_path&#34;])
    else:
        result = EventStream(&#34;Empty&#34;)
        result.append_error(f&#34;Loading from {file_name} failed; missing EventStream name.&#34;)
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.event_stream.EventStream.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, other_stream: <a title="redvox.api1000.wrapped_redvox_packet.event_streams.EventStream" href="../api1000/wrapped_redvox_packet/event_streams.html#redvox.api1000.wrapped_redvox_packet.event_streams.EventStream">EventStream</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a Redvox Api1000 EventStream with the same name to the data</p>
<p>:param other_stream: another EventStream with the same name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, other_stream: es.EventStream):
    &#34;&#34;&#34;
    adds a Redvox Api1000 EventStream with the same name to the data

    :param other_stream: another EventStream with the same name
    &#34;&#34;&#34;
    if self.name != other_stream.get_name():
        self._errors.append(f&#34;Attempted to add a stream with a different name ({other_stream.get_name()})&#34;)
    else:
        self.timestamps_metadata = {**self.timestamps_metadata, **other_stream.get_timestamps().get_metadata()}
        self.metadata = {**self.metadata, **other_stream.get_metadata()}
        num_events = other_stream.get_events().get_count()
        if num_events &gt; 1:
            tbl = self._get_tbl_schema()
            for i in range(num_events):
                tbl[&#34;timestamps&#34;].append(other_stream.get_timestamps().get_timestamps()[i])
                tbl[&#34;unaltered_timestamps&#34;].append(other_stream.get_timestamps().get_timestamps()[i])
                evnt = other_stream.get_events().get_values()[i]
                for items in map(self.__get_items, [evnt.get_string_payload(), evnt.get_numeric_payload(),
                                                    evnt.get_boolean_payload(), evnt.get_byte_payload()]):
                    for c, st in items:
                        tbl[c].append(st)
            self._data = pa.concat_tables([self._data, pa.Table.from_pydict(tbl)])</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.add_raw"><code class="name flex">
<span>def <span class="ident">add_raw</span></span>(<span>self, other_stream: src.redvox_api_m.redvox_api_m_pb2.EventStream)</span>
</code></dt>
<dd>
<div class="desc"><p>add a protobuf EventStream with the same name to the data</p>
<p>:param other_stream: a protobuf EventStream to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_raw(self, other_stream: RedvoxPacketM.EventStream):
    &#34;&#34;&#34;
    add a protobuf EventStream with the same name to the data

    :param other_stream: a protobuf EventStream to add
    &#34;&#34;&#34;
    if self.name != other_stream.name:
        self._errors.append(f&#34;Attempted to add a stream with a different name ({other_stream.name})&#34;)
    else:
        self.timestamps_metadata = {**self.timestamps_metadata, **other_stream.timestamps.metadata}
        self.metadata = {**self.metadata, **other_stream.metadata}
        num_events = len(other_stream.events)
        if num_events &gt; 1:
            tbl = self._get_tbl_schema()
            for i in range(num_events):
                tbl[&#34;timestamps&#34;].append(other_stream.timestamps.timestamps[i])
                tbl[&#34;unaltered_timestamps&#34;].append(other_stream.timestamps.timestamps[i])
                evnt = other_stream.events[i]
                for items in map(EventStream.__get_items_raw, [evnt.string_payload, evnt.numeric_payload,
                                                               evnt.boolean_payload, evnt.byte_payload]):
                    for c, st in items:
                        tbl[c].append(st)
            self._data = pa.concat_tables([self._data, pa.Table.from_pydict(tbl)])</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.add_to_schema"><code class="name flex">
<span>def <span class="ident">add_to_schema</span></span>(<span>self, key: str, value: str)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a value to the schema, under the specified key</p>
<p>:param key: one of "string", "numeric", "boolean", or "byte"
:param value: the name of the column to add to the schema</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_schema(self, key: str, value: str):
    &#34;&#34;&#34;
    adds a value to the schema, under the specified key

    :param key: one of &#34;string&#34;, &#34;numeric&#34;, &#34;boolean&#34;, or &#34;byte&#34;
    :param value: the name of the column to add to the schema
    &#34;&#34;&#34;
    if key not in self._schema.keys():
        self._errors.append(&#34;Attempted to add an unknown key to the EventStream schema.\n&#34;
                            f&#34;You must use one of {self._schema.keys()}.&#34;)
    else:
        self._schema[key].append(value)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, other_stream: <a title="redvox.common.event_stream.EventStream" href="#redvox.common.event_stream.EventStream">EventStream</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>add another EventStream onto the calling one if they have the same name</p>
<p>:param other_stream: other stream to add to current</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, other_stream: &#34;EventStream&#34;):
    &#34;&#34;&#34;
    add another EventStream onto the calling one if they have the same name

    :param other_stream: other stream to add to current
    &#34;&#34;&#34;
    if other_stream.name == self.name:
        self._data = pa.concat_tables([self._data, other_stream._data])
        self.timestamps_metadata = {**self.timestamps_metadata, **other_stream.timestamps_metadata}
        self.metadata = {**self.metadata, **other_stream.metadata}
        self._errors.extend_error(other_stream.errors())</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.append_error"><code class="name flex">
<span>def <span class="ident">append_error</span></span>(<span>self, error: str)</span>
</code></dt>
<dd>
<div class="desc"><p>add an error to the Sensor</p>
<p>:param error: error to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_error(self, error: str):
    &#34;&#34;&#34;
    add an error to the Sensor

    :param error: error to add
    &#34;&#34;&#34;
    self._errors.append(error)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>:return: EventStream as a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    :return: EventStream as a dictionary
    &#34;&#34;&#34;
    return {
        &#34;name&#34;: self.name,
        &#34;metadata&#34;: self.metadata,
        &#34;timestamps_metadata&#34;: self.timestamps_metadata,
        &#34;is_timestamps_corrected&#34;: self._is_timestamps_corrected,
        &#34;schema&#34;: self._schema,
        &#34;file_path&#34;: self.full_path(),
        &#34;errors&#34;: self._errors.as_dict()
    }</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the data as a pyarrow table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self) -&gt; pa.Table:
    &#34;&#34;&#34;
    :return: the data as a pyarrow table
    &#34;&#34;&#34;
    if self._data is None:
        if self.is_save_to_disk():
            self._data = pq.read_table(self.full_path())
        else:
            return pa.Table.from_pydict({})
    return self._data</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.default_json_file_name"><code class="name flex">
<span>def <span class="ident">default_json_file_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: default event stream json file name (event_[event.name]): note there is no extension</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_json_file_name(self) -&gt; str:
    &#34;&#34;&#34;
    :return: default event stream json file name (event_[event.name]): note there is no extension
    &#34;&#34;&#34;
    return f&#34;event_{self.name}&#34;</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.errors"><code class="name flex">
<span>def <span class="ident">errors</span></span>(<span>self) ‑> <a title="redvox.common.errors.RedVoxExceptions" href="errors.html#redvox.common.errors.RedVoxExceptions">RedVoxExceptions</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: errors of the sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def errors(self) -&gt; RedVoxExceptions:
    &#34;&#34;&#34;
    :return: errors of the sensor
    &#34;&#34;&#34;
    return self._errors</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.file_name"><code class="name flex">
<span>def <span class="ident">file_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: file name without extension</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_name(self) -&gt; str:
    &#34;&#34;&#34;
    :return: file name without extension
    &#34;&#34;&#34;
    return self._fs_writer.file_name</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.fs_writer"><code class="name flex">
<span>def <span class="ident">fs_writer</span></span>(<span>self) ‑> <a title="redvox.common.io.FileSystemWriter" href="io.html#redvox.common.io.FileSystemWriter">FileSystemWriter</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: FileSystemWriter object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fs_writer(self) -&gt; Fsw:
    &#34;&#34;&#34;
    :return: FileSystemWriter object
    &#34;&#34;&#34;
    return self._fs_writer</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.full_file_name"><code class="name flex">
<span>def <span class="ident">full_file_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: full name of parquet file containing the data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full_file_name(self) -&gt; str:
    &#34;&#34;&#34;
    :return: full name of parquet file containing the data
    &#34;&#34;&#34;
    return self._fs_writer.full_name()</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.full_path"><code class="name flex">
<span>def <span class="ident">full_path</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the full path to the data file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full_path(self) -&gt; str:
    &#34;&#34;&#34;
    :return: the full path to the data file
    &#34;&#34;&#34;
    return self._fs_writer.full_path()</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_boolean_column"><code class="name flex">
<span>def <span class="ident">get_boolean_column</span></span>(<span>self, column_name: str) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:param column_name: name of boolean payload to retrieve
:return: boolean data from the column specified</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_boolean_column(self, column_name: str) -&gt; np.array:
    &#34;&#34;&#34;
    :param column_name: name of boolean payload to retrieve
    :return: boolean data from the column specified
    &#34;&#34;&#34;
    return self.__get_column_data(self.get_boolean_schema(), column_name)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_boolean_schema"><code class="name flex">
<span>def <span class="ident">get_boolean_schema</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the column names of boolean typed data as a list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_boolean_schema(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: the column names of boolean typed data as a list of strings
    &#34;&#34;&#34;
    return self._schema[&#34;boolean&#34;]</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_boolean_values"><code class="name flex">
<span>def <span class="ident">get_boolean_values</span></span>(<span>self) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the boolean data as a pyarrow table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_boolean_values(self) -&gt; pa.Table:
    &#34;&#34;&#34;
    :return: the boolean data as a pyarrow table
    &#34;&#34;&#34;
    return self._data.select(self.get_boolean_schema()) if self._data else pa.Table.from_pydict({})</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_byte_column"><code class="name flex">
<span>def <span class="ident">get_byte_column</span></span>(<span>self, column_name: str) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:param column_name: name of byte payload to retrieve
:return: bytes data from the column specified</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_byte_column(self, column_name: str) -&gt; np.array:
    &#34;&#34;&#34;
    :param column_name: name of byte payload to retrieve
    :return: bytes data from the column specified
    &#34;&#34;&#34;
    return self.__get_column_data(self.get_byte_schema(), column_name)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_byte_schema"><code class="name flex">
<span>def <span class="ident">get_byte_schema</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the column names of byte typed data as a list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_byte_schema(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: the column names of byte typed data as a list of strings
    &#34;&#34;&#34;
    return self._schema[&#34;byte&#34;]</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_byte_values"><code class="name flex">
<span>def <span class="ident">get_byte_values</span></span>(<span>self) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the byte data as a pyarrow table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_byte_values(self) -&gt; pa.Table:
    &#34;&#34;&#34;
    :return: the byte data as a pyarrow table
    &#34;&#34;&#34;
    return self._data.select(self.get_byte_schema()) if self._data else pa.Table.from_pydict({})</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_numeric_column"><code class="name flex">
<span>def <span class="ident">get_numeric_column</span></span>(<span>self, column_name: str) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:param column_name: name of numeric payload to retrieve
:return: numeric data from the column specified</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_numeric_column(self, column_name: str) -&gt; np.array:
    &#34;&#34;&#34;
    :param column_name: name of numeric payload to retrieve
    :return: numeric data from the column specified
    &#34;&#34;&#34;
    return self.__get_column_data(self.get_numeric_schema(), column_name)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_numeric_schema"><code class="name flex">
<span>def <span class="ident">get_numeric_schema</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the column names of numeric typed data as a list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_numeric_schema(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: the column names of numeric typed data as a list of strings
    &#34;&#34;&#34;
    return self._schema[&#34;numeric&#34;]</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_numeric_values"><code class="name flex">
<span>def <span class="ident">get_numeric_values</span></span>(<span>self) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the numeric data as a pyarrow table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_numeric_values(self) -&gt; pa.Table:
    &#34;&#34;&#34;
    :return: the numeric data as a pyarrow table
    &#34;&#34;&#34;
    return self._data.select(self.get_numeric_schema()) if self._data else pa.Table.from_pydict({})</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_schema"><code class="name flex">
<span>def <span class="ident">get_schema</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the schema of the EventStream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_schema(self) -&gt; dict:
    &#34;&#34;&#34;
    :return: the schema of the EventStream
    &#34;&#34;&#34;
    return self._schema</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_string_column"><code class="name flex">
<span>def <span class="ident">get_string_column</span></span>(<span>self, column_name: str) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:param column_name: name of string payload to retrieve
:return: string data from the column specified</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string_column(self, column_name: str) -&gt; np.array:
    &#34;&#34;&#34;
    :param column_name: name of string payload to retrieve
    :return: string data from the column specified
    &#34;&#34;&#34;
    return self.__get_column_data(self.get_string_schema(), column_name)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_string_schema"><code class="name flex">
<span>def <span class="ident">get_string_schema</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the column names of string typed data as a list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string_schema(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: the column names of string typed data as a list of strings
    &#34;&#34;&#34;
    return self._schema[&#34;string&#34;]</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.get_string_values"><code class="name flex">
<span>def <span class="ident">get_string_values</span></span>(<span>self) ‑> pyarrow.lib.Table</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the string data as a pyarrow table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string_values(self) -&gt; pa.Table:
    &#34;&#34;&#34;
    :return: the string data as a pyarrow table
    &#34;&#34;&#34;
    return self._data.select(self.get_string_schema()) if self._data else pa.Table.from_pydict({})</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.is_save_to_disk"><code class="name flex">
<span>def <span class="ident">is_save_to_disk</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>:return: True if sensor will be saved to disk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_save_to_disk(self) -&gt; bool:
    &#34;&#34;&#34;
    :return: True if sensor will be saved to disk
    &#34;&#34;&#34;
    return self._fs_writer.is_save_disk()</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.print_errors"><code class="name flex">
<span>def <span class="ident">print_errors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>print all errors to screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_errors(self):
    &#34;&#34;&#34;
    print all errors to screen
    &#34;&#34;&#34;
    self._errors.print()</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.read_events"><code class="name flex">
<span>def <span class="ident">read_events</span></span>(<span>self, eventstream: <a title="redvox.api1000.wrapped_redvox_packet.event_streams.EventStream" href="../api1000/wrapped_redvox_packet/event_streams.html#redvox.api1000.wrapped_redvox_packet.event_streams.EventStream">EventStream</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>read the payloads of each event in the eventstream and separate the data by payload type</p>
<p>:param eventstream: stream of events to process</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_events(self, eventstream: es.EventStream):
    &#34;&#34;&#34;
    read the payloads of each event in the eventstream and separate the data by payload type

    :param eventstream: stream of events to process
    &#34;&#34;&#34;
    self.name = eventstream.get_name()
    self._fs_writer.file_name = f&#34;event_{self.name}&#34;
    num_events = eventstream.get_events().get_count()
    if num_events &gt; 1:
        tbl = self._get_tbl_schema()
        self.timestamps_metadata = eventstream.get_timestamps().get_metadata()
        self.metadata = eventstream.get_metadata()
        first_event = eventstream.get_events().get_values()[0]
        for t, c in map(self.__get_keys, [&#34;string&#34;, &#34;numeric&#34;, &#34;boolean&#34;, &#34;byte&#34;],
                        [first_event.get_string_payload(), first_event.get_numeric_payload(),
                         first_event.get_boolean_payload(), first_event.get_byte_payload()]):
            for k in c:
                self.add_to_schema(t, k)
                tbl[k] = []
        for i in range(num_events):
            tbl[&#34;timestamps&#34;].append(eventstream.get_timestamps().get_timestamps()[i])
            tbl[&#34;unaltered_timestamps&#34;].append(eventstream.get_timestamps().get_timestamps()[i])
            evnt = eventstream.get_events().get_values()[i]
            for items in map(self.__get_items, [evnt.get_string_payload(), evnt.get_numeric_payload(),
                                                evnt.get_boolean_payload(), evnt.get_byte_payload()]):
                for c, st in items:
                    tbl[c].append(st)
        self._data = pa.Table.from_pydict(tbl)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.read_from_dir"><code class="name flex">
<span>def <span class="ident">read_from_dir</span></span>(<span>self, file: str)</span>
</code></dt>
<dd>
<div class="desc"><p>read a pyarrow table from a file on disk</p>
<p>:param file: full path to the file to read</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_from_dir(self, file: str):
    &#34;&#34;&#34;
    read a pyarrow table from a file on disk

    :param file: full path to the file to read
    &#34;&#34;&#34;
    try:
        tbl = pq.read_table(file)
        if tbl.schema.names == self._get_tbl_schema():
            self._data = tbl
    except FileNotFoundError:
        self._errors.append(&#34;No data file was found; this event is empty.&#34;)
        self._data = None</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.read_raw"><code class="name flex">
<span>def <span class="ident">read_raw</span></span>(<span>self, stream: src.redvox_api_m.redvox_api_m_pb2.EventStream) ‑> <a title="redvox.common.event_stream.EventStream" href="#redvox.common.event_stream.EventStream">EventStream</a></span>
</code></dt>
<dd>
<div class="desc"><p>read the contents of a protobuf stream</p>
<p>:param stream: the protobuf stream to read</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_raw(self, stream: RedvoxPacketM.EventStream) -&gt; &#39;EventStream&#39;:
    &#34;&#34;&#34;
    read the contents of a protobuf stream

    :param stream: the protobuf stream to read
    &#34;&#34;&#34;
    self.name = stream.name
    self._fs_writer.file_name = f&#34;event_{self.name}&#34;
    num_events = len(stream.events)
    if num_events &gt; 1:
        tbl = self._get_tbl_schema()
        self.timestamps_metadata = stream.timestamps.metadata
        self.metadata = stream.metadata
        first_event = stream.events[0]
        for t, c in map(EventStream.__get_keys_raw, [&#34;string&#34;, &#34;numeric&#34;, &#34;boolean&#34;, &#34;byte&#34;],
                        [first_event.string_payload, first_event.numeric_payload,
                         first_event.boolean_payload, first_event.byte_payload]):
            for k in c:
                self.add_to_schema(t, k)
                tbl[k] = []
        for i in range(num_events):
            tbl[&#34;timestamps&#34;].append(stream.timestamps.timestamps[i])
            tbl[&#34;unaltered_timestamps&#34;].append(stream.timestamps.timestamps[i])
            evnt = stream.events[i]
            for items in map(EventStream.__get_items_raw, [evnt.string_payload, evnt.numeric_payload,
                                                           evnt.boolean_payload, evnt.byte_payload]):
                for c, st in items:
                    tbl[c].append(st)
        self._data = pa.Table.from_pydict(tbl)
    return self</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.save_dir"><code class="name flex">
<span>def <span class="ident">save_dir</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>:return: directory containing parquet files for the sensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_dir(self) -&gt; str:
    &#34;&#34;&#34;
    :return: directory containing parquet files for the sensor
    &#34;&#34;&#34;
    return self._fs_writer.save_dir()</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.set_errors"><code class="name flex">
<span>def <span class="ident">set_errors</span></span>(<span>self, errors: <a title="redvox.common.errors.RedVoxExceptions" href="errors.html#redvox.common.errors.RedVoxExceptions">RedVoxExceptions</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>sets the errors of the Sensor</p>
<p>:param errors: errors to set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_errors(self, errors: RedVoxExceptions):
    &#34;&#34;&#34;
    sets the errors of the Sensor

    :param errors: errors to set
    &#34;&#34;&#34;
    self._errors = errors</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.set_file_name"><code class="name flex">
<span>def <span class="ident">set_file_name</span></span>(<span>self, new_file: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>set the pyarrow file name or use the default: event_{EventStream.name}</li>
<li>Do not give an extension</li>
</ul>
<p>:param new_file: optional file name to change to; default None (use default name)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_file_name(self, new_file: Optional[str] = None):
    &#34;&#34;&#34;
    * set the pyarrow file name or use the default: event_{EventStream.name}
    * Do not give an extension

    :param new_file: optional file name to change to; default None (use default name)
    &#34;&#34;&#34;
    self._fs_writer.file_name = new_file if new_file else f&#34;event_{self.name}&#34;</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.set_save_dir"><code class="name flex">
<span>def <span class="ident">set_save_dir</span></span>(<span>self, new_dir: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>set the pyarrow directory or use the default: "." (current directory)</p>
<p>:param new_dir: the directory to change to; default None (use current directory)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_save_dir(self, new_dir: Optional[str] = None):
    &#34;&#34;&#34;
    set the pyarrow directory or use the default: &#34;.&#34; (current directory)

    :param new_dir: the directory to change to; default None (use current directory)
    &#34;&#34;&#34;
    self._fs_writer.base_dir = new_dir if new_dir else &#34;.&#34;</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.set_save_mode"><code class="name flex">
<span>def <span class="ident">set_save_mode</span></span>(<span>self, save_mode: <a title="redvox.common.io.FileSystemSaveMode" href="io.html#redvox.common.io.FileSystemSaveMode">FileSystemSaveMode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>set the save mode</p>
<p>:param save_mode: new save mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_save_mode(self, save_mode: FileSystemSaveMode):
    &#34;&#34;&#34;
    set the save mode

    :param save_mode: new save mode
    &#34;&#34;&#34;
    self._fs_writer.set_save_mode(save_mode)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.set_save_to_disk"><code class="name flex">
<span>def <span class="ident">set_save_to_disk</span></span>(<span>self, save: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>:param save: If True, save to disk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_save_to_disk(self, save: bool):
    &#34;&#34;&#34;
    :param save: If True, save to disk
    &#34;&#34;&#34;
    self._fs_writer.save_to_disk = save</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.set_schema"><code class="name flex">
<span>def <span class="ident">set_schema</span></span>(<span>self, schema: Dict[str, list])</span>
</code></dt>
<dd>
<div class="desc"><p>sets the schema of the EventStream using a specially structured dictionary.
Structure is:</p>
<p>{"string": [s_values], "numeric": [n_values], "boolean": [o_values], "byte": [b_values]}</p>
<p>where [*_values] is a list of strings and can be empty</p>
<p>:param schema: specially structured dictionary of data table schema</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_schema(self, schema: Dict[str, list]):
    &#34;&#34;&#34;
    sets the schema of the EventStream using a specially structured dictionary.
    Structure is:

    {&#34;string&#34;: [s_values], &#34;numeric&#34;: [n_values], &#34;boolean&#34;: [o_values], &#34;byte&#34;: [b_values]}

    where [*_values] is a list of strings and can be empty

    :param schema: specially structured dictionary of data table schema
    &#34;&#34;&#34;
    if schema.keys() != self._schema.keys():
        self._errors.append(f&#34;Attempted to add invalid schema with keys {list(schema.keys())} to EventStreams.\n&#34;
                            f&#34;Valid keys are: {list(self._schema.keys())}&#34;)
    else:
        self._schema = schema</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.timestamps"><code class="name flex">
<span>def <span class="ident">timestamps</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: the timestamps as a numpy array; returns empty array if no timestamps exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timestamps(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: the timestamps as a numpy array; returns empty array if no timestamps exist
    &#34;&#34;&#34;
    if &#34;timestamps&#34; in self.data().schema.names:
        return self.data()[&#34;timestamps&#34;].to_numpy()
    else:
        return np.array([])</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.to_json_file"><code class="name flex">
<span>def <span class="ident">to_json_file</span></span>(<span>self, file_name: Optional[str] = None) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>saves the EventStream as a json file</p>
<p>:param file_name: the optional base file name.
Do not include a file extension.
If None, a default file name is created using this format:
event_[event.name].json
:return: path to json file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json_file(self, file_name: Optional[str] = None) -&gt; Path:
    &#34;&#34;&#34;
    saves the EventStream as a json file

    :param file_name: the optional base file name.  Do not include a file extension.
                        If None, a default file name is created using this format:
                        event_[event.name].json
    :return: path to json file
    &#34;&#34;&#34;
    if self._fs_writer.file_extension == &#34;parquet&#34; and self._data is not None:
        self.write_table()
    return io.to_json_file(self, file_name)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.unaltered_timestamps"><code class="name flex">
<span>def <span class="ident">unaltered_timestamps</span></span>(<span>self) ‑> <built-in function array></span>
</code></dt>
<dd>
<div class="desc"><p>:return: the unaltered timestamps as a numpy array; returns empty array if no timestamps exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unaltered_timestamps(self) -&gt; np.array:
    &#34;&#34;&#34;
    :return: the unaltered timestamps as a numpy array; returns empty array if no timestamps exist
    &#34;&#34;&#34;
    if &#34;unaltered_timestamps&#34; in self.data().schema.names:
        return self.data()[&#34;unaltered_timestamps&#34;].to_numpy()
    else:
        return np.array([])</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.update_timestamps"><code class="name flex">
<span>def <span class="ident">update_timestamps</span></span>(<span>self, offset_model: <a title="redvox.common.offset_model.OffsetModel" href="offset_model.html#redvox.common.offset_model.OffsetModel">OffsetModel</a>, use_model_function: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>updates the timestamps of the data points</p>
<p>:param offset_model: model used to update the timestamps
:param use_model_function: if True, use the model's slope function to update the timestamps.
otherwise uses the best offset (model's intercept value).
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_timestamps(self, offset_model: om.OffsetModel, use_model_function: bool = False):
    &#34;&#34;&#34;
    updates the timestamps of the data points

    :param offset_model: model used to update the timestamps
    :param use_model_function: if True, use the model&#39;s slope function to update the timestamps.
                                otherwise uses the best offset (model&#39;s intercept value).  Default False
    &#34;&#34;&#34;
    if self._data is not None and self._data.num_rows &gt; 0:
        timestamps = pa.array(offset_model.update_timestamps(self._data[&#34;timestamps&#34;].to_numpy(),
                                                             use_model_function))
        self._data.set_column(0, &#34;timestamps&#34;, timestamps)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStream.write_table"><code class="name flex">
<span>def <span class="ident">write_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>writes the event stream data to disk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_table(self):
    &#34;&#34;&#34;
    writes the event stream data to disk.
    &#34;&#34;&#34;
    if self._data is not None:
        pq.write_table(self._data, self.full_path())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.event_stream.EventStreams"><code class="flex name class">
<span>class <span class="ident">EventStreams</span></span>
<span>(</span><span>streams: List[<a title="redvox.common.event_stream.EventStream" href="#redvox.common.event_stream.EventStream">EventStream</a>] = &lt;factory&gt;, save_mode: <a title="redvox.common.io.FileSystemSaveMode" href="io.html#redvox.common.io.FileSystemSaveMode">FileSystemSaveMode</a> = FileSystemSaveMode.MEM, base_dir: str = '.', debug: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>stores multiple event streams per station
ALL timestamps in microseconds since epoch UTC unless otherwise stated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_json
@dataclass
class EventStreams:
    &#34;&#34;&#34;
    stores multiple event streams per station
    ALL timestamps in microseconds since epoch UTC unless otherwise stated
    &#34;&#34;&#34;
    streams: List[EventStream] = field(default_factory=lambda: [])
    save_mode: FileSystemSaveMode = FileSystemSaveMode.MEM
    base_dir: str = &#34;.&#34;
    debug: bool = False

    def list_for_dict(self) -&gt; list:
        &#34;&#34;&#34;
        :return: the name of files that store event streams
        &#34;&#34;&#34;
        return [s.file_name() for s in self.streams]

    def read_from_packet(self, packet: RedvoxPacketM):
        &#34;&#34;&#34;
        read the eventstream payload from a single Redvox Api1000 packet

        :param packet: packet to read data from
        &#34;&#34;&#34;
        for st in packet.event_streams:
            if st.name in self.get_stream_names():
                self.get_stream(st.name).add_raw(st)
            else:
                self.streams.append(EventStream(save_mode=self.save_mode, base_dir=self.base_dir).read_raw(st))

    def read_from_packets_list(self, packets: List[RedvoxPacketM]):
        &#34;&#34;&#34;
        read the eventstream payload from multiple Redvox Api1000 packets

        :param packets: packets to read data from
        &#34;&#34;&#34;
        for p in packets:
            if type(p) == RedvoxPacketM:
                self.read_from_packet(p)

    def append(self, other_stream: EventStream):
        &#34;&#34;&#34;
        append another EventStream to an existing EventStream or add to the list of EventStream

        :param other_stream: other EventStream to add
        &#34;&#34;&#34;
        if other_stream.name in self.get_stream_names():
            self.get_stream(other_stream.name).append(other_stream)
        else:
            self.streams.append(other_stream)

    def append_streams(self, other_streams: &#34;EventStreams&#34;):
        &#34;&#34;&#34;
        append another EventStreams object to an existing EventStreams object

        :param other_streams: EventStreams to add
        &#34;&#34;&#34;
        for s in other_streams.streams:
            self.append(s)

    def get_stream(self, stream_name: str) -&gt; Optional[EventStream]:
        &#34;&#34;&#34;
        :param stream_name: name of event stream to get
        :return: the EventStream that has the name specified or None if it doesn&#39;t exist
        &#34;&#34;&#34;
        for s in self.streams:
            if s.name == stream_name:
                return s
        if self.debug:
            print(f&#34;{stream_name} does not exist in streams.  Use one of {[self.get_stream_names()]}&#34;)
        return None

    def get_stream_names(self) -&gt; List[str]:
        &#34;&#34;&#34;
        :return: names of all streams
        &#34;&#34;&#34;
        return [s.name for s in self.streams]

    def save_streams(self):
        &#34;&#34;&#34;
        saves all streams to disk

        note: use the function set_save_dir() to change where events are saved
        &#34;&#34;&#34;
        for s in self.streams:
            s.to_json_file()

    def set_save_dir(self, new_dir: str):
        &#34;&#34;&#34;
        change the directory where events are saved to

        :param new_dir: new directory path
        &#34;&#34;&#34;
        self.base_dir = new_dir
        for s in self.streams:
            s.set_save_dir(new_dir)

    def set_save_mode(self, new_save_mode: FileSystemSaveMode):
        &#34;&#34;&#34;
        update the save mode for all EventStream

        :param new_save_mode: save mode to set
        &#34;&#34;&#34;
        for s in self.streams:
            s.set_save_mode(new_save_mode)

    def update_timestamps(self, offset_model: om.OffsetModel, use_model_function: bool = False):
        &#34;&#34;&#34;
        update the timestamps in the data

        :param offset_model: model used to update the timestamps
        :param use_model_function: if True, use the model&#39;s slope function to update the timestamps.
                                    otherwise uses the best offset (model&#39;s intercept value).  Default False
        &#34;&#34;&#34;
        for evnt in self.streams:
            evnt.update_timestamps(offset_model, use_model_function)

    @staticmethod
    def from_dir(base_dir: str, file_names: List[str]) -&gt; &#34;EventStreams&#34;:
        &#34;&#34;&#34;
        :param base_dir: directory containing EventStream files
        :param file_names: the names of .json files containing EventStream data

        :return: EventStreams object from a directory
        &#34;&#34;&#34;
        return EventStreams([EventStream.from_json_file(base_dir, e) for e in file_names],
                            save_mode=FileSystemSaveMode.DISK, base_dir=base_dir)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.event_stream.EventStreams.base_dir"><code class="name">var <span class="ident">base_dir</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.EventStreams.debug"><code class="name">var <span class="ident">debug</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.EventStreams.save_mode"><code class="name">var <span class="ident">save_mode</span> : <a title="redvox.common.io.FileSystemSaveMode" href="io.html#redvox.common.io.FileSystemSaveMode">FileSystemSaveMode</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.EventStreams.streams"><code class="name">var <span class="ident">streams</span> : List[<a title="redvox.common.event_stream.EventStream" href="#redvox.common.event_stream.EventStream">EventStream</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.event_stream.EventStreams.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>kvs: Union[dict, list, str, int, float, bool, ForwardRef(None)], *, infer_missing=False) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls: Type[A],
              kvs: Json,
              *,
              infer_missing=False) -&gt; A:
    return _decode_dataclass(cls, kvs, infer_missing)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.from_dir"><code class="name flex">
<span>def <span class="ident">from_dir</span></span>(<span>base_dir: str, file_names: List[str]) ‑> <a title="redvox.common.event_stream.EventStreams" href="#redvox.common.event_stream.EventStreams">EventStreams</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param base_dir: directory containing EventStream files
:param file_names: the names of .json files containing EventStream data</p>
<p>:return: EventStreams object from a directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dir(base_dir: str, file_names: List[str]) -&gt; &#34;EventStreams&#34;:
    &#34;&#34;&#34;
    :param base_dir: directory containing EventStream files
    :param file_names: the names of .json files containing EventStream data

    :return: EventStreams object from a directory
    &#34;&#34;&#34;
    return EventStreams([EventStream.from_json_file(base_dir, e) for e in file_names],
                        save_mode=FileSystemSaveMode.DISK, base_dir=base_dir)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s: Union[str, bytes, bytearray], *, parse_float=None, parse_int=None, parse_constant=None, infer_missing=False, **kw) ‑> ~A</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_json(cls: Type[A],
              s: JsonData,
              *,
              parse_float=None,
              parse_int=None,
              parse_constant=None,
              infer_missing=False,
              **kw) -&gt; A:
    kvs = json.loads(s,
                     parse_float=parse_float,
                     parse_int=parse_int,
                     parse_constant=parse_constant,
                     **kw)
    return cls.from_dict(kvs, infer_missing=infer_missing)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>*, infer_missing: bool = False, only=None, exclude=(), many: bool = False, context=None, load_only=(), dump_only=(), partial: bool = False, unknown=None) ‑> dataclasses_json.mm.SchemaF[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def schema(cls: Type[A],
           *,
           infer_missing: bool = False,
           only=None,
           exclude=(),
           many: bool = False,
           context=None,
           load_only=(),
           dump_only=(),
           partial: bool = False,
           unknown=None) -&gt; SchemaType:
    Schema = build_schema(cls, DataClassJsonMixin, infer_missing, partial)

    if unknown is None:
        undefined_parameter_action = _undefined_parameter_action_safe(cls)
        if undefined_parameter_action is not None:
            # We can just make use of the same-named mm keywords
            unknown = undefined_parameter_action.name.lower()

    return Schema(only=only,
                  exclude=exclude,
                  many=many,
                  context=context,
                  load_only=load_only,
                  dump_only=dump_only,
                  partial=partial,
                  unknown=unknown)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.event_stream.EventStreams.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, other_stream: <a title="redvox.common.event_stream.EventStream" href="#redvox.common.event_stream.EventStream">EventStream</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>append another EventStream to an existing EventStream or add to the list of EventStream</p>
<p>:param other_stream: other EventStream to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, other_stream: EventStream):
    &#34;&#34;&#34;
    append another EventStream to an existing EventStream or add to the list of EventStream

    :param other_stream: other EventStream to add
    &#34;&#34;&#34;
    if other_stream.name in self.get_stream_names():
        self.get_stream(other_stream.name).append(other_stream)
    else:
        self.streams.append(other_stream)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.append_streams"><code class="name flex">
<span>def <span class="ident">append_streams</span></span>(<span>self, other_streams: <a title="redvox.common.event_stream.EventStreams" href="#redvox.common.event_stream.EventStreams">EventStreams</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>append another EventStreams object to an existing EventStreams object</p>
<p>:param other_streams: EventStreams to add</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_streams(self, other_streams: &#34;EventStreams&#34;):
    &#34;&#34;&#34;
    append another EventStreams object to an existing EventStreams object

    :param other_streams: EventStreams to add
    &#34;&#34;&#34;
    for s in other_streams.streams:
        self.append(s)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.get_stream"><code class="name flex">
<span>def <span class="ident">get_stream</span></span>(<span>self, stream_name: str) ‑> Optional[<a title="redvox.common.event_stream.EventStream" href="#redvox.common.event_stream.EventStream">EventStream</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>:param stream_name: name of event stream to get
:return: the EventStream that has the name specified or None if it doesn't exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stream(self, stream_name: str) -&gt; Optional[EventStream]:
    &#34;&#34;&#34;
    :param stream_name: name of event stream to get
    :return: the EventStream that has the name specified or None if it doesn&#39;t exist
    &#34;&#34;&#34;
    for s in self.streams:
        if s.name == stream_name:
            return s
    if self.debug:
        print(f&#34;{stream_name} does not exist in streams.  Use one of {[self.get_stream_names()]}&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.get_stream_names"><code class="name flex">
<span>def <span class="ident">get_stream_names</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>:return: names of all streams</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stream_names(self) -&gt; List[str]:
    &#34;&#34;&#34;
    :return: names of all streams
    &#34;&#34;&#34;
    return [s.name for s in self.streams]</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.list_for_dict"><code class="name flex">
<span>def <span class="ident">list_for_dict</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the name of files that store event streams</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_for_dict(self) -&gt; list:
    &#34;&#34;&#34;
    :return: the name of files that store event streams
    &#34;&#34;&#34;
    return [s.file_name() for s in self.streams]</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.read_from_packet"><code class="name flex">
<span>def <span class="ident">read_from_packet</span></span>(<span>self, packet: src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM)</span>
</code></dt>
<dd>
<div class="desc"><p>read the eventstream payload from a single Redvox Api1000 packet</p>
<p>:param packet: packet to read data from</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_from_packet(self, packet: RedvoxPacketM):
    &#34;&#34;&#34;
    read the eventstream payload from a single Redvox Api1000 packet

    :param packet: packet to read data from
    &#34;&#34;&#34;
    for st in packet.event_streams:
        if st.name in self.get_stream_names():
            self.get_stream(st.name).add_raw(st)
        else:
            self.streams.append(EventStream(save_mode=self.save_mode, base_dir=self.base_dir).read_raw(st))</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.read_from_packets_list"><code class="name flex">
<span>def <span class="ident">read_from_packets_list</span></span>(<span>self, packets: List[src.redvox_api_m.redvox_api_m_pb2.RedvoxPacketM])</span>
</code></dt>
<dd>
<div class="desc"><p>read the eventstream payload from multiple Redvox Api1000 packets</p>
<p>:param packets: packets to read data from</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_from_packets_list(self, packets: List[RedvoxPacketM]):
    &#34;&#34;&#34;
    read the eventstream payload from multiple Redvox Api1000 packets

    :param packets: packets to read data from
    &#34;&#34;&#34;
    for p in packets:
        if type(p) == RedvoxPacketM:
            self.read_from_packet(p)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.save_streams"><code class="name flex">
<span>def <span class="ident">save_streams</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>saves all streams to disk</p>
<p>note: use the function set_save_dir() to change where events are saved</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_streams(self):
    &#34;&#34;&#34;
    saves all streams to disk

    note: use the function set_save_dir() to change where events are saved
    &#34;&#34;&#34;
    for s in self.streams:
        s.to_json_file()</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.set_save_dir"><code class="name flex">
<span>def <span class="ident">set_save_dir</span></span>(<span>self, new_dir: str)</span>
</code></dt>
<dd>
<div class="desc"><p>change the directory where events are saved to</p>
<p>:param new_dir: new directory path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_save_dir(self, new_dir: str):
    &#34;&#34;&#34;
    change the directory where events are saved to

    :param new_dir: new directory path
    &#34;&#34;&#34;
    self.base_dir = new_dir
    for s in self.streams:
        s.set_save_dir(new_dir)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.set_save_mode"><code class="name flex">
<span>def <span class="ident">set_save_mode</span></span>(<span>self, new_save_mode: <a title="redvox.common.io.FileSystemSaveMode" href="io.html#redvox.common.io.FileSystemSaveMode">FileSystemSaveMode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>update the save mode for all EventStream</p>
<p>:param new_save_mode: save mode to set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_save_mode(self, new_save_mode: FileSystemSaveMode):
    &#34;&#34;&#34;
    update the save mode for all EventStream

    :param new_save_mode: save mode to set
    &#34;&#34;&#34;
    for s in self.streams:
        s.set_save_mode(new_save_mode)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, encode_json=False) ‑> Dict[str, Union[dict, list, str, int, float, bool, ForwardRef(None)]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, encode_json=False) -&gt; Dict[str, Json]:
    return _asdict(self, encode_json=encode_json)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, ForwardRef(None)] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self,
            *,
            skipkeys: bool = False,
            ensure_ascii: bool = True,
            check_circular: bool = True,
            allow_nan: bool = True,
            indent: Optional[Union[int, str]] = None,
            separators: Tuple[str, str] = None,
            default: Callable = None,
            sort_keys: bool = False,
            **kw) -&gt; str:
    return json.dumps(self.to_dict(encode_json=False),
                      cls=_ExtendedEncoder,
                      skipkeys=skipkeys,
                      ensure_ascii=ensure_ascii,
                      check_circular=check_circular,
                      allow_nan=allow_nan,
                      indent=indent,
                      separators=separators,
                      default=default,
                      sort_keys=sort_keys,
                      **kw)</code></pre>
</details>
</dd>
<dt id="redvox.common.event_stream.EventStreams.update_timestamps"><code class="name flex">
<span>def <span class="ident">update_timestamps</span></span>(<span>self, offset_model: <a title="redvox.common.offset_model.OffsetModel" href="offset_model.html#redvox.common.offset_model.OffsetModel">OffsetModel</a>, use_model_function: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>update the timestamps in the data</p>
<p>:param offset_model: model used to update the timestamps
:param use_model_function: if True, use the model's slope function to update the timestamps.
otherwise uses the best offset (model's intercept value).
Default False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_timestamps(self, offset_model: om.OffsetModel, use_model_function: bool = False):
    &#34;&#34;&#34;
    update the timestamps in the data

    :param offset_model: model used to update the timestamps
    :param use_model_function: if True, use the model&#39;s slope function to update the timestamps.
                                otherwise uses the best offset (model&#39;s intercept value).  Default False
    &#34;&#34;&#34;
    for evnt in self.streams:
        evnt.update_timestamps(offset_model, use_model_function)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM"><code class="flex name class">
<span>class <span class="ident">RedvoxPacketM</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>google.protobuf.pyext._message.CMessage</li>
<li>google.protobuf.message.Message</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="redvox.common.event_stream.RedvoxPacketM.BYTE"><code class="name">var <span class="ident">BYTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.CENTIMETERS"><code class="name">var <span class="ident">CENTIMETERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.DECIBEL"><code class="name">var <span class="ident">DECIBEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.DECIMAL_DEGREES"><code class="name">var <span class="ident">DECIMAL_DEGREES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.DEGREES_CELSIUS"><code class="name">var <span class="ident">DEGREES_CELSIUS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.DESCRIPTOR"><code class="name">var <span class="ident">DESCRIPTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.DoubleSamplePayload"><code class="name">var <span class="ident">DoubleSamplePayload</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.EventStream"><code class="name">var <span class="ident">EventStream</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.KILOPASCAL"><code class="name">var <span class="ident">KILOPASCAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.LSB_PLUS_MINUS_COUNTS"><code class="name">var <span class="ident">LSB_PLUS_MINUS_COUNTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.LUX"><code class="name">var <span class="ident">LUX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.METERS"><code class="name">var <span class="ident">METERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.METERS_PER_SECOND"><code class="name">var <span class="ident">METERS_PER_SECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.METERS_PER_SECOND_SQUARED"><code class="name">var <span class="ident">METERS_PER_SECOND_SQUARED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.MICROAMPERES"><code class="name">var <span class="ident">MICROAMPERES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.MICROSECONDS_SINCE_UNIX_EPOCH"><code class="name">var <span class="ident">MICROSECONDS_SINCE_UNIX_EPOCH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.MICROTESLA"><code class="name">var <span class="ident">MICROTESLA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.MetadataEntry"><code class="name">var <span class="ident">MetadataEntry</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.NORMALIZED_COUNTS"><code class="name">var <span class="ident">NORMALIZED_COUNTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.PCM"><code class="name">var <span class="ident">PCM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.PERCENTAGE"><code class="name">var <span class="ident">PERCENTAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.RADIANS"><code class="name">var <span class="ident">RADIANS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.RADIANS_PER_SECOND"><code class="name">var <span class="ident">RADIANS_PER_SECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.SamplePayload"><code class="name">var <span class="ident">SamplePayload</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.Sensors"><code class="name">var <span class="ident">Sensors</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.StationInformation"><code class="name">var <span class="ident">StationInformation</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.SummaryStatistics"><code class="name">var <span class="ident">SummaryStatistics</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.TimingInformation"><code class="name">var <span class="ident">TimingInformation</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.TimingPayload"><code class="name">var <span class="ident">TimingPayload</span></code></dt>
<dd>
<div class="desc"><p>A ProtocolMessage</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.UNITLESS"><code class="name">var <span class="ident">UNITLESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.Unit"><code class="name">var <span class="ident">Unit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="redvox.common.event_stream.RedvoxPacketM.api"><code class="name">var <span class="ident">api</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.api</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.event_streams"><code class="name">var <span class="ident">event_streams</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.event_streams</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.metadata</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.sensors"><code class="name">var <span class="ident">sensors</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.sensors</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.station_information"><code class="name">var <span class="ident">station_information</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.station_information</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.sub_api"><code class="name">var <span class="ident">sub_api</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.sub_api</p></div>
</dd>
<dt id="redvox.common.event_stream.RedvoxPacketM.timing_information"><code class="name">var <span class="ident">timing_information</span></code></dt>
<dd>
<div class="desc"><p>Field redvox_api_m.RedvoxPacketM.timing_information</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.common.event_stream.EventStream" href="#redvox.common.event_stream.EventStream">EventStream</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.event_stream.EventStream.add" href="#redvox.common.event_stream.EventStream.add">add</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.add_raw" href="#redvox.common.event_stream.EventStream.add_raw">add_raw</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.add_to_schema" href="#redvox.common.event_stream.EventStream.add_to_schema">add_to_schema</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.append" href="#redvox.common.event_stream.EventStream.append">append</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.append_error" href="#redvox.common.event_stream.EventStream.append_error">append_error</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.as_dict" href="#redvox.common.event_stream.EventStream.as_dict">as_dict</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.data" href="#redvox.common.event_stream.EventStream.data">data</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.default_json_file_name" href="#redvox.common.event_stream.EventStream.default_json_file_name">default_json_file_name</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.errors" href="#redvox.common.event_stream.EventStream.errors">errors</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.file_name" href="#redvox.common.event_stream.EventStream.file_name">file_name</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.from_json_file" href="#redvox.common.event_stream.EventStream.from_json_file">from_json_file</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.fs_writer" href="#redvox.common.event_stream.EventStream.fs_writer">fs_writer</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.full_file_name" href="#redvox.common.event_stream.EventStream.full_file_name">full_file_name</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.full_path" href="#redvox.common.event_stream.EventStream.full_path">full_path</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_boolean_column" href="#redvox.common.event_stream.EventStream.get_boolean_column">get_boolean_column</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_boolean_schema" href="#redvox.common.event_stream.EventStream.get_boolean_schema">get_boolean_schema</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_boolean_values" href="#redvox.common.event_stream.EventStream.get_boolean_values">get_boolean_values</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_byte_column" href="#redvox.common.event_stream.EventStream.get_byte_column">get_byte_column</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_byte_schema" href="#redvox.common.event_stream.EventStream.get_byte_schema">get_byte_schema</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_byte_values" href="#redvox.common.event_stream.EventStream.get_byte_values">get_byte_values</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_numeric_column" href="#redvox.common.event_stream.EventStream.get_numeric_column">get_numeric_column</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_numeric_schema" href="#redvox.common.event_stream.EventStream.get_numeric_schema">get_numeric_schema</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_numeric_values" href="#redvox.common.event_stream.EventStream.get_numeric_values">get_numeric_values</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_schema" href="#redvox.common.event_stream.EventStream.get_schema">get_schema</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_string_column" href="#redvox.common.event_stream.EventStream.get_string_column">get_string_column</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_string_schema" href="#redvox.common.event_stream.EventStream.get_string_schema">get_string_schema</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.get_string_values" href="#redvox.common.event_stream.EventStream.get_string_values">get_string_values</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.is_save_to_disk" href="#redvox.common.event_stream.EventStream.is_save_to_disk">is_save_to_disk</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.print_errors" href="#redvox.common.event_stream.EventStream.print_errors">print_errors</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.read_events" href="#redvox.common.event_stream.EventStream.read_events">read_events</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.read_from_dir" href="#redvox.common.event_stream.EventStream.read_from_dir">read_from_dir</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.read_raw" href="#redvox.common.event_stream.EventStream.read_raw">read_raw</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.save_dir" href="#redvox.common.event_stream.EventStream.save_dir">save_dir</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.set_errors" href="#redvox.common.event_stream.EventStream.set_errors">set_errors</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.set_file_name" href="#redvox.common.event_stream.EventStream.set_file_name">set_file_name</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.set_save_dir" href="#redvox.common.event_stream.EventStream.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.set_save_mode" href="#redvox.common.event_stream.EventStream.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.set_save_to_disk" href="#redvox.common.event_stream.EventStream.set_save_to_disk">set_save_to_disk</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.set_schema" href="#redvox.common.event_stream.EventStream.set_schema">set_schema</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.timestamps" href="#redvox.common.event_stream.EventStream.timestamps">timestamps</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.to_json_file" href="#redvox.common.event_stream.EventStream.to_json_file">to_json_file</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.unaltered_timestamps" href="#redvox.common.event_stream.EventStream.unaltered_timestamps">unaltered_timestamps</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.update_timestamps" href="#redvox.common.event_stream.EventStream.update_timestamps">update_timestamps</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStream.write_table" href="#redvox.common.event_stream.EventStream.write_table">write_table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.event_stream.EventStreams" href="#redvox.common.event_stream.EventStreams">EventStreams</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.event_stream.EventStreams.append" href="#redvox.common.event_stream.EventStreams.append">append</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.append_streams" href="#redvox.common.event_stream.EventStreams.append_streams">append_streams</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.base_dir" href="#redvox.common.event_stream.EventStreams.base_dir">base_dir</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.debug" href="#redvox.common.event_stream.EventStreams.debug">debug</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.from_dict" href="#redvox.common.event_stream.EventStreams.from_dict">from_dict</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.from_dir" href="#redvox.common.event_stream.EventStreams.from_dir">from_dir</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.from_json" href="#redvox.common.event_stream.EventStreams.from_json">from_json</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.get_stream" href="#redvox.common.event_stream.EventStreams.get_stream">get_stream</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.get_stream_names" href="#redvox.common.event_stream.EventStreams.get_stream_names">get_stream_names</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.list_for_dict" href="#redvox.common.event_stream.EventStreams.list_for_dict">list_for_dict</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.read_from_packet" href="#redvox.common.event_stream.EventStreams.read_from_packet">read_from_packet</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.read_from_packets_list" href="#redvox.common.event_stream.EventStreams.read_from_packets_list">read_from_packets_list</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.save_mode" href="#redvox.common.event_stream.EventStreams.save_mode">save_mode</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.save_streams" href="#redvox.common.event_stream.EventStreams.save_streams">save_streams</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.schema" href="#redvox.common.event_stream.EventStreams.schema">schema</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.set_save_dir" href="#redvox.common.event_stream.EventStreams.set_save_dir">set_save_dir</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.set_save_mode" href="#redvox.common.event_stream.EventStreams.set_save_mode">set_save_mode</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.streams" href="#redvox.common.event_stream.EventStreams.streams">streams</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.to_dict" href="#redvox.common.event_stream.EventStreams.to_dict">to_dict</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.to_json" href="#redvox.common.event_stream.EventStreams.to_json">to_json</a></code></li>
<li><code><a title="redvox.common.event_stream.EventStreams.update_timestamps" href="#redvox.common.event_stream.EventStreams.update_timestamps">update_timestamps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.common.event_stream.RedvoxPacketM" href="#redvox.common.event_stream.RedvoxPacketM">RedvoxPacketM</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.BYTE" href="#redvox.common.event_stream.RedvoxPacketM.BYTE">BYTE</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.CENTIMETERS" href="#redvox.common.event_stream.RedvoxPacketM.CENTIMETERS">CENTIMETERS</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.DECIBEL" href="#redvox.common.event_stream.RedvoxPacketM.DECIBEL">DECIBEL</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.DECIMAL_DEGREES" href="#redvox.common.event_stream.RedvoxPacketM.DECIMAL_DEGREES">DECIMAL_DEGREES</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.DEGREES_CELSIUS" href="#redvox.common.event_stream.RedvoxPacketM.DEGREES_CELSIUS">DEGREES_CELSIUS</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.DESCRIPTOR" href="#redvox.common.event_stream.RedvoxPacketM.DESCRIPTOR">DESCRIPTOR</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.DoubleSamplePayload" href="#redvox.common.event_stream.RedvoxPacketM.DoubleSamplePayload">DoubleSamplePayload</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.EventStream" href="#redvox.common.event_stream.RedvoxPacketM.EventStream">EventStream</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.KILOPASCAL" href="#redvox.common.event_stream.RedvoxPacketM.KILOPASCAL">KILOPASCAL</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.LSB_PLUS_MINUS_COUNTS" href="#redvox.common.event_stream.RedvoxPacketM.LSB_PLUS_MINUS_COUNTS">LSB_PLUS_MINUS_COUNTS</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.LUX" href="#redvox.common.event_stream.RedvoxPacketM.LUX">LUX</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.METERS" href="#redvox.common.event_stream.RedvoxPacketM.METERS">METERS</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.METERS_PER_SECOND" href="#redvox.common.event_stream.RedvoxPacketM.METERS_PER_SECOND">METERS_PER_SECOND</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.METERS_PER_SECOND_SQUARED" href="#redvox.common.event_stream.RedvoxPacketM.METERS_PER_SECOND_SQUARED">METERS_PER_SECOND_SQUARED</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.MICROAMPERES" href="#redvox.common.event_stream.RedvoxPacketM.MICROAMPERES">MICROAMPERES</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.MICROSECONDS_SINCE_UNIX_EPOCH" href="#redvox.common.event_stream.RedvoxPacketM.MICROSECONDS_SINCE_UNIX_EPOCH">MICROSECONDS_SINCE_UNIX_EPOCH</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.MICROTESLA" href="#redvox.common.event_stream.RedvoxPacketM.MICROTESLA">MICROTESLA</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.MetadataEntry" href="#redvox.common.event_stream.RedvoxPacketM.MetadataEntry">MetadataEntry</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.NORMALIZED_COUNTS" href="#redvox.common.event_stream.RedvoxPacketM.NORMALIZED_COUNTS">NORMALIZED_COUNTS</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.PCM" href="#redvox.common.event_stream.RedvoxPacketM.PCM">PCM</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.PERCENTAGE" href="#redvox.common.event_stream.RedvoxPacketM.PERCENTAGE">PERCENTAGE</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.RADIANS" href="#redvox.common.event_stream.RedvoxPacketM.RADIANS">RADIANS</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.RADIANS_PER_SECOND" href="#redvox.common.event_stream.RedvoxPacketM.RADIANS_PER_SECOND">RADIANS_PER_SECOND</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.SamplePayload" href="#redvox.common.event_stream.RedvoxPacketM.SamplePayload">SamplePayload</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.Sensors" href="#redvox.common.event_stream.RedvoxPacketM.Sensors">Sensors</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.StationInformation" href="#redvox.common.event_stream.RedvoxPacketM.StationInformation">StationInformation</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.SummaryStatistics" href="#redvox.common.event_stream.RedvoxPacketM.SummaryStatistics">SummaryStatistics</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.TimingInformation" href="#redvox.common.event_stream.RedvoxPacketM.TimingInformation">TimingInformation</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.TimingPayload" href="#redvox.common.event_stream.RedvoxPacketM.TimingPayload">TimingPayload</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.UNITLESS" href="#redvox.common.event_stream.RedvoxPacketM.UNITLESS">UNITLESS</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.UNKNOWN" href="#redvox.common.event_stream.RedvoxPacketM.UNKNOWN">UNKNOWN</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.Unit" href="#redvox.common.event_stream.RedvoxPacketM.Unit">Unit</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.api" href="#redvox.common.event_stream.RedvoxPacketM.api">api</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.event_streams" href="#redvox.common.event_stream.RedvoxPacketM.event_streams">event_streams</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.metadata" href="#redvox.common.event_stream.RedvoxPacketM.metadata">metadata</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.sensors" href="#redvox.common.event_stream.RedvoxPacketM.sensors">sensors</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.station_information" href="#redvox.common.event_stream.RedvoxPacketM.station_information">station_information</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.sub_api" href="#redvox.common.event_stream.RedvoxPacketM.sub_api">sub_api</a></code></li>
<li><code><a title="redvox.common.event_stream.RedvoxPacketM.timing_information" href="#redvox.common.event_stream.RedvoxPacketM.timing_information">timing_information</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>