<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>redvox.api1000.wrapped_redvox_packet.ml API documentation</title>
<meta name="description" content="This module provides methods and datatypes for the efficient extraction and manipulation of machine learning data stored
in RedVox packet EventStreams." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.api1000.wrapped_redvox_packet.ml</code></h1>
</header>
<section id="section-intro">
<p>This module provides methods and datatypes for the efficient extraction and manipulation of machine learning data stored
in RedVox packet EventStreams.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides methods and datatypes for the efficient extraction and manipulation of machine learning data stored
 in RedVox packet EventStreams.
&#34;&#34;&#34;

from dataclasses import dataclass
from enum import Enum
from math import isfinite
from typing import Optional, Dict, List

import numpy as np
from redvox.common.errors import RedVoxError

from redvox.api1000.common.generic import ProtoRepeatedMessage
from redvox.api1000.wrapped_redvox_packet.event_streams import EventStream, Event
from redvox.api1000.wrapped_redvox_packet.wrapped_packet import WrappedRedvoxPacketM

ML_CLASS_PREFIX: str = &#34;class_&#34;
ML_SCORE_PREFIX: str = &#34;score_&#34;
ML_EVENT_STREAM_NAME: str = &#34;inference&#34;
ML_METADATA_MODEL_VERSION_KEY: str = &#34;model_version&#34;
ML_METADATA_INPUT_SAMPLES_PER_HOP_KEY: str = &#34;input_samples_per_hop&#34;
ML_METADATA_INPUT_SAMPLE_RATE_KEY: str = &#34;input_sample_rate&#34;
ML_METADATA_INPUT_SAMPLES_PER_WINDOW_KEY: str = &#34;input_samples_per_window&#34;


class MlError(RedVoxError):
    def __init__(self, msg: str):
        super().__init__(f&#34;MlError: {msg}&#34;)


@dataclass
class ExtractedMl:
    &#34;&#34;&#34;
    Contains the extracted ML classes and scores as well as metadata relating to the utilized model.
    &#34;&#34;&#34;

    metadata: &#34;MlMetadata&#34;
    windows: List[&#34;MlWindow&#34;]

    def sort(self, sort_by: &#34;SortBy&#34;) -&gt; &#34;ExtractedMl&#34;:
        &#34;&#34;&#34;
        Sorts the labels in ascending or descending order by either score of class name.
        :param sort_by: The sort operation to use.
        :return: An updated instance of ExtractedMl.
        &#34;&#34;&#34;
        self.windows = list(map(lambda window: window.sort(sort_by), self.windows))
        return self

    def prune_zeros(self) -&gt; &#34;ExtractedMl&#34;:
        &#34;&#34;&#34;
        Removes labels that have a score of 0.
        :return: An updated instance of ExtractedMl.
        &#34;&#34;&#34;
        self.windows = list(map(lambda window: window.prune_zeros(), self.windows))
        return self

    def prune_lt(self, min_v: float) -&gt; &#34;ExtractedMl&#34;:
        &#34;&#34;&#34;
        Prunes labels with score less than the provided minimum.
        :param min_v: The minimum acceptable label score.
        :return: An updated instance of ExtractedMl.
        &#34;&#34;&#34;
        if min_v &lt;= 0:
            raise MlError(f&#34;min_v={min_v} must be &gt; 0&#34;)

        self.windows = list(map(lambda window: window.prune_lt(min_v), self.windows))
        return self

    def retain_top(self, n: int) -&gt; &#34;ExtractedMl&#34;:
        &#34;&#34;&#34;
        Sorts labels in descending order by score and only keeps up to the top n labels.
        :param n: The number of labels to keep.
        :return: An updated instance of ExtractedMl.
        &#34;&#34;&#34;
        if n &lt;= 0:
            raise MlError(f&#34;n={n} must be &gt; 0&#34;)

        self.windows = list(map(lambda window: window.retain_top(n), self.windows))
        return self


@dataclass
class MlMetadata:
    &#34;&#34;&#34;
    Metadata relating to the utilized ML model.
    &#34;&#34;&#34;

    model_name: str
    model_version: str
    input_samples_per_hop: int
    input_sample_rate: int
    input_samples_per_window: int


@dataclass
class MlWindow:
    &#34;&#34;&#34;
    Labels from a single time window.
    &#34;&#34;&#34;

    timestamp: int
    labels: List[&#34;Label&#34;]

    def sort(self, sort_by: &#34;SortBy&#34;) -&gt; &#34;MlWindow&#34;:
        &#34;&#34;&#34;
        Sorts the labels in ascending or descending order by either score of class name.
        :param sort_by: The sort operation to use.
        :return: An updated instance of MlWindow.
        &#34;&#34;&#34;
        if sort_by is SortBy.CLASS_ASC:
            self.labels = sorted(self.labels, key=lambda label: label.class_name)
        elif sort_by is SortBy.CLASS_DESC:
            self.labels = sorted(
                self.labels, key=lambda label: label.class_name, reverse=True
            )
        elif sort_by is SortBy.SCORE_ASC:
            self.labels = sorted(self.labels, key=lambda label: label.score)
        else:
            self.labels = sorted(
                self.labels, key=lambda label: label.score, reverse=True
            )

        return self

    def prune_zeros(self) -&gt; &#34;MlWindow&#34;:
        &#34;&#34;&#34;
        Removes labels that have a score of 0.
        :return: An updated instance of MlWindow.
        &#34;&#34;&#34;
        self.labels = list(filter(lambda label: label.score &gt; 0, self.labels))
        return self

    def prune_lt(self, min_v: float) -&gt; &#34;MlWindow&#34;:
        &#34;&#34;&#34;
        Prunes labels with score less than the provided minimum.
        :param min_v: The minimum acceptable label score.
        :return: An updated instance of MlWindow.
        &#34;&#34;&#34;
        if min_v &lt;= 0:
            raise MlError(f&#34;min_v={min_v} must be &gt; 0&#34;)

        self.labels = list(filter(lambda label: label.score &gt;= min_v, self.labels))
        return self

    def retain_top(self, n: int) -&gt; &#34;MlWindow&#34;:
        &#34;&#34;&#34;
        Sorts labels in descending order by score and only keeps up to the top n labels.
        :param n: The number of labels to keep.
        :return: An updated instance of MlWindow.
        &#34;&#34;&#34;
        if n &lt;= 0:
            raise MlError(f&#34;n={n} must be &gt; 0&#34;)

        sorted_window: MlWindow = self.sort(SortBy.SCORE_DESC)
        sorted_window.labels = sorted_window.labels[:n]
        return sorted_window


@dataclass
class Label:
    &#34;&#34;&#34;
    A pair containing a class name and a score.
    &#34;&#34;&#34;

    class_name: str
    score: float


class SortBy(Enum):
    &#34;&#34;&#34;
    An enumeration that represents the valid label sorting methods.
    &#34;&#34;&#34;

    SCORE_ASC: int = 1
    SCORE_DESC: int = 2
    CLASS_ASC: int = 3
    CLASS_DESC: int = 4


def extract_ml_metadata(stream: EventStream) -&gt; MlMetadata:
    &#34;&#34;&#34;
    Extracts ML metadata from an event stream.
    :param stream: The event stream to extract the ML metadata from.
    :return: An instance of MlMetadata.
    &#34;&#34;&#34;
    if stream.get_name() != ML_EVENT_STREAM_NAME:
        raise MlError(
            f&#34;Invalid ML event stream name={stream.get_name()} != {ML_EVENT_STREAM_NAME}&#34;
        )

    if stream.get_events().get_count() == 0:
        raise MlError(&#34;ML EventStream contains 0 Events&#34;)

    name: str = stream.get_events().get_values()[0].get_description()
    meta: Dict[str, str] = stream.get_metadata().get_metadata()

    for key in [
        ML_METADATA_MODEL_VERSION_KEY,
        ML_METADATA_INPUT_SAMPLES_PER_HOP_KEY,
        ML_METADATA_INPUT_SAMPLE_RATE_KEY,
        ML_METADATA_INPUT_SAMPLES_PER_WINDOW_KEY,
    ]:
        if key not in meta:
            raise MlError(f&#34;Missing required ML metadata key={key}&#34;)

    try:
        return MlMetadata(
            name,
            meta[ML_METADATA_MODEL_VERSION_KEY],
            int(meta[ML_METADATA_INPUT_SAMPLES_PER_HOP_KEY]),
            int(meta[ML_METADATA_INPUT_SAMPLE_RATE_KEY]),
            int(meta[ML_METADATA_INPUT_SAMPLES_PER_WINDOW_KEY]),
        )
    except ValueError:
        raise MlError(&#34;Could not parse ML metadata&#34;)


def find_ml_event_stream(packet: WrappedRedvoxPacketM) -&gt; Optional[EventStream]:
    &#34;&#34;&#34;
    Attempts to find an event stream with ML data.
    :param packet: The packet to search in.
    :return: An instance of the matching event stream or None.
    &#34;&#34;&#34;
    streams: ProtoRepeatedMessage = packet.get_event_streams()

    stream: EventStream
    for stream in streams.get_values():
        if stream.get_name() == ML_EVENT_STREAM_NAME:
            return stream

    return None


def label_at(
    str_payload: Dict[str, str], num_payload: Dict[str, float], idx: int
) -&gt; Label:
    &#34;&#34;&#34;
    Finds the label and score in the event payloads.
    :param str_payload: The event string payload.
    :param num_payload: The event numeric payload.
    :param idx: The index of the class and score.
    :return: An instance of a Label.
    &#34;&#34;&#34;
    class_key: str = f&#34;{ML_CLASS_PREFIX}{idx}&#34;
    score_key: str = f&#34;{ML_SCORE_PREFIX}{idx}&#34;

    if class_key not in str_payload:
        raise MlError(f&#34;Missing required class_key={class_key}&#34;)

    if score_key not in num_payload:
        raise MlError(f&#34;Missing required score_key={score_key}&#34;)

    class_name: str = str_payload[class_key]
    score: float = num_payload[score_key]

    if not isfinite(score):
        raise MlError(f&#34;Invalid non-finite score={score}&#34;)

    return Label(class_name, score)


def extract_ml_windows(stream: EventStream) -&gt; List[MlWindow]:
    &#34;&#34;&#34;
    Extracts ML windows from an event stream.
    :param stream: The stream to extract windows from.
    :return: A list of ML windows.
    &#34;&#34;&#34;
    if stream.get_name() != ML_EVENT_STREAM_NAME:
        raise MlError(
            f&#34;Invalid ML event stream name={stream.get_name()} != {ML_EVENT_STREAM_NAME}&#34;
        )

    timestamps: np.ndarray = stream.get_timestamps().get_timestamps()
    windows: List[MlWindow] = []

    events: List[Event] = stream.get_events().get_values()

    if len(timestamps) != len(events):
        raise MlError(f&#34;len(timestamps={len(timestamps)}) != len(events={len(events)})&#34;)

    idx_window: int
    timestamp: float
    for (idx_window, timestamp) in enumerate(timestamps):
        event: Event = events[idx_window]
        str_payload: Dict[str, str] = event.get_string_payload().get_metadata()
        num_payload: Dict[str, float] = event.get_numeric_payload().get_metadata()

        labels: List[Label] = []
        for i in range(len(str_payload)):
            label: Label = label_at(str_payload, num_payload, i)
            labels.append(label)

        window: MlWindow = MlWindow(int(round(timestamp)), labels)
        windows.append(window)

    return windows


def extract_ml_from_event_stream(stream: EventStream) -&gt; ExtractedMl:
    &#34;&#34;&#34;
    Extract ML parameters from an event stream.
    :param stream: The event stream to extract ML parameters from.
    :return: The extracted ML parameters or None.
    &#34;&#34;&#34;
    if stream.get_name() != ML_EVENT_STREAM_NAME:
        raise MlError(
            f&#34;Invalid ML event stream name={stream.get_name()} != {ML_EVENT_STREAM_NAME}&#34;
        )

    metadata: MlMetadata = extract_ml_metadata(stream)
    windows: List[MlWindow] = extract_ml_windows(stream)
    return ExtractedMl(metadata, windows)


def extract_ml_from_packet(packet: WrappedRedvoxPacketM) -&gt; Optional[ExtractedMl]:
    &#34;&#34;&#34;
    Extract ML parameters from an event stream.
    :param packet: The packet to extract ML parameters from.
    :return: The extracted ML parameters or None.
    &#34;&#34;&#34;
    stream: Optional[EventStream] = find_ml_event_stream(packet)
    if stream is None:
        return None
    return extract_ml_from_event_stream(stream)


def extract_ml_from_file(file_path: str) -&gt; Optional[ExtractedMl]:
    &#34;&#34;&#34;
    Extract ML parameters from a file.
    :param file_path: The path of the packet to extract ML parameters from.
    :return: The extracted ML parameters or None.
    &#34;&#34;&#34;
    packet: WrappedRedvoxPacketM = WrappedRedvoxPacketM.from_compressed_path(file_path)
    return extract_ml_from_packet(packet)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_from_event_stream"><code class="name flex">
<span>def <span class="ident">extract_ml_from_event_stream</span></span>(<span>stream: <a title="redvox.api1000.wrapped_redvox_packet.event_streams.EventStream" href="event_streams.html#redvox.api1000.wrapped_redvox_packet.event_streams.EventStream">EventStream</a>) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl">ExtractedMl</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extract ML parameters from an event stream.
:param stream: The event stream to extract ML parameters from.
:return: The extracted ML parameters or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_ml_from_event_stream(stream: EventStream) -&gt; ExtractedMl:
    &#34;&#34;&#34;
    Extract ML parameters from an event stream.
    :param stream: The event stream to extract ML parameters from.
    :return: The extracted ML parameters or None.
    &#34;&#34;&#34;
    if stream.get_name() != ML_EVENT_STREAM_NAME:
        raise MlError(
            f&#34;Invalid ML event stream name={stream.get_name()} != {ML_EVENT_STREAM_NAME}&#34;
        )

    metadata: MlMetadata = extract_ml_metadata(stream)
    windows: List[MlWindow] = extract_ml_windows(stream)
    return ExtractedMl(metadata, windows)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_from_file"><code class="name flex">
<span>def <span class="ident">extract_ml_from_file</span></span>(<span>file_path: str) ‑> Optional[<a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl">ExtractedMl</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract ML parameters from a file.
:param file_path: The path of the packet to extract ML parameters from.
:return: The extracted ML parameters or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_ml_from_file(file_path: str) -&gt; Optional[ExtractedMl]:
    &#34;&#34;&#34;
    Extract ML parameters from a file.
    :param file_path: The path of the packet to extract ML parameters from.
    :return: The extracted ML parameters or None.
    &#34;&#34;&#34;
    packet: WrappedRedvoxPacketM = WrappedRedvoxPacketM.from_compressed_path(file_path)
    return extract_ml_from_packet(packet)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_from_packet"><code class="name flex">
<span>def <span class="ident">extract_ml_from_packet</span></span>(<span>packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> Optional[<a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl">ExtractedMl</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract ML parameters from an event stream.
:param packet: The packet to extract ML parameters from.
:return: The extracted ML parameters or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_ml_from_packet(packet: WrappedRedvoxPacketM) -&gt; Optional[ExtractedMl]:
    &#34;&#34;&#34;
    Extract ML parameters from an event stream.
    :param packet: The packet to extract ML parameters from.
    :return: The extracted ML parameters or None.
    &#34;&#34;&#34;
    stream: Optional[EventStream] = find_ml_event_stream(packet)
    if stream is None:
        return None
    return extract_ml_from_event_stream(stream)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_metadata"><code class="name flex">
<span>def <span class="ident">extract_ml_metadata</span></span>(<span>stream: <a title="redvox.api1000.wrapped_redvox_packet.event_streams.EventStream" href="event_streams.html#redvox.api1000.wrapped_redvox_packet.event_streams.EventStream">EventStream</a>) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata" href="#redvox.api1000.wrapped_redvox_packet.ml.MlMetadata">MlMetadata</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extracts ML metadata from an event stream.
:param stream: The event stream to extract the ML metadata from.
:return: An instance of MlMetadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_ml_metadata(stream: EventStream) -&gt; MlMetadata:
    &#34;&#34;&#34;
    Extracts ML metadata from an event stream.
    :param stream: The event stream to extract the ML metadata from.
    :return: An instance of MlMetadata.
    &#34;&#34;&#34;
    if stream.get_name() != ML_EVENT_STREAM_NAME:
        raise MlError(
            f&#34;Invalid ML event stream name={stream.get_name()} != {ML_EVENT_STREAM_NAME}&#34;
        )

    if stream.get_events().get_count() == 0:
        raise MlError(&#34;ML EventStream contains 0 Events&#34;)

    name: str = stream.get_events().get_values()[0].get_description()
    meta: Dict[str, str] = stream.get_metadata().get_metadata()

    for key in [
        ML_METADATA_MODEL_VERSION_KEY,
        ML_METADATA_INPUT_SAMPLES_PER_HOP_KEY,
        ML_METADATA_INPUT_SAMPLE_RATE_KEY,
        ML_METADATA_INPUT_SAMPLES_PER_WINDOW_KEY,
    ]:
        if key not in meta:
            raise MlError(f&#34;Missing required ML metadata key={key}&#34;)

    try:
        return MlMetadata(
            name,
            meta[ML_METADATA_MODEL_VERSION_KEY],
            int(meta[ML_METADATA_INPUT_SAMPLES_PER_HOP_KEY]),
            int(meta[ML_METADATA_INPUT_SAMPLE_RATE_KEY]),
            int(meta[ML_METADATA_INPUT_SAMPLES_PER_WINDOW_KEY]),
        )
    except ValueError:
        raise MlError(&#34;Could not parse ML metadata&#34;)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_windows"><code class="name flex">
<span>def <span class="ident">extract_ml_windows</span></span>(<span>stream: <a title="redvox.api1000.wrapped_redvox_packet.event_streams.EventStream" href="event_streams.html#redvox.api1000.wrapped_redvox_packet.event_streams.EventStream">EventStream</a>) ‑> List[<a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow">MlWindow</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts ML windows from an event stream.
:param stream: The stream to extract windows from.
:return: A list of ML windows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_ml_windows(stream: EventStream) -&gt; List[MlWindow]:
    &#34;&#34;&#34;
    Extracts ML windows from an event stream.
    :param stream: The stream to extract windows from.
    :return: A list of ML windows.
    &#34;&#34;&#34;
    if stream.get_name() != ML_EVENT_STREAM_NAME:
        raise MlError(
            f&#34;Invalid ML event stream name={stream.get_name()} != {ML_EVENT_STREAM_NAME}&#34;
        )

    timestamps: np.ndarray = stream.get_timestamps().get_timestamps()
    windows: List[MlWindow] = []

    events: List[Event] = stream.get_events().get_values()

    if len(timestamps) != len(events):
        raise MlError(f&#34;len(timestamps={len(timestamps)}) != len(events={len(events)})&#34;)

    idx_window: int
    timestamp: float
    for (idx_window, timestamp) in enumerate(timestamps):
        event: Event = events[idx_window]
        str_payload: Dict[str, str] = event.get_string_payload().get_metadata()
        num_payload: Dict[str, float] = event.get_numeric_payload().get_metadata()

        labels: List[Label] = []
        for i in range(len(str_payload)):
            label: Label = label_at(str_payload, num_payload, i)
            labels.append(label)

        window: MlWindow = MlWindow(int(round(timestamp)), labels)
        windows.append(window)

    return windows</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.find_ml_event_stream"><code class="name flex">
<span>def <span class="ident">find_ml_event_stream</span></span>(<span>packet: <a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>) ‑> Optional[<a title="redvox.api1000.wrapped_redvox_packet.event_streams.EventStream" href="event_streams.html#redvox.api1000.wrapped_redvox_packet.event_streams.EventStream">EventStream</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to find an event stream with ML data.
:param packet: The packet to search in.
:return: An instance of the matching event stream or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_ml_event_stream(packet: WrappedRedvoxPacketM) -&gt; Optional[EventStream]:
    &#34;&#34;&#34;
    Attempts to find an event stream with ML data.
    :param packet: The packet to search in.
    :return: An instance of the matching event stream or None.
    &#34;&#34;&#34;
    streams: ProtoRepeatedMessage = packet.get_event_streams()

    stream: EventStream
    for stream in streams.get_values():
        if stream.get_name() == ML_EVENT_STREAM_NAME:
            return stream

    return None</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.label_at"><code class="name flex">
<span>def <span class="ident">label_at</span></span>(<span>str_payload: Dict[str, str], num_payload: Dict[str, float], idx: int) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.Label" href="#redvox.api1000.wrapped_redvox_packet.ml.Label">Label</a></span>
</code></dt>
<dd>
<div class="desc"><p>Finds the label and score in the event payloads.
:param str_payload: The event string payload.
:param num_payload: The event numeric payload.
:param idx: The index of the class and score.
:return: An instance of a Label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label_at(
    str_payload: Dict[str, str], num_payload: Dict[str, float], idx: int
) -&gt; Label:
    &#34;&#34;&#34;
    Finds the label and score in the event payloads.
    :param str_payload: The event string payload.
    :param num_payload: The event numeric payload.
    :param idx: The index of the class and score.
    :return: An instance of a Label.
    &#34;&#34;&#34;
    class_key: str = f&#34;{ML_CLASS_PREFIX}{idx}&#34;
    score_key: str = f&#34;{ML_SCORE_PREFIX}{idx}&#34;

    if class_key not in str_payload:
        raise MlError(f&#34;Missing required class_key={class_key}&#34;)

    if score_key not in num_payload:
        raise MlError(f&#34;Missing required score_key={score_key}&#34;)

    class_name: str = str_payload[class_key]
    score: float = num_payload[score_key]

    if not isfinite(score):
        raise MlError(f&#34;Invalid non-finite score={score}&#34;)

    return Label(class_name, score)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl"><code class="flex name class">
<span>class <span class="ident">ExtractedMl</span></span>
<span>(</span><span>metadata: <a title="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata" href="#redvox.api1000.wrapped_redvox_packet.ml.MlMetadata">MlMetadata</a>, windows: List[ForwardRef('<a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow">MlWindow</a>')])</span>
</code></dt>
<dd>
<div class="desc"><p>Contains the extracted ML classes and scores as well as metadata relating to the utilized model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ExtractedMl:
    &#34;&#34;&#34;
    Contains the extracted ML classes and scores as well as metadata relating to the utilized model.
    &#34;&#34;&#34;

    metadata: &#34;MlMetadata&#34;
    windows: List[&#34;MlWindow&#34;]

    def sort(self, sort_by: &#34;SortBy&#34;) -&gt; &#34;ExtractedMl&#34;:
        &#34;&#34;&#34;
        Sorts the labels in ascending or descending order by either score of class name.
        :param sort_by: The sort operation to use.
        :return: An updated instance of ExtractedMl.
        &#34;&#34;&#34;
        self.windows = list(map(lambda window: window.sort(sort_by), self.windows))
        return self

    def prune_zeros(self) -&gt; &#34;ExtractedMl&#34;:
        &#34;&#34;&#34;
        Removes labels that have a score of 0.
        :return: An updated instance of ExtractedMl.
        &#34;&#34;&#34;
        self.windows = list(map(lambda window: window.prune_zeros(), self.windows))
        return self

    def prune_lt(self, min_v: float) -&gt; &#34;ExtractedMl&#34;:
        &#34;&#34;&#34;
        Prunes labels with score less than the provided minimum.
        :param min_v: The minimum acceptable label score.
        :return: An updated instance of ExtractedMl.
        &#34;&#34;&#34;
        if min_v &lt;= 0:
            raise MlError(f&#34;min_v={min_v} must be &gt; 0&#34;)

        self.windows = list(map(lambda window: window.prune_lt(min_v), self.windows))
        return self

    def retain_top(self, n: int) -&gt; &#34;ExtractedMl&#34;:
        &#34;&#34;&#34;
        Sorts labels in descending order by score and only keeps up to the top n labels.
        :param n: The number of labels to keep.
        :return: An updated instance of ExtractedMl.
        &#34;&#34;&#34;
        if n &lt;= 0:
            raise MlError(f&#34;n={n} must be &gt; 0&#34;)

        self.windows = list(map(lambda window: window.retain_top(n), self.windows))
        return self</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.metadata"><code class="name">var <span class="ident">metadata</span> : <a title="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata" href="#redvox.api1000.wrapped_redvox_packet.ml.MlMetadata">MlMetadata</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.windows"><code class="name">var <span class="ident">windows</span> : List[<a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow">MlWindow</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.prune_lt"><code class="name flex">
<span>def <span class="ident">prune_lt</span></span>(<span>self, min_v: float) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl">ExtractedMl</a></span>
</code></dt>
<dd>
<div class="desc"><p>Prunes labels with score less than the provided minimum.
:param min_v: The minimum acceptable label score.
:return: An updated instance of ExtractedMl.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prune_lt(self, min_v: float) -&gt; &#34;ExtractedMl&#34;:
    &#34;&#34;&#34;
    Prunes labels with score less than the provided minimum.
    :param min_v: The minimum acceptable label score.
    :return: An updated instance of ExtractedMl.
    &#34;&#34;&#34;
    if min_v &lt;= 0:
        raise MlError(f&#34;min_v={min_v} must be &gt; 0&#34;)

    self.windows = list(map(lambda window: window.prune_lt(min_v), self.windows))
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.prune_zeros"><code class="name flex">
<span>def <span class="ident">prune_zeros</span></span>(<span>self) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl">ExtractedMl</a></span>
</code></dt>
<dd>
<div class="desc"><p>Removes labels that have a score of 0.
:return: An updated instance of ExtractedMl.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prune_zeros(self) -&gt; &#34;ExtractedMl&#34;:
    &#34;&#34;&#34;
    Removes labels that have a score of 0.
    :return: An updated instance of ExtractedMl.
    &#34;&#34;&#34;
    self.windows = list(map(lambda window: window.prune_zeros(), self.windows))
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.retain_top"><code class="name flex">
<span>def <span class="ident">retain_top</span></span>(<span>self, n: int) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl">ExtractedMl</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sorts labels in descending order by score and only keeps up to the top n labels.
:param n: The number of labels to keep.
:return: An updated instance of ExtractedMl.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retain_top(self, n: int) -&gt; &#34;ExtractedMl&#34;:
    &#34;&#34;&#34;
    Sorts labels in descending order by score and only keeps up to the top n labels.
    :param n: The number of labels to keep.
    :return: An updated instance of ExtractedMl.
    &#34;&#34;&#34;
    if n &lt;= 0:
        raise MlError(f&#34;n={n} must be &gt; 0&#34;)

    self.windows = list(map(lambda window: window.retain_top(n), self.windows))
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, sort_by: <a title="redvox.api1000.wrapped_redvox_packet.ml.SortBy" href="#redvox.api1000.wrapped_redvox_packet.ml.SortBy">SortBy</a>) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl">ExtractedMl</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sorts the labels in ascending or descending order by either score of class name.
:param sort_by: The sort operation to use.
:return: An updated instance of ExtractedMl.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, sort_by: &#34;SortBy&#34;) -&gt; &#34;ExtractedMl&#34;:
    &#34;&#34;&#34;
    Sorts the labels in ascending or descending order by either score of class name.
    :param sort_by: The sort operation to use.
    :return: An updated instance of ExtractedMl.
    &#34;&#34;&#34;
    self.windows = list(map(lambda window: window.sort(sort_by), self.windows))
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.Label"><code class="flex name class">
<span>class <span class="ident">Label</span></span>
<span>(</span><span>class_name: str, score: float)</span>
</code></dt>
<dd>
<div class="desc"><p>A pair containing a class name and a score.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Label:
    &#34;&#34;&#34;
    A pair containing a class name and a score.
    &#34;&#34;&#34;

    class_name: str
    score: float</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.Label.class_name"><code class="name">var <span class="ident">class_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.Label.score"><code class="name">var <span class="ident">score</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlError"><code class="flex name class">
<span>class <span class="ident">MlError</span></span>
<span>(</span><span>msg: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents generic RedVox SDK errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MlError(RedVoxError):
    def __init__(self, msg: str):
        super().__init__(f&#34;MlError: {msg}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="redvox.common.errors.RedVoxError" href="../../common/errors.html#redvox.common.errors.RedVoxError">RedVoxError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata"><code class="flex name class">
<span>class <span class="ident">MlMetadata</span></span>
<span>(</span><span>model_name: str, model_version: str, input_samples_per_hop: int, input_sample_rate: int, input_samples_per_window: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Metadata relating to the utilized ML model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class MlMetadata:
    &#34;&#34;&#34;
    Metadata relating to the utilized ML model.
    &#34;&#34;&#34;

    model_name: str
    model_version: str
    input_samples_per_hop: int
    input_sample_rate: int
    input_samples_per_window: int</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.input_sample_rate"><code class="name">var <span class="ident">input_sample_rate</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.input_samples_per_hop"><code class="name">var <span class="ident">input_samples_per_hop</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.input_samples_per_window"><code class="name">var <span class="ident">input_samples_per_window</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.model_name"><code class="name">var <span class="ident">model_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.model_version"><code class="name">var <span class="ident">model_version</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlWindow"><code class="flex name class">
<span>class <span class="ident">MlWindow</span></span>
<span>(</span><span>timestamp: int, labels: List[ForwardRef('<a title="redvox.api1000.wrapped_redvox_packet.ml.Label" href="#redvox.api1000.wrapped_redvox_packet.ml.Label">Label</a>')])</span>
</code></dt>
<dd>
<div class="desc"><p>Labels from a single time window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class MlWindow:
    &#34;&#34;&#34;
    Labels from a single time window.
    &#34;&#34;&#34;

    timestamp: int
    labels: List[&#34;Label&#34;]

    def sort(self, sort_by: &#34;SortBy&#34;) -&gt; &#34;MlWindow&#34;:
        &#34;&#34;&#34;
        Sorts the labels in ascending or descending order by either score of class name.
        :param sort_by: The sort operation to use.
        :return: An updated instance of MlWindow.
        &#34;&#34;&#34;
        if sort_by is SortBy.CLASS_ASC:
            self.labels = sorted(self.labels, key=lambda label: label.class_name)
        elif sort_by is SortBy.CLASS_DESC:
            self.labels = sorted(
                self.labels, key=lambda label: label.class_name, reverse=True
            )
        elif sort_by is SortBy.SCORE_ASC:
            self.labels = sorted(self.labels, key=lambda label: label.score)
        else:
            self.labels = sorted(
                self.labels, key=lambda label: label.score, reverse=True
            )

        return self

    def prune_zeros(self) -&gt; &#34;MlWindow&#34;:
        &#34;&#34;&#34;
        Removes labels that have a score of 0.
        :return: An updated instance of MlWindow.
        &#34;&#34;&#34;
        self.labels = list(filter(lambda label: label.score &gt; 0, self.labels))
        return self

    def prune_lt(self, min_v: float) -&gt; &#34;MlWindow&#34;:
        &#34;&#34;&#34;
        Prunes labels with score less than the provided minimum.
        :param min_v: The minimum acceptable label score.
        :return: An updated instance of MlWindow.
        &#34;&#34;&#34;
        if min_v &lt;= 0:
            raise MlError(f&#34;min_v={min_v} must be &gt; 0&#34;)

        self.labels = list(filter(lambda label: label.score &gt;= min_v, self.labels))
        return self

    def retain_top(self, n: int) -&gt; &#34;MlWindow&#34;:
        &#34;&#34;&#34;
        Sorts labels in descending order by score and only keeps up to the top n labels.
        :param n: The number of labels to keep.
        :return: An updated instance of MlWindow.
        &#34;&#34;&#34;
        if n &lt;= 0:
            raise MlError(f&#34;n={n} must be &gt; 0&#34;)

        sorted_window: MlWindow = self.sort(SortBy.SCORE_DESC)
        sorted_window.labels = sorted_window.labels[:n]
        return sorted_window</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.labels"><code class="name">var <span class="ident">labels</span> : List[<a title="redvox.api1000.wrapped_redvox_packet.ml.Label" href="#redvox.api1000.wrapped_redvox_packet.ml.Label">Label</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.timestamp"><code class="name">var <span class="ident">timestamp</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.prune_lt"><code class="name flex">
<span>def <span class="ident">prune_lt</span></span>(<span>self, min_v: float) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow">MlWindow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Prunes labels with score less than the provided minimum.
:param min_v: The minimum acceptable label score.
:return: An updated instance of MlWindow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prune_lt(self, min_v: float) -&gt; &#34;MlWindow&#34;:
    &#34;&#34;&#34;
    Prunes labels with score less than the provided minimum.
    :param min_v: The minimum acceptable label score.
    :return: An updated instance of MlWindow.
    &#34;&#34;&#34;
    if min_v &lt;= 0:
        raise MlError(f&#34;min_v={min_v} must be &gt; 0&#34;)

    self.labels = list(filter(lambda label: label.score &gt;= min_v, self.labels))
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.prune_zeros"><code class="name flex">
<span>def <span class="ident">prune_zeros</span></span>(<span>self) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow">MlWindow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Removes labels that have a score of 0.
:return: An updated instance of MlWindow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prune_zeros(self) -&gt; &#34;MlWindow&#34;:
    &#34;&#34;&#34;
    Removes labels that have a score of 0.
    :return: An updated instance of MlWindow.
    &#34;&#34;&#34;
    self.labels = list(filter(lambda label: label.score &gt; 0, self.labels))
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.retain_top"><code class="name flex">
<span>def <span class="ident">retain_top</span></span>(<span>self, n: int) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow">MlWindow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sorts labels in descending order by score and only keeps up to the top n labels.
:param n: The number of labels to keep.
:return: An updated instance of MlWindow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retain_top(self, n: int) -&gt; &#34;MlWindow&#34;:
    &#34;&#34;&#34;
    Sorts labels in descending order by score and only keeps up to the top n labels.
    :param n: The number of labels to keep.
    :return: An updated instance of MlWindow.
    &#34;&#34;&#34;
    if n &lt;= 0:
        raise MlError(f&#34;n={n} must be &gt; 0&#34;)

    sorted_window: MlWindow = self.sort(SortBy.SCORE_DESC)
    sorted_window.labels = sorted_window.labels[:n]
    return sorted_window</code></pre>
</details>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, sort_by: <a title="redvox.api1000.wrapped_redvox_packet.ml.SortBy" href="#redvox.api1000.wrapped_redvox_packet.ml.SortBy">SortBy</a>) ‑> <a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow">MlWindow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sorts the labels in ascending or descending order by either score of class name.
:param sort_by: The sort operation to use.
:return: An updated instance of MlWindow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, sort_by: &#34;SortBy&#34;) -&gt; &#34;MlWindow&#34;:
    &#34;&#34;&#34;
    Sorts the labels in ascending or descending order by either score of class name.
    :param sort_by: The sort operation to use.
    :return: An updated instance of MlWindow.
    &#34;&#34;&#34;
    if sort_by is SortBy.CLASS_ASC:
        self.labels = sorted(self.labels, key=lambda label: label.class_name)
    elif sort_by is SortBy.CLASS_DESC:
        self.labels = sorted(
            self.labels, key=lambda label: label.class_name, reverse=True
        )
    elif sort_by is SortBy.SCORE_ASC:
        self.labels = sorted(self.labels, key=lambda label: label.score)
    else:
        self.labels = sorted(
            self.labels, key=lambda label: label.score, reverse=True
        )

    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.SortBy"><code class="flex name class">
<span>class <span class="ident">SortBy</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration that represents the valid label sorting methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SortBy(Enum):
    &#34;&#34;&#34;
    An enumeration that represents the valid label sorting methods.
    &#34;&#34;&#34;

    SCORE_ASC: int = 1
    SCORE_DESC: int = 2
    CLASS_ASC: int = 3
    CLASS_DESC: int = 4</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.SortBy.CLASS_ASC"><code class="name">var <span class="ident">CLASS_ASC</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.SortBy.CLASS_DESC"><code class="name">var <span class="ident">CLASS_DESC</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.SortBy.SCORE_ASC"><code class="name">var <span class="ident">SCORE_ASC</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.wrapped_redvox_packet.ml.SortBy.SCORE_DESC"><code class="name">var <span class="ident">SCORE_DESC</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.api1000.wrapped_redvox_packet" href="index.html">redvox.api1000.wrapped_redvox_packet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_from_event_stream" href="#redvox.api1000.wrapped_redvox_packet.ml.extract_ml_from_event_stream">extract_ml_from_event_stream</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_from_file" href="#redvox.api1000.wrapped_redvox_packet.ml.extract_ml_from_file">extract_ml_from_file</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_from_packet" href="#redvox.api1000.wrapped_redvox_packet.ml.extract_ml_from_packet">extract_ml_from_packet</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_metadata" href="#redvox.api1000.wrapped_redvox_packet.ml.extract_ml_metadata">extract_ml_metadata</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.extract_ml_windows" href="#redvox.api1000.wrapped_redvox_packet.ml.extract_ml_windows">extract_ml_windows</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.find_ml_event_stream" href="#redvox.api1000.wrapped_redvox_packet.ml.find_ml_event_stream">find_ml_event_stream</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.label_at" href="#redvox.api1000.wrapped_redvox_packet.ml.label_at">label_at</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl">ExtractedMl</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.metadata" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.metadata">metadata</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.prune_lt" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.prune_lt">prune_lt</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.prune_zeros" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.prune_zeros">prune_zeros</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.retain_top" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.retain_top">retain_top</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.sort" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.sort">sort</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.windows" href="#redvox.api1000.wrapped_redvox_packet.ml.ExtractedMl.windows">windows</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.api1000.wrapped_redvox_packet.ml.Label" href="#redvox.api1000.wrapped_redvox_packet.ml.Label">Label</a></code></h4>
<ul class="">
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.Label.class_name" href="#redvox.api1000.wrapped_redvox_packet.ml.Label.class_name">class_name</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.Label.score" href="#redvox.api1000.wrapped_redvox_packet.ml.Label.score">score</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlError" href="#redvox.api1000.wrapped_redvox_packet.ml.MlError">MlError</a></code></h4>
</li>
<li>
<h4><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata" href="#redvox.api1000.wrapped_redvox_packet.ml.MlMetadata">MlMetadata</a></code></h4>
<ul class="">
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.input_sample_rate" href="#redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.input_sample_rate">input_sample_rate</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.input_samples_per_hop" href="#redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.input_samples_per_hop">input_samples_per_hop</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.input_samples_per_window" href="#redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.input_samples_per_window">input_samples_per_window</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.model_name" href="#redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.model_name">model_name</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.model_version" href="#redvox.api1000.wrapped_redvox_packet.ml.MlMetadata.model_version">model_version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow">MlWindow</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.labels" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow.labels">labels</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.prune_lt" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow.prune_lt">prune_lt</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.prune_zeros" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow.prune_zeros">prune_zeros</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.retain_top" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow.retain_top">retain_top</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.sort" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow.sort">sort</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.MlWindow.timestamp" href="#redvox.api1000.wrapped_redvox_packet.ml.MlWindow.timestamp">timestamp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.api1000.wrapped_redvox_packet.ml.SortBy" href="#redvox.api1000.wrapped_redvox_packet.ml.SortBy">SortBy</a></code></h4>
<ul class="">
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.SortBy.CLASS_ASC" href="#redvox.api1000.wrapped_redvox_packet.ml.SortBy.CLASS_ASC">CLASS_ASC</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.SortBy.CLASS_DESC" href="#redvox.api1000.wrapped_redvox_packet.ml.SortBy.CLASS_DESC">CLASS_DESC</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.SortBy.SCORE_ASC" href="#redvox.api1000.wrapped_redvox_packet.ml.SortBy.SCORE_ASC">SCORE_ASC</a></code></li>
<li><code><a title="redvox.api1000.wrapped_redvox_packet.ml.SortBy.SCORE_DESC" href="#redvox.api1000.wrapped_redvox_packet.ml.SortBy.SCORE_DESC">SCORE_DESC</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>