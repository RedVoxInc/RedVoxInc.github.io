<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>redvox.common.offset_model API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.common.offset_model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from typing import Tuple

MIN_VALID_LATENCY_MICROS = 100              # minimum value of latency before it&#39;s unreliable
DEFAULT_SAMPLES = 3                         # default number of samples per bin
MIN_SAMPLES = 3                             # minimum number of samples per 5 minutes for reliable data
MIN_TIMESYNC_DURATION_MIN = 5               # minimum number of minutes of data required to produce reliable results


class OffsetModel:
    &#34;&#34;&#34;
    Offset model which represents the change in offset over a period of time
    Properties:
        start_time: float, start timestamp of model in microseconds since epoch UTC
        end_time: float, end timestamp of model in microseconds since epoch UTC
        k_bins: int, the number of data bins used to create the model
        n_samples: int, the number of samples per data bin; 3 is the minimum to create a balanced line
        slope: float, the slope of the change in offset
        intercept: float, the offset at start_time
    &#34;&#34;&#34;
    def __init__(self, latencies: np.ndarray, offsets: np.ndarray, times: np.ndarray,
                 start_time: float, end_time: float, n_samples: int = DEFAULT_SAMPLES):
        &#34;&#34;&#34;
        Create an OffsetModel
        :param latencies: latencies within the time specified
        :param offsets: offsets that correspond to the latencies
        :param times: timestamps that correspond to the latencies
        :param start_time: model&#39;s start timestamp in microseconds since epoch utc
        :param end_time: model&#39;s end timestamp in microseconds since epoch utc
        :param n_samples: number of samples per bin, default 3
        &#34;&#34;&#34;
        self.start_time = start_time
        self.end_time = end_time
        self.k_bins = get_bins_per_5min(start_time, end_time)
        self.n_samples = n_samples
        latencies = np.where(latencies &lt; MIN_VALID_LATENCY_MICROS, np.nan, latencies)
        use_model = timesync_quality_check(latencies, start_time, end_time)
        if use_model:
            self.slope, self.intercept = get_offset_function(latencies, offsets, times, self.k_bins,
                                                             n_samples, start_time, end_time)
            use_model = self.slope != 0.0
        # if data or model is not sufficient, use the offset corresponding to lowest latency:
        if not use_model:
            self.slope = 0.0
            if all(np.nan_to_num(latencies) == 0.0):
                self.intercept = 0.0
            else:
                best_latency = np.nanmin(latencies[np.nonzero(latencies)])
                self.intercept = offsets[np.argwhere(latencies == best_latency)[0][0]]

    @staticmethod
    def empty_model() -&gt; &#34;OffsetModel&#34;:
        &#34;&#34;&#34;
        :return: an empty model with default values
        &#34;&#34;&#34;
        return OffsetModel(np.array([]), np.array([]), np.array([]), 0, 0)

    def get_offset_at_new_time(self, new_time: float) -&gt; float:
        &#34;&#34;&#34;
        Get&#39;s offset at new_time time based on the offset model.
        :param new_time: The time of corresponding to the new offset
        :return: new offset corresponding to the new_time
        &#34;&#34;&#34;
        return get_offset_at_new_time(new_time, self.slope, self.intercept, self.start_time)

    def update_time(self, new_time: float) -&gt; float:
        &#34;&#34;&#34;
        update new_time time based on the offset model.
        :param new_time: The time to update
        :return: updated new_time
        &#34;&#34;&#34;
        return new_time + self.get_offset_at_new_time(new_time)


# Method to get number of bins
def get_bins_per_5min(start_time: float, end_time: float) -&gt; int:
    &#34;&#34;&#34;
    Calculates number of bins needed for roughly 5 minute bins.
        k_bins = int((end_time - start_time) / (300 * 1e6) + 1)
    :param start_time: the time used to compute the intercept (offset) and time bins; use start time of first packet
    :param end_time: the time used to compute the time bins; use start time of last packet + packet duration
    :return: number of bins to use for offset model
    &#34;&#34;&#34;

    # Divide the duration by 5 minutes
    return int((end_time - start_time) / (1e6 * 300) + 1)


# min max scaling for the weights
def minmax_scale(data: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns scaled data by subtracting the min value and dividing by (max - min) value.
    :param data: the data to be scaled
    :return: scaled data
    &#34;&#34;&#34;
    # Use np.nanmin and np.nanmax to avoid issues with nan values
    return (data - np.nanmin(data)) / (np.nanmax(data) - np.nanmin(data))


# The Weighted Linear Regression Function for offsets
def offset_weighted_linear_regression(latencies: np.ndarray, offsets: np.ndarray,
                                      times: np.ndarray) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Computes and returns the slope and intercept for the offset function (offset = slope * time + intercept)
    The intercept is based on first UTC time 0, all units are in microseconds
    :param latencies: array of the best latencies per packet
    :param offsets: array of offsets corresponding to the best latencies per packet
    :param times: array of device times corresponding to the best latencies per packet
    :return:  slope, intercept
    &#34;&#34;&#34;

    if all(np.isnan(latencies)):
        return 0.0, 0.0

    # Compute the weights for the linear regression by the latencies
    latencies_ms = latencies / 1e3
    weights = latencies_ms ** -2
    norm_weights = minmax_scale(weights)

    # Set up the weighted linear regression
    wls = LinearRegression()
    wls.fit(X=times.reshape(-1, 1),
            y=offsets.reshape(-1, 1),
            sample_weight=norm_weights)

    # return the slope and intercept
    return wls.coef_[0][0], wls.intercept_[0]


# Function to correct the intercept value
def get_offset_at_new_time(new_time: float, slope: float, intercept: float, model_time: float) -&gt; float:
    &#34;&#34;&#34;
    Get&#39;s offset at new_time time based on the offset model.
    :param new_time: The time of corresponding to the new offset
    :param slope: slope of the offset model
    :param intercept: the intercept of the offset model relative to the model_time
    :param model_time: the time corresponding to the intercept of the offset model
    :return: new offset corresponding to the new_time
    &#34;&#34;&#34;
    # get the time difference
    time_diff = new_time - model_time

    # apply the offset model to get new intercept
    new_offset = slope * time_diff + intercept

    return new_offset


# Function to get the subset data frame to do the weighted linear regression
def get_binned_df(full_df: pd.DataFrame, bin_times: np.ndarray, n_samples: float) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Returns a subset of the full_df with n_samples per binned times.
    nan latencies values will be ignored.
    :param full_df: pandas DataFrame containing latencies, offsets, and times.
    :param bin_times: array of edge times for each bin
    :param n_samples: number of samples to take per bin
    :return: binned_df
    &#34;&#34;&#34;

    # Initialize the data frame
    binned_df = pd.DataFrame()

    # Loop through each bin and get the n smallest samples
    for i in range(len(bin_times)-1):
        # select the time range
        select_df = full_df[full_df[&#39;times&#39;] &lt; bin_times[i + 1]]
        select_df = select_df[select_df[&#39;times&#39;] &gt; bin_times[i]]

        # select n_samples smallest values (ignores nan values)
        n_smallest = select_df.nsmallest(n_samples, &#39;latencies&#39;)

        # append the n_smallest entries
        binned_df = binned_df.append(n_smallest)

    # Sort the binned_df by time
    binned_df = binned_df.sort_values(by=[&#39;times&#39;])

    return binned_df


# The main function
def get_offset_function(latencies: np.ndarray, offsets: np.ndarray, times: np.ndarray,
                        k_bins: int, n_samples: int, start_time: float, end_time: float) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Computes and returns the slope and intercept for the offset function (offset = slope * time + intercept)
    The data is binned by k_bins in equally spaced times, the n_samples best latencies are taken to be used to get
    the weighted linear regression. The slope and intercept is then returned as the offset model.
    The intercept is offset at first_start_time.
    :param latencies: array of the best latencies per packet
    :param offsets: array of offsets corresponding to the best latencies per packet
    :param times: array of device times corresponding to the best latencies per packet
    :param k_bins: number of bins to separate the latencies
    :param n_samples: number of points to use per bins
    :param start_time: the time used to compute the intercept (offset) and time bins; use start time of first packet
    :param end_time: the time used to compute the time bins; use start time of last packet + packet duration
    :return: slope, intercept
    &#34;&#34;&#34;

    # Organize the data into a data frame
    full_df = pd.DataFrame(data=times, columns=[&#39;times&#39;])
    full_df[&#39;latencies&#39;] = latencies
    full_df[&#39;offsets&#39;] = offsets

    # Get the index for the separations (add +1 to k_bins so that there would be k_bins bins)
    bin_times = np.linspace(start_time, end_time, k_bins + 1)

    # Make the dataframe with the data with n_samples per bins
    binned_df = get_binned_df(full_df=full_df,
                              bin_times=bin_times,
                              n_samples=n_samples)

    # Compute the weighted linear regression
    slope, zero_intercept = offset_weighted_linear_regression(latencies=binned_df[&#39;latencies&#39;].values,
                                                              offsets=binned_df[&#39;offsets&#39;].values,
                                                              times=binned_df[&#39;times&#39;].values)

    # Get offset relative to the first time
    intercept = get_offset_at_new_time(new_time=start_time,
                                       slope=slope,
                                       intercept=zero_intercept,
                                       model_time=0)

    return slope, intercept


def timesync_quality_check(latencies: np.ndarray, start_time: float, end_time: float, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    Checks quality of timesync data to determine if offset model should be used.
    The following list is the quality check:
        If timesync duration is longer than 5 min
        If there are 3 latency values (non-nan) per 5 minutes on average
    Returns False if the data quality is not up to &#34;standards&#34;.
    :param latencies: array of the best latencies per packet
    :param start_time: the time used to compute the intercept (offset) and time bins; use start time of first packet
    :param end_time: the time used to compute the time bins; use start time of last packet + packet duration
    :param debug: if True, reason for failing quality check is printed, default False
    :return: True if timesync data passes all quality checks, False otherwise
    &#34;&#34;&#34;

    # Check the Duration of the signal of interest
    duration_min = (end_time - start_time) / (1e6 * 60)

    if duration_min &lt; MIN_TIMESYNC_DURATION_MIN:
        if debug:
            print(f&#39;Timesync data duration less than {MIN_TIMESYNC_DURATION_MIN} min&#39;)
        return False

    # Check average number of points per 5 min (pretty arbitrary, but maybe 3 points per 5 min)
    points_per_5min = 5 * np.count_nonzero(~np.isnan(latencies)) / duration_min

    if points_per_5min &lt; MIN_SAMPLES:
        if debug:
            print(f&#39;Less than {MIN_SAMPLES} of timesync data per 5 min&#39;)
        return False

    # Return True if it meets the above criteria
    return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.common.offset_model.get_binned_df"><code class="name flex">
<span>def <span class="ident">get_binned_df</span></span>(<span>full_df: pandas.core.frame.DataFrame, bin_times: numpy.ndarray, n_samples: float) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a subset of the full_df with n_samples per binned times.
nan latencies values will be ignored.
:param full_df: pandas DataFrame containing latencies, offsets, and times.
:param bin_times: array of edge times for each bin
:param n_samples: number of samples to take per bin
:return: binned_df</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_binned_df(full_df: pd.DataFrame, bin_times: np.ndarray, n_samples: float) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Returns a subset of the full_df with n_samples per binned times.
    nan latencies values will be ignored.
    :param full_df: pandas DataFrame containing latencies, offsets, and times.
    :param bin_times: array of edge times for each bin
    :param n_samples: number of samples to take per bin
    :return: binned_df
    &#34;&#34;&#34;

    # Initialize the data frame
    binned_df = pd.DataFrame()

    # Loop through each bin and get the n smallest samples
    for i in range(len(bin_times)-1):
        # select the time range
        select_df = full_df[full_df[&#39;times&#39;] &lt; bin_times[i + 1]]
        select_df = select_df[select_df[&#39;times&#39;] &gt; bin_times[i]]

        # select n_samples smallest values (ignores nan values)
        n_smallest = select_df.nsmallest(n_samples, &#39;latencies&#39;)

        # append the n_smallest entries
        binned_df = binned_df.append(n_smallest)

    # Sort the binned_df by time
    binned_df = binned_df.sort_values(by=[&#39;times&#39;])

    return binned_df</code></pre>
</details>
</dd>
<dt id="redvox.common.offset_model.get_bins_per_5min"><code class="name flex">
<span>def <span class="ident">get_bins_per_5min</span></span>(<span>start_time: float, end_time: float) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates number of bins needed for roughly 5 minute bins.
k_bins = int((end_time - start_time) / (300 * 1e6) + 1)
:param start_time: the time used to compute the intercept (offset) and time bins; use start time of first packet
:param end_time: the time used to compute the time bins; use start time of last packet + packet duration
:return: number of bins to use for offset model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bins_per_5min(start_time: float, end_time: float) -&gt; int:
    &#34;&#34;&#34;
    Calculates number of bins needed for roughly 5 minute bins.
        k_bins = int((end_time - start_time) / (300 * 1e6) + 1)
    :param start_time: the time used to compute the intercept (offset) and time bins; use start time of first packet
    :param end_time: the time used to compute the time bins; use start time of last packet + packet duration
    :return: number of bins to use for offset model
    &#34;&#34;&#34;

    # Divide the duration by 5 minutes
    return int((end_time - start_time) / (1e6 * 300) + 1)</code></pre>
</details>
</dd>
<dt id="redvox.common.offset_model.get_offset_at_new_time"><code class="name flex">
<span>def <span class="ident">get_offset_at_new_time</span></span>(<span>new_time: float, slope: float, intercept: float, model_time: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get's offset at new_time time based on the offset model.
:param new_time: The time of corresponding to the new offset
:param slope: slope of the offset model
:param intercept: the intercept of the offset model relative to the model_time
:param model_time: the time corresponding to the intercept of the offset model
:return: new offset corresponding to the new_time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offset_at_new_time(new_time: float, slope: float, intercept: float, model_time: float) -&gt; float:
    &#34;&#34;&#34;
    Get&#39;s offset at new_time time based on the offset model.
    :param new_time: The time of corresponding to the new offset
    :param slope: slope of the offset model
    :param intercept: the intercept of the offset model relative to the model_time
    :param model_time: the time corresponding to the intercept of the offset model
    :return: new offset corresponding to the new_time
    &#34;&#34;&#34;
    # get the time difference
    time_diff = new_time - model_time

    # apply the offset model to get new intercept
    new_offset = slope * time_diff + intercept

    return new_offset</code></pre>
</details>
</dd>
<dt id="redvox.common.offset_model.get_offset_function"><code class="name flex">
<span>def <span class="ident">get_offset_function</span></span>(<span>latencies: numpy.ndarray, offsets: numpy.ndarray, times: numpy.ndarray, k_bins: int, n_samples: int, start_time: float, end_time: float) ‑> typing.Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns the slope and intercept for the offset function (offset = slope * time + intercept)
The data is binned by k_bins in equally spaced times, the n_samples best latencies are taken to be used to get
the weighted linear regression. The slope and intercept is then returned as the offset model.
The intercept is offset at first_start_time.
:param latencies: array of the best latencies per packet
:param offsets: array of offsets corresponding to the best latencies per packet
:param times: array of device times corresponding to the best latencies per packet
:param k_bins: number of bins to separate the latencies
:param n_samples: number of points to use per bins
:param start_time: the time used to compute the intercept (offset) and time bins; use start time of first packet
:param end_time: the time used to compute the time bins; use start time of last packet + packet duration
:return: slope, intercept</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offset_function(latencies: np.ndarray, offsets: np.ndarray, times: np.ndarray,
                        k_bins: int, n_samples: int, start_time: float, end_time: float) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Computes and returns the slope and intercept for the offset function (offset = slope * time + intercept)
    The data is binned by k_bins in equally spaced times, the n_samples best latencies are taken to be used to get
    the weighted linear regression. The slope and intercept is then returned as the offset model.
    The intercept is offset at first_start_time.
    :param latencies: array of the best latencies per packet
    :param offsets: array of offsets corresponding to the best latencies per packet
    :param times: array of device times corresponding to the best latencies per packet
    :param k_bins: number of bins to separate the latencies
    :param n_samples: number of points to use per bins
    :param start_time: the time used to compute the intercept (offset) and time bins; use start time of first packet
    :param end_time: the time used to compute the time bins; use start time of last packet + packet duration
    :return: slope, intercept
    &#34;&#34;&#34;

    # Organize the data into a data frame
    full_df = pd.DataFrame(data=times, columns=[&#39;times&#39;])
    full_df[&#39;latencies&#39;] = latencies
    full_df[&#39;offsets&#39;] = offsets

    # Get the index for the separations (add +1 to k_bins so that there would be k_bins bins)
    bin_times = np.linspace(start_time, end_time, k_bins + 1)

    # Make the dataframe with the data with n_samples per bins
    binned_df = get_binned_df(full_df=full_df,
                              bin_times=bin_times,
                              n_samples=n_samples)

    # Compute the weighted linear regression
    slope, zero_intercept = offset_weighted_linear_regression(latencies=binned_df[&#39;latencies&#39;].values,
                                                              offsets=binned_df[&#39;offsets&#39;].values,
                                                              times=binned_df[&#39;times&#39;].values)

    # Get offset relative to the first time
    intercept = get_offset_at_new_time(new_time=start_time,
                                       slope=slope,
                                       intercept=zero_intercept,
                                       model_time=0)

    return slope, intercept</code></pre>
</details>
</dd>
<dt id="redvox.common.offset_model.minmax_scale"><code class="name flex">
<span>def <span class="ident">minmax_scale</span></span>(<span>data: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns scaled data by subtracting the min value and dividing by (max - min) value.
:param data: the data to be scaled
:return: scaled data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minmax_scale(data: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Returns scaled data by subtracting the min value and dividing by (max - min) value.
    :param data: the data to be scaled
    :return: scaled data
    &#34;&#34;&#34;
    # Use np.nanmin and np.nanmax to avoid issues with nan values
    return (data - np.nanmin(data)) / (np.nanmax(data) - np.nanmin(data))</code></pre>
</details>
</dd>
<dt id="redvox.common.offset_model.offset_weighted_linear_regression"><code class="name flex">
<span>def <span class="ident">offset_weighted_linear_regression</span></span>(<span>latencies: numpy.ndarray, offsets: numpy.ndarray, times: numpy.ndarray) ‑> typing.Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns the slope and intercept for the offset function (offset = slope * time + intercept)
The intercept is based on first UTC time 0, all units are in microseconds
:param latencies: array of the best latencies per packet
:param offsets: array of offsets corresponding to the best latencies per packet
:param times: array of device times corresponding to the best latencies per packet
:return:
slope, intercept</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offset_weighted_linear_regression(latencies: np.ndarray, offsets: np.ndarray,
                                      times: np.ndarray) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Computes and returns the slope and intercept for the offset function (offset = slope * time + intercept)
    The intercept is based on first UTC time 0, all units are in microseconds
    :param latencies: array of the best latencies per packet
    :param offsets: array of offsets corresponding to the best latencies per packet
    :param times: array of device times corresponding to the best latencies per packet
    :return:  slope, intercept
    &#34;&#34;&#34;

    if all(np.isnan(latencies)):
        return 0.0, 0.0

    # Compute the weights for the linear regression by the latencies
    latencies_ms = latencies / 1e3
    weights = latencies_ms ** -2
    norm_weights = minmax_scale(weights)

    # Set up the weighted linear regression
    wls = LinearRegression()
    wls.fit(X=times.reshape(-1, 1),
            y=offsets.reshape(-1, 1),
            sample_weight=norm_weights)

    # return the slope and intercept
    return wls.coef_[0][0], wls.intercept_[0]</code></pre>
</details>
</dd>
<dt id="redvox.common.offset_model.timesync_quality_check"><code class="name flex">
<span>def <span class="ident">timesync_quality_check</span></span>(<span>latencies: numpy.ndarray, start_time: float, end_time: float, debug: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks quality of timesync data to determine if offset model should be used.
The following list is the quality check:
If timesync duration is longer than 5 min
If there are 3 latency values (non-nan) per 5 minutes on average
Returns False if the data quality is not up to "standards".
:param latencies: array of the best latencies per packet
:param start_time: the time used to compute the intercept (offset) and time bins; use start time of first packet
:param end_time: the time used to compute the time bins; use start time of last packet + packet duration
:param debug: if True, reason for failing quality check is printed, default False
:return: True if timesync data passes all quality checks, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timesync_quality_check(latencies: np.ndarray, start_time: float, end_time: float, debug: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    Checks quality of timesync data to determine if offset model should be used.
    The following list is the quality check:
        If timesync duration is longer than 5 min
        If there are 3 latency values (non-nan) per 5 minutes on average
    Returns False if the data quality is not up to &#34;standards&#34;.
    :param latencies: array of the best latencies per packet
    :param start_time: the time used to compute the intercept (offset) and time bins; use start time of first packet
    :param end_time: the time used to compute the time bins; use start time of last packet + packet duration
    :param debug: if True, reason for failing quality check is printed, default False
    :return: True if timesync data passes all quality checks, False otherwise
    &#34;&#34;&#34;

    # Check the Duration of the signal of interest
    duration_min = (end_time - start_time) / (1e6 * 60)

    if duration_min &lt; MIN_TIMESYNC_DURATION_MIN:
        if debug:
            print(f&#39;Timesync data duration less than {MIN_TIMESYNC_DURATION_MIN} min&#39;)
        return False

    # Check average number of points per 5 min (pretty arbitrary, but maybe 3 points per 5 min)
    points_per_5min = 5 * np.count_nonzero(~np.isnan(latencies)) / duration_min

    if points_per_5min &lt; MIN_SAMPLES:
        if debug:
            print(f&#39;Less than {MIN_SAMPLES} of timesync data per 5 min&#39;)
        return False

    # Return True if it meets the above criteria
    return True</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.common.offset_model.OffsetModel"><code class="flex name class">
<span>class <span class="ident">OffsetModel</span></span>
<span>(</span><span>latencies: numpy.ndarray, offsets: numpy.ndarray, times: numpy.ndarray, start_time: float, end_time: float, n_samples: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Offset model which represents the change in offset over a period of time</p>
<h2 id="properties">Properties</h2>
<p>start_time: float, start timestamp of model in microseconds since epoch UTC
end_time: float, end timestamp of model in microseconds since epoch UTC
k_bins: int, the number of data bins used to create the model
n_samples: int, the number of samples per data bin; 3 is the minimum to create a balanced line
slope: float, the slope of the change in offset
intercept: float, the offset at start_time</p>
<p>Create an OffsetModel
:param latencies: latencies within the time specified
:param offsets: offsets that correspond to the latencies
:param times: timestamps that correspond to the latencies
:param start_time: model's start timestamp in microseconds since epoch utc
:param end_time: model's end timestamp in microseconds since epoch utc
:param n_samples: number of samples per bin, default 3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OffsetModel:
    &#34;&#34;&#34;
    Offset model which represents the change in offset over a period of time
    Properties:
        start_time: float, start timestamp of model in microseconds since epoch UTC
        end_time: float, end timestamp of model in microseconds since epoch UTC
        k_bins: int, the number of data bins used to create the model
        n_samples: int, the number of samples per data bin; 3 is the minimum to create a balanced line
        slope: float, the slope of the change in offset
        intercept: float, the offset at start_time
    &#34;&#34;&#34;
    def __init__(self, latencies: np.ndarray, offsets: np.ndarray, times: np.ndarray,
                 start_time: float, end_time: float, n_samples: int = DEFAULT_SAMPLES):
        &#34;&#34;&#34;
        Create an OffsetModel
        :param latencies: latencies within the time specified
        :param offsets: offsets that correspond to the latencies
        :param times: timestamps that correspond to the latencies
        :param start_time: model&#39;s start timestamp in microseconds since epoch utc
        :param end_time: model&#39;s end timestamp in microseconds since epoch utc
        :param n_samples: number of samples per bin, default 3
        &#34;&#34;&#34;
        self.start_time = start_time
        self.end_time = end_time
        self.k_bins = get_bins_per_5min(start_time, end_time)
        self.n_samples = n_samples
        latencies = np.where(latencies &lt; MIN_VALID_LATENCY_MICROS, np.nan, latencies)
        use_model = timesync_quality_check(latencies, start_time, end_time)
        if use_model:
            self.slope, self.intercept = get_offset_function(latencies, offsets, times, self.k_bins,
                                                             n_samples, start_time, end_time)
            use_model = self.slope != 0.0
        # if data or model is not sufficient, use the offset corresponding to lowest latency:
        if not use_model:
            self.slope = 0.0
            if all(np.nan_to_num(latencies) == 0.0):
                self.intercept = 0.0
            else:
                best_latency = np.nanmin(latencies[np.nonzero(latencies)])
                self.intercept = offsets[np.argwhere(latencies == best_latency)[0][0]]

    @staticmethod
    def empty_model() -&gt; &#34;OffsetModel&#34;:
        &#34;&#34;&#34;
        :return: an empty model with default values
        &#34;&#34;&#34;
        return OffsetModel(np.array([]), np.array([]), np.array([]), 0, 0)

    def get_offset_at_new_time(self, new_time: float) -&gt; float:
        &#34;&#34;&#34;
        Get&#39;s offset at new_time time based on the offset model.
        :param new_time: The time of corresponding to the new offset
        :return: new offset corresponding to the new_time
        &#34;&#34;&#34;
        return get_offset_at_new_time(new_time, self.slope, self.intercept, self.start_time)

    def update_time(self, new_time: float) -&gt; float:
        &#34;&#34;&#34;
        update new_time time based on the offset model.
        :param new_time: The time to update
        :return: updated new_time
        &#34;&#34;&#34;
        return new_time + self.get_offset_at_new_time(new_time)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="redvox.common.offset_model.OffsetModel.empty_model"><code class="name flex">
<span>def <span class="ident">empty_model</span></span>(<span>) ‑> <a title="redvox.common.offset_model.OffsetModel" href="#redvox.common.offset_model.OffsetModel">OffsetModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>:return: an empty model with default values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty_model() -&gt; &#34;OffsetModel&#34;:
    &#34;&#34;&#34;
    :return: an empty model with default values
    &#34;&#34;&#34;
    return OffsetModel(np.array([]), np.array([]), np.array([]), 0, 0)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.common.offset_model.OffsetModel.get_offset_at_new_time"><code class="name flex">
<span>def <span class="ident">get_offset_at_new_time</span></span>(<span>self, new_time: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get's offset at new_time time based on the offset model.
:param new_time: The time of corresponding to the new offset
:return: new offset corresponding to the new_time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offset_at_new_time(self, new_time: float) -&gt; float:
    &#34;&#34;&#34;
    Get&#39;s offset at new_time time based on the offset model.
    :param new_time: The time of corresponding to the new offset
    :return: new offset corresponding to the new_time
    &#34;&#34;&#34;
    return get_offset_at_new_time(new_time, self.slope, self.intercept, self.start_time)</code></pre>
</details>
</dd>
<dt id="redvox.common.offset_model.OffsetModel.update_time"><code class="name flex">
<span>def <span class="ident">update_time</span></span>(<span>self, new_time: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>update new_time time based on the offset model.
:param new_time: The time to update
:return: updated new_time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_time(self, new_time: float) -&gt; float:
    &#34;&#34;&#34;
    update new_time time based on the offset model.
    :param new_time: The time to update
    :return: updated new_time
    &#34;&#34;&#34;
    return new_time + self.get_offset_at_new_time(new_time)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.common" href="index.html">redvox.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.common.offset_model.get_binned_df" href="#redvox.common.offset_model.get_binned_df">get_binned_df</a></code></li>
<li><code><a title="redvox.common.offset_model.get_bins_per_5min" href="#redvox.common.offset_model.get_bins_per_5min">get_bins_per_5min</a></code></li>
<li><code><a title="redvox.common.offset_model.get_offset_at_new_time" href="#redvox.common.offset_model.get_offset_at_new_time">get_offset_at_new_time</a></code></li>
<li><code><a title="redvox.common.offset_model.get_offset_function" href="#redvox.common.offset_model.get_offset_function">get_offset_function</a></code></li>
<li><code><a title="redvox.common.offset_model.minmax_scale" href="#redvox.common.offset_model.minmax_scale">minmax_scale</a></code></li>
<li><code><a title="redvox.common.offset_model.offset_weighted_linear_regression" href="#redvox.common.offset_model.offset_weighted_linear_regression">offset_weighted_linear_regression</a></code></li>
<li><code><a title="redvox.common.offset_model.timesync_quality_check" href="#redvox.common.offset_model.timesync_quality_check">timesync_quality_check</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.common.offset_model.OffsetModel" href="#redvox.common.offset_model.OffsetModel">OffsetModel</a></code></h4>
<ul class="">
<li><code><a title="redvox.common.offset_model.OffsetModel.empty_model" href="#redvox.common.offset_model.OffsetModel.empty_model">empty_model</a></code></li>
<li><code><a title="redvox.common.offset_model.OffsetModel.get_offset_at_new_time" href="#redvox.common.offset_model.OffsetModel.get_offset_at_new_time">get_offset_at_new_time</a></code></li>
<li><code><a title="redvox.common.offset_model.OffsetModel.update_time" href="#redvox.common.offset_model.OffsetModel.update_time">update_time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>